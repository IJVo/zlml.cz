-- Adminer 4.2.1 MySQL dump

SET NAMES utf8;
SET time_zone = '+00:00';
SET foreign_key_checks = 0;
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

DROP TABLE IF EXISTS `mirror_posts`;
CREATE TABLE `mirror_posts` (
  `id` int(11) NOT NULL,
  `title` text NOT NULL,
  `body` text NOT NULL,
  `date` datetime NOT NULL,
  PRIMARY KEY (`id`),
  FULLTEXT KEY `title` (`title`),
  FULLTEXT KEY `body` (`body`),
  FULLTEXT KEY `title_body` (`title`,`body`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO `mirror_posts` (`id`, `title`, `body`, `date`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\n\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\n\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\n\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\n\n/--code\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\n\\--\n\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58'),
(3,	'Lovec matematik',	'Znáte následující hádanku?\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\n\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\n\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\n\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26'),
(4,	'Tabulkový masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12'),
(6,	'Výpočet mediánu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39'),
(7,	'Osm návrhových přikázání',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14'),
(9,	'Návrhový vzor Singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--',	'2012-12-26 20:38:01'),
(10,	'Návrhový vzor Factory Method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://zlml.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39'),
(11,	'Nette 2.1-dev CliRouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem <code>php index.php</code>. Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze <code>php index.php Front:Homepage:default</code>.',	'2013-03-17 22:02:36'),
(74,	'Znovupoužitelný formulář',	'Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\nMotivace\n========\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\nPresenter\n=========\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n/--code php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n	/** @var \\ActualityFactory @inject */\n	public $actualityFactory;\n\n	private $id;\n\n	public function actionAktualita($id = NULL) {\n		$this->id = $id;\n	}\n\n	protected function createComponentForm() {\n		$control = $this->actualityFactory->create($this->id);\n		$control[\'form\']->onSuccess[] = function () {\n			$this->redirect(\'default\');\n		};\n		return $control;\n	}\n\n}\n\\--\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control[\'form\']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\nFactory\n=======\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n/--code php\n<?php\n\ninterface IActualityFactory {\n\n	/** @return \\Cntrl\\Actuality */\n	public function create();\n\n}\n\\--\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n/--code php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new Cntrl\\Actuality;\n		return $service;\n	}\n\n}\n\\--\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n/--code php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n	private $actualities;\n\n	public function __construct(App\\Actualities $actualities) {\n		$this->actualities = $actualities;\n	}\n\n	public function create($id) {\n		return new \\Cntrl\\Actuality($this->actualities, $id);\n	}\n\n}\n\\--\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	- ActualityFactory\n\\--\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\nSamotná komponenta\n==================\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n/--code php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n	private $actualities;\n	private $actuality;\n\n	public function __construct(App\\Actualities $actualities, $id) {\n		parent::__construct();\n		$this->actualities = $actualities;\n		$this->actuality = $this->actualities->findOneBy([\'id\' => $id]);\n	}\n\n	public function render() {\n		$this->template->setFile(__DIR__ . \'/Actuality.latte\');\n		$this->template->render();\n	}\n\n	protected function createComponentForm() {\n		$form = new UI\\Form;\n		$form->addText(\'headline\', \'Titulek:\');\n		$form->addTextArea(\'text\', \'Text:\');\n		$form->addSubmit(\'send\', \'Uložit\');\n		if($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n			$form->setDefaults(array(\n				\'headline\' => $this->actuality->headline,\n				\'text\' => $this->actuality->text,\n			));\n		}\n		$form->onSuccess[] = $this->actualityFormSucceeded;\n		return $form;\n	}\n\n	public function actualityFormSucceeded(UI\\Form $form) {\n		$values = $form->getValues();\n		try {\n			if(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n				$this->actuality = new Entity\\Actuality();\n			}\n			$this->actuality->headline = $values->headline;\n			$this->actuality->text = $values->text;\n			$this->actuality->date = new \\DateTime();\n			$this->actualities->save($this->actuality);\n			$this->presenter->flashMessage(\'Aktualita byla úspěšně uložena.\', \'success\');\n		} catch (\\Exception $exc) {\n			$this->presenter->flashMessage($exc->getMessage(), \'danger\');\n		}\n		//žádný redirect, až v presenteru!\n	}\n\n}\n\\--\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n/--code\n{control form}\n\\--\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)',	'2014-05-13 11:54:22'),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'<div class=\"alert alert-danger\">Následující text řeší starší verzi FineUploaderu `3.*`, nikoliv nejnovější. Hledáte-li aktuálnější návod, přečtěte si prosím http://zlml.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2...</div>\n\nA je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\n\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\n\n/--code html\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\n\n/--code html\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\n<div id=\"triggerUpload\">Nahrát obrázky</div>\n\\--\n\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\n\n/--code javascript\n$(function () {\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\n		$.nette.ext(\'uploader\', {\n			complete: function () { //zavěšení na konec ajaxového požadavku\n				var uploader = $(\'#image-uploader\').fineUploader({\n					request: {\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\n					},\n					text: {\n						uploadButton: \'Klikněte, nebo přetáhněte obrázky\',\n						cancelButton: \'zrušit\',\n						failUpload: \'Nahrání obrázku se nezdařilo\',\n						dragZone: \'Přetáhněte soubory sem\',\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\n						formatProgress: \'{percent}% z {total_size}\',\n						waitingForResponse: \'Zpracovávám...\'\n					},\n					autoUpload: false,\n					failedUploadTextDisplay: {\n						mode: \'custom\',\n						maxChars: 70,\n						responseProperty: \'error\',\n						enableTooltip: true\n					}\n				});\n				$(\'#triggerUpload\').click(function () {\n					uploader.fineUploader(\'uploadStoredFiles\');\n				});\n			}\n		});\n	}\n\n	$.nette.init(); //inicializace nette.ajax\n});\n\\--\n\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\nTen může vypadat například takto:\n\n/--code php\npublic function handleUpload($id) {\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\n	$uploader = new \\qqFileUploader($allowedExtensions);\n	//...\n	try {\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\n		$result[\'uploadName\'] = $uploader->getUploadName();\n		//...\n	} catch (\\Exception $exc) {\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\n			\'error\' => $exc->getMessage(),\n		)));\n	}\n	$this->invalidateControl();\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\njako úspěšný upload.\n\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\no webalize názvů souborů.\n\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použít.\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2013-08-21 22:14:44'),
(44,	'Portál ZČU dočasně mimo provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n<div class=\"alert alert-danger\">Tak dlouho jsem s tímto blogem experimentoval, až jsem o obrázek \npřišel. :-( Představte si tedy prosím screen vyhledávání na kterém je portál ZČU se zaindexovaným\ntitle \"Portál ZČU dočasně mimo provoz&hellip;\"</div>\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42'),
(45,	'Testování presenterů v Nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38'),
(46,	'CRON validátor',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--',	'2013-07-28 22:53:32'),
(47,	'Třída pro připojení k FIO API',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://zlml.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         * @return array|mixed\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last/\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44'),
(61,	'Stáhněte si zdarma 897457 emailových adres',	'V následujícím článku bych rád nastínil problematiku newsletterů nejen z programátorského hlediska <s>a také bych se rád opřel do bezpečnosti společnosti Wedos, které mnoho lidí tolik věří</s>... (-:\n\n<span style=\"color:green\">Tento projekt pravděpodobně nemá se společností Wedos nic společného jak jsem si zřejmě mylně myslel.</span>\n\nNa začátku byl email\n====================\nJednoho dne mi přišel email, který byl automaticky filtrován jako spam. Vzhledem k tomu, že když mě něco štve, tak to řeším, spam jsem otevřel a hledal odkaz na odhlášení. Ten byl dobře umístěn, stačilo kliknout a hotovo. Každý přece ví, že to takto má být. Když je odhlášení delší, než kliknutí na spam v email klientovi, je to problém. Bohužel tento odkaz vedlo na doménu <code>m-letter.eu</code>. Mě samozřejmě zajímá jak jsem se dostal do takového spam listu a jelikož jsem byl odkázán na mě neznámou doménu, byl jsem velmi rozezlen.\n\n<s>Zde je nutné říct, že jsem dříve jednal, než pátral. Nakonec se ukázalo, že jsem byl možná v tomto listu oprávněně, jelikož se jedná o doménu, ze které zřejmě Wedos odesílá podobné reklamní emaily, takže je dost pravděpodobné, že jsem s tím dříve souhlasil.</s>\n\n<span style=\"color:green\">Při hlubším pátrání jsem zjistil, že jsem stále nic nezjistil. Chybně jsem tento problém svedl na někoho jiného, což mě odvedlo na špatnou kolej. Stále tedy nevím, kde jsem se na tomto spam listu vzal a opět to beru osobně. Není mi to jedno...</span>\n\nNeštvi programátora\n===================\nCelý reklamní systém je udělán dosti nešťastně, takže než abych pátral jak jsem se tam dostal, soustředil jsem se na něco jiného, co pro mě z pohledu programátora webových aplikací bylo dost zajímavé. URL adresa. Celá adresa pro odhlášení je v následujícím formátu:\n\n/--code\nhttp://www.m-letter.eu/odh.html?c=XXXXXXX&s=53&q=51\n\\--\n\nKde **XXXXXXX** je číslo zhruba od 1300486 do 2197943. To mě zaujalo a tak jsem toto číslo začal měnit. A ukázalo se, že jsem odhlašoval další lidi. V té době ještě tato stránka vypsala informaci o úspěšném odhlášení včetně emailu, který byl odhlášen. Vzhledem k tomu, že stránka je velmi jednoduchá, lze programově stejně jednoduše získat onu emailovou adresu.\n\nJen si představte program, který iteruje tuto URL adresu a jen sbírá emaily. 897457. To je počet emailů které takto získáte. **897457**. Navíc tímto celý systém znehodnotíte, protože všechny odhlásíte. A pro takový počet emailů to již není zanedbatelné.\n\nTo má být jako oprava?\n======================\nNejde mi zrovna o to znehodnotit celý čupr dupr systém na spamování, ale proč ne. Tato informace se poměrně rychle rozšířila a o pár minut později mi byl odepřen přístup na tento server. Navíc výpis byl pozměněn tak, aby již nešlo stáhnout téměř 900 000 emailových adres. Nicméně celý systém zřejmě stále funguje stejně, takže můžete jednoduše iterovat URL adresy a tím celý systém znehodnotit:\n\n/--code php\n<?php\nfor ($i=2197943; $i > 1300486; $i--) {\n    file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\");\n}\n\\--\n\nDoporučuji spustit v příkazové řádce, kde není nastaven pro PHP timeout. Iterace je schválně pozpátku, protože se dá předpokládat, že ty nejnovější záznamy mají větší číslo a ty s malým číslem už dost možná nebudou aktuální. Celý program jsem měl daleko složitější, vzhledem k tomu, že jsem byl připraven na stáhnutí všech emailů. Po změně výpisu již většina programu není potřeba a stačí tedy tři řádky pro znehodnocení celého nezanedbatelně velkého systému.\n\n<s>Dejme tedy někomu z Wedos čas na opravu a pak hurá na hromadný lynč.</s> <span style=\"color:green\">Opět stejný problém jako předtím. Doufám, že mám tentokrát pravdu...</span> Sice jde jen o emailové adresy, ale vzpomeňte si na to až zase budete nadávat na spam, nebo souhlasit s tím, že vaše emailová adresa nebude nikde uveřejněna.',	'2014-01-27 12:33:57'),
(49,	'Using fulltext searching with InnoDB',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51'),
(50,	'Problémy fulltextu v Nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://zlml.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.',	'2013-07-30 22:15:33'),
(51,	'Routování v Nette - prakticky',	'<div class=\"alert alert-success\">Tento článek byl naposledy revidován, aktualizován a rozšířen <strong>27. června 2014</strong>. Snažím se jej držet stále aktuální&hellip;</div>\n\nV následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\n\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\n\nPrvní kroky\n===========\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu:\n\n/--code\napp/\n├─── config/\n├─── model/\n├─── presenters/\n│     └── HomepagePresenter.php\n│\n├─── router/\n├─── templates/\n│     ├── Homepage/\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\n│     │    └── ...\n│     └── @layout.latte\n│\n└─── bootstrap.php\n\\--\n\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\n\n/--code php\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n\\--\n\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\n\n/--code\nhttp://zlml.cz/homepage/kontakt\n\\--\n\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibližně následující:\nBude-li se někdo odkazovat v obecném tvaru `Presenter:view`, pochop `Presenter` jako název presenteru (např. **Homepage**Presenter) a hledej tedy soubor `HomepagePresenter.php`\na `view` bude šablona presenteru, hledej ji tedy ve složce `Presenter/view.latte` a sestav URL která bude přesně v tomto tvaru.\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\n\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\n\n/--code php\n$router[] = new Route(\'<action>\', \'Homepage:default\');\n\\--\n\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\nse mění cílová šablona podle URL:\n\n/--code\nhttp://zlml.cz/kontakt\n\\--\n\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\n\n/--code php\npublic function createRouter() {\n	$router = new RouteList();\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n	return $router;\n}\n\\--\n\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře jako šablony, routa je opět jednoduchá:\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\n\\--\n\nHledá se šablona <code>sitemap.latte</code>. Přečtěte si jak vytvořit tuto šablonu v článku \"RSS a Sitemap jednoduše a rychle\":http://zlml.cz/rss-a-sitemap-jednoduse-a-rychle. Výsledná URL je tak jak má být:\n\n/--code\nhttp://zlml.cz/sitemap.xml\n\\--\n\nTo samé lze udělal pro RSS.\n\nJdeme do hloubky\n================\nTrošku složitější routování přichází vždy když chcete udělat něco speciálního.\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\n\n/--code\nhttp://zlml.cz/2\n\\--\n\n/--code php\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\n\n/--code\nhttp://zlml.cz/using-fulltext-searching-with-innodb\n\\--\n\n/--code php\n$router[] = new Route(\'<id>\', array(\n	\'presenter\' => \'Single\',\n	\'action\' => \'article\',\n	\'id\' => array(\n		Route::FILTER_IN => function ($url) {\n			return $this->posts->getIdByUrl($url);\n		},\n		Route::FILTER_OUT => function ($id) {\n			return $this->posts->getUrlById($id);\n		},\n	),\n));\n\\--\n\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\n\n/--code\nhttp://zlml.cz/search/fio%20api\n\\--\n\n/--code php\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\n\\--\n\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\n\n/--code\nhttp://zlml.cz/rss.xml\n\\--\n\n/--code php\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n\\--\n\nChová se to stejně jako u předchozího příkladu se `sitemap.xml`, v tomto příkladu však routa hledá `BlogPresenter.php` ve složce `FrontModule` a šablonu `rss.latte`, také v tomto modulu. U rout pro modulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa zvládne jazykové mutace pro FrontModul, jinak je to opět ta nejobecnější routa vůbec:\n\n/--code\nhttp://zlml.cz/en/site/kontakt\n\\--\n\n/--code php\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\n	\'module\' => \'Front\',\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n));\n\\--\n\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\n\n/--code\nhttp://zlml.cz/user/en/setting/password\n\\--\n\n/--code php\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\n	\'module\' => \'User\',\n	\'presenter\' => \'Board\',\n	\'action\' => \'default\',\n));\n\\--\n\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\n$router[] = new Route(\'\', \'Front:Product:default\');\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\n	\'module\' => \'Rest\',\n	\'presenter\' => \'Resource\',\n	\'action\' => \'get\',\n), \\App\\RestRouter::RESTFUL);\n\\--\n\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\n\nJak na v posledním příkladu zmíněný CLI router se dočtete v článku \"Nette 2.1-dev CliRouter\":http://zlml.cz/nette-2-1-dev-clirouter.\n\nMáte nějakou zajímavou routu? Podělte se o ni... (-:',	'2013-08-04 12:19:19'),
(52,	'Fluent interface a PCRE',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://zlml.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://zlml.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://zlml.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://zlml.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.',	'2013-08-10 22:31:21'),
(53,	'RSS a Sitemap jednoduše a rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:',	'2013-08-10 23:10:22'),
(55,	'Důležitost titulku podruhé (a naposled)',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://zlml.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://zlml.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://zlml.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.',	'2013-10-21 23:20:36'),
(56,	'LaTeX šablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?',	'2013-10-21 23:42:14'),
(57,	'Změna URL struktury',	'Rád bych tímto upozornil na změny URL adres na tomto webu. A zároveň k technické povaze tohoto webu\nprozradím i bližší informace ze zákulisí.\n\nPřed úpravou URL struktury jsem definoval několik důležitých bodů, kterých jsem se držel:\n1) Musí zůstat maximální (úplná) zpětná kompatibilita\n2) Výsledné URL musí být maximálně jednoduché a cool\n\nPředtím a potom\n===============\nDůležité je, aby stará URL adresa nekončila chybou 404, ale aby přesměrovala na novou URL.\nRSS je nyní na adrese http://zlml.cz/rss. Původně bylo na adrese http://zlml.cz/homepage/rss.\nObě dvě adresy fungují stále, rozdíl je v tom, že homepage/rss nyní přesměrovává pomocí 301 na */rss.\nToho se dalo docílit velice jednoduše:\n\n/--code php\n$router[] = new Route(\'rss\', \'Homepage:rss\'); //nová routa\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\'); //původní\n//záleží na pořadí!\n\\--\n\nAčkoliv je teď druhá routa zbytečná, nechal jsem jí pro případ, že bych měl nějakou URL nezachycenou.\nV tom případě ji zachytí tato obecná.\n\nZpětná kompatibilita\n====================\nStejně tak jako změna adresy RSS, tak si i ostatní adresy musí zachovat stejné vlastnosti viz první bod.\nA vzhledem k tomu, že jsem se rozhodl změnit adresu vyhledávání a tagů, nezbývalo, než další\ndvě routy přidat. Opět záleží na pořadí:\n\n/--code php\n$router[] = new Route(\'s[/<search>]\', \'Search:default\'); //nová\n$router[] = new Route(\'t[/<search>]\', \'Tag:default\'); //nová\n\n//tyto routy (až uznám za vhodné) mohu smazat:\n$router[] = new Route(\'search[/<search>]\', \'Search:default\', Route::ONE_WAY); //původní\n$router[] = new Route(\'tag[/<search>]\', \'Tag:default\', Route::ONE_WAY); //původní\n\\--\n\nOpět platí, že funguje jak stará adresa http://zlml.cz/search/nette s přesměrováním 301, tak i nová \nhttp://zlml.cz/s/nette. Obdobně je tomu u tagů.\n\nČarodějnictví!\n==============\nNejvětší sranda však začíná u druhého požadavku. Už dlouho jsem si pohrával s myšlenkou,\nže chci názvy článků a adresy jednotlivých stránek v menu hned za lomítkem jako v kořenovém\nadresáři. Tedy aby článek měl adresu http://zlml.cz/lovec-matematik a stránka http://zlml.cz/about.\nZde jsem se však vždy dostával do velkého problému. Jak rozlišit a nabídnout z databáze článek a \njak poznat, kdy naopak nabídnout stránku například s referencemi?\n\nNo, tak nejdříve je zapotřebí routa pro články:\n/--code php\n$router[] = new Route(\'<slug>\', \'Single:article\');\n\\--\nKdy v presenteru tahám články z databáze podle slugu:\n/--code php\npublic function renderArticle($slug) {\n	$post = $this->posts->getBySlug($slug)->fetch(); //načetní článku podle slugu\n	if (!$post) { //článek neexistuje (db vrací FALSE)\n		$this->forward($slug); //nabídni statickou šablonu\n	} else { // zobrazení článku\n    	//...\n    }\n}\n\\--\nCož je podle mého dostatečně elegantní řešení. Jednoduše se pokusím o načtení stránky podle slugu\nz databáze a když se to nepodaří, nabídnu nějaký latte soubor, pokud existuje. Pokud neexistuje, \ntak ErrorPresenter již obstará vrácení 404, což je správně, protože není co nabídnout...\n\nJeště je zapotřebí vytvořit jednu routu:\n/--code php\n$router[] = new Route(\'<action>\', \'Single:article\');\n\\--\nBez této routy by to také fungovalo, ale latte ony latte soubory (action) bych našel na dvou URL\nadresách, což nechci. Takže se z původního http://zlml.cz/single/about dostanu na http://zlml.cz/about, \ncož je cool a splňuji tak druhý požadavek.\n\nPoslední routa, která stojí za zmíňku pak zajišťuje stránkování. Pouze rozpoznává čísla podle\nregulárního výrazu a podle toho stránkuje:\n/--code php\n$regex = \'1|2|3\'; //zjednodušeně\n$router[] = new Route(\"[<paginator-page [$regex]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nOstatně to jak mám v době psaní tohoto článku router vytvořený můžete zjistit na \"bitbucketu\":https://bitbucket.org/mrtnzlml/zlml.cz/src/0580e2e9f0e4edb162fe97ad563cfef766bea625/app/router/RouterFactory.php.\n',	'2013-10-27 21:27:00'),
(58,	'Nette 2.2-dev',	'Nedávno byla změněna vývojová verze Nette Frameworku na 2.2-dev (https://github.com/nette/nette/commit/3a426255084163ec1a2f324ea0d3e9b3139adccc).\nTato změna s sebou přinesla explozi změn. Na následujících řádcích bych rád přiblížil\nněkteré zásadní změny, které se odehrály a je zapotřebí je upravit, aby bylo možné z verze 2.1-dev\npřejít právě na verzi 2.2-dev.\n\nNutné úpravy\n============\nPrvě se změnilo umístění konfigurátoru. Tato změna se samozřejmě týká souboru `bootstrap.php`.\nNově je konfigurátor v novém umístění:\n\n/--code php\n//$configurator = new Nette\\Config\\Configurator;\n$configurator = new \\Nette\\Configurator;\n\\--\n\nDále jsem si zvykl používat automatické injektování závislostí pomocí anotace `@inject`.\nPro opětovné použití je nutné zapnout `nette.container.accessors`, což ostatně napoví chybová hláška,\njelikož je tato volba v nové developměnt verzi Nette ve výchozím stavu zakázána. Config.neon:\n\n/--code neon\nnette:\n	container:\n    	accessors: TRUE\n\\--\n\nNyní již bude možné anotace `@inject` používat. Další změna, které mě osobně moc nepotěšila\na nevím co jí předcházelo je zrušení podpory krátkého zápisu bloků:\n\n/--code html\n<!-- Předtím: -->\n{#content}\n	...\n{/#}\n<!-- Nyní: -->\n{block content}\n	...\n{/block}\n\\--\n\nTato změna se mi moc nelíbí, protože například stále funguje `{include #parent}`, což je prostě\nzvláštní... Za zmínku také stojí změna třídy pro práci s databází. Zatímco se ve verzi 2.0.13\nnormálně používá `Nette\\Database\\Connection`, ve verzi 2.1-dev se přešlo na `Nette\\Database\\SelectionFactory`, \nnicméně ve verzi 2.1.0RC2 se již pracuje s `Nette\\Database\\Context` a SelectionFactory již neexistuje. \nToto  platí i pro verzi 2.2-dev. Tato změna mi bude zřejmě dlouho trvat, než ji vstřebám.\nMyslím si, že obyčejné `Nette\\Database` by bylo v modelu daleko více vypovídající než nějaký Context, \nale budiž.\n\nTolik k podle mého zásadním změnám, které zabrání například spuštění projektu z quickstartu. Nyní\nbych rád poukázal na několik málo změn z celé té exploze, které mě zaujaly.\n\nDalší změny\n===========\nByla odstraněna celá řada zastaralých věcí. Nemá smysl je rozebírat. Je jich hodně a zastaralé jsou\nuž od 2.1. Každopádně například makro `n:input` se stalo zastaralé a k dispozici je nové makro\n`{inputError}`, které ošéfuje vykreslení chybové hlášky u příslušného políčka. Jééj! :-)\n\nLehce odlišně se také přistupuje k checkboxům a vůbec, formuláře jsou zase o něco lepší, což\npředpokládám souvisí s:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Chtěl jsem v rychlosti udělat příklad, jak v <a href=\"https://twitter.com/search?q=%23netteFw&amp;src=hash\">#netteFw</a> renderovat formuláře s Twitter Bootstrapem.&#10;&#10;Zabitej den a překopaný Nette…</p>&mdash; geekovo (@geekovo) <a href=\"https://twitter.com/geekovo/statuses/409064701369516032\">December 6, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nKonečně!\n========\nSvětlo světa spatřil nový \"quickstart\":http://doc.nette.org/cs/2.1/quickstart v češtině pro dnes již téměř nekatuální verzi 2.0.13.\nVěřím tomu, že se jedná o daleko přínosnější věc, než psaní pokročilých návodů v angličtině\n(navazujících na quickstart) a doufám, že tento počin pomůže pár lidí popostrčit dál...\n\nJaká změna vás zaujala nejvíce?',	'2013-12-15 14:10:23'),
(59,	'Přednáška z Nette na ZČU',	'Dnes jsem měl tu čest přednášet na ZČU studentům předmětu KIV/WEB - Webové aplikace.\nPřednášku a i celé povídání jsem se snažil chopit velmi realisticky, prakticky a pro studenty, \nkteří s tvorbou webových aplikací teprve začínají. Doufám, ze bylo mé povídání\ninspirativní, srozumitelné a pochopitelné. Ostatně sami si prezentaci můžete přečíst:\n<br><br>\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29326870\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe>\n\n<br>\nVěřím, že Nette bude používat zase o něco více začátečníků a že še jim podaří psát kvalitní\nwebové aplikace. Rád bych ještě jednou popřál všem studentům úspěšné složení zkoušky z předmětu KIV/WEB\na snad se ještě někdy potkáme... (-:',	'2013-12-18 17:54:22'),
(60,	'Veřejná distribuce klíčů',	'<blockquote>\n  Inspirací a zdrojem informací pro tento článek byla kniha <strong>Simona Singha</strong> - Kniha kódu a šifer.\n  <small>Utajování od starého Egypta po kvantovou kryptografii</small>\n</blockquote>\n\nTímto článkem bych rád navázal na článek o asymetrickém šifrování http://zlml.cz/asymetricka-sifra-s-verejnym-klicem a vyřešil tak několik restů. Zejména potom onu osudnou veřejnou distribuci klíčů o které jsem sice již dříve psal, ale článek již není k dispozici. Proto tento text budu brát jako revizi původního. Také bych na začátek chtěl říct, že tento problém je již dávno vyřešen a proto bude následující text ohlédnutím za vznikem této myšlenky s tím, že je však použití stále aktuální a reálně se používá (např.: http://nodejs.org/api/crypto.html#crypto_class_diffiehellman).\n\nDistribuce klíčů? Vždyť je to tak snadné...\n===========================================\nPokud si chtějí dvě osoby vyměnit zašifrované zprávy, je jasné, že musejí znát i klíče, které jim umožní tyto zprávy dešifrovat. Jenže jak si vyměnit tyto klíče? Mohou se tyto osoby někdy potkat a klíč si povědět. To však není vždy možné. Navíc klíče je dobé frekventovaně měnit, takže je v dnešní době toto řešení naprosto nesmyslné.\n\n<blockquote>\n  Dříve, než dva lidé mohou sdílet tajemství, musí již jedno tajemství sdílet.\n  <small>Dříve než dva lidé mohou sdílet šifrovanou zprávu, musí již sdílet klíč.</small>\n</blockquote>\n\nAčkoliv je osobní výměna bezpečná, jedná se tedy o metodu nereálnou a je třeba navrhnout jiné postupy. Co třeba najmou kurýra? Je to sice méně bezpečné, ale eliminují se některé předchozí problémy. Bohužel kurýr je až příliš nebezpečný způsob, protože pak lze klíč rovnou nějakým kanálem poslat a dostáváme se opět na začátek. Je tedy vůbec možné si vyměnit klíč bez nutnosti potkat se? Je tedy vůbec nutné si klíč vyměnit?\n\nMožná to jde i jinak\n====================\nExistuje skvělá hádanka, která na první pohled daný problém řeší. Představte si poštovní službu, která však všechny zásilky otevírá a čte si je. Nicméně Alice potřebuje poslat tajný balík Bobovi. Lze využít tuto poštu tak, aniž by balík otevřela?\n\nPřistupím rovnou k řešení, které je opravdu jednoduché. Alice pošle balík (schránku), který opatří vlastním zámkem a klíč od tohoto zámku si ponechá. V tom případě není pošta schopna balík otevřít. Bohužel ani Bob balík neumí otevřít, protože nemá k dispozici správný klíč. Proto Bob vezme vlastní zámek a schránku zamkne ještě vlastním zámkem. Klíč si opět ponechá. To může vyznít zvláštně, ale hned to začne být jasné. Bob balík opět odešle, Alice sundá vlastní zámek (protože od něj má klíč) a balík pošle opět Bobovi. Nyní je na balíku pouze Bobovo zámek a ten ho může jednoduše odemknout. Zdá se tedy, že lze cokoliv poslat zabezpečeně a výměna klíčů není potřeba! Toto je nesmírně důležitá myšlenka.\n\nMá to však háček. Ačkoliv se zdá být předchozí problém naprosto zřejmý a funkční, po převedení do světa kódů a šifer, celá myšlenka padá. Důvod je jednoduchý. Bylo velmi snadné na schránku umístit zámek **A**, poté zámek **B**, poté odstranit zámek **A** a nakonec odstranit zámek **B**. Takže posloupnost  šifrování byla +A => +B => -A => -B. Použijete-li však tento postup pomocí doposud známých šifer, zjistíte, že záleží na pořadí šifrování, resp. dešifrování. Zkrátka nelze toto pořadí zaměnit, jinak je výsledek zamíchaný a nepoužitelný.\n\nTak to je problém...\n====================\nAčkoliv byla myšlenka posílání balíku téměř ideální, ve světě šifer již nefunguje. Co teď? Na scénu přichází matematika. Konkrétně jednosměrné funkce a s nimi modulární aritmetika. Nemyslím si, že má smysl řešit co je to jednosměrná funkce, ale zkráceně jednosměrná funkce je taková funkce, která se nedá (nebo velmi těžce) zvrátit. Jeko velmi dobrý příklad takové funkce je například smíchání dvou barev (nelze získat zpět původní barvy). Obdobně pro matematické funkce. Zkrátky vždy je o to nalézt takovou funkci, kterou je velmi jednoduché použít a spočítat, ale již velmi složité invertovat výsledek. Právě pro tyto úlohy se perfektně hodí modulární aritmetika. Tam kde se běžná aritmetika chová předvídatelně a na základě pokusů lze konvergovat k výsledku, v modulární takováto chování neexistují.\n\nŘešení\n======\nNásledující algoritmus je zhruba použit v šifrách DES (pro velká čísla). Budu však používat malá, aby bylo vše lépe pochopitelné. Alice a Bob se <strong>veřejně</strong> dohodnou na funkci *Y<sup>x</sup>(mod P)*, kdy si číla např. Y=5 a P=8 vymění (a útočník je může odposlechnout).\n\nTeď tedy zná příjemnce, odesílatel i útočník danou funkci. Odesílatel a příjemnce si nyní zvolí jiné číslo <strong>které uchovají v tajnosti</strong>, toto číslo vloží do matematické funkce *Y<sup>x</sup>(mod P)* a výsledek odešlou. Například Bob zvolil x=4, tedy *5<sup>4</sup>(mod 8)=1*. Alice volí x=3, tedy *5<sup>3</sup>(mod 8)=5*. Tyto výsledky si vymění.\n\nZ pohledu útočníka lze říci, že zná funkci a zná také výsledky, konkrétně 1 a 5. S touto znalostí by šlo možná privátní číslo **x** dopočítat. Jenže vyzkoušejte si to. Pro malá čísla možná, ale pro velká je to téměř nemožné. A že se používají velká čísla...\n\nNyní vezme Alice výsledek od Boba a spočte *vysledek<sup>x</sup>(mod P)*, tedy *1<sup>3</sup>(mod 8)=1*. Nezapomeňte, že číslo **x** je stále privátní a zná ho jen Alice. Stejně teď postupuje i Bob, ale s vlastním privátním číslem a výsledkem od Alice: *5<sup>4</sup>(mod 8)=1*. A zde je vidět k čemu došlo. Výsledek obou výpočtů vyšel stejně a k přenosu priváního čísla **x** nikdy nedošlo. Vyzkoušejte si to na papír a nejlépe pro větší čísla. Pro útočníka nastává velký problém, protože nezná privátní číslo a je pro něj tedy nemožné provést tyto výpočty, nicméně Alice i Bob mají k dispozici jeden výsledek, tedy jeden klíč, který mohou používat.\n\nZávěr\n=====\nJeště zopakuji k čemu tedy došlo. Bylo zapotřebí dohodnout se mezi odesílatelem a příjemcem na společném klíči, podle kterého bude posílaná zpráva šifrována. To se pomocí vhodných matematických metod povedlo a navíc (což je to njdůležitější) není téměř možné tento přenos odposlechnout, jelikož se jedná o jednosměrné operace.\n\nAnalogicky lze použít opět míchání barev. Alice a Bob mají nádobu s litrem červené barvy. Stejnou nádobu má i útočník. Alice i Bob nyní nalijí vlastní privátní barvu do nádoby a tyto nádoby si vymění. Útočník je může vidět, ale nedokáže z nich odhadnout jaká je privátní barva. Nakonec Alice i Bob nalijí zbytek své tajné barvy do nádoby (již je mají vyměněné), čímž vznikne Alici i Bobovi stejná barva. Ani Alice, ani Bob, ani útočník neví co bylo přidáno za barvy od toho druhého, ale se znalostí vlastního privátního klíče se dostanou ke stejnému výsledku. útočník tyto klíče nezná a je nahraný.\n\nTak a zde by měl začínat článek http://zlml.cz/asymetricka-sifra-s-verejnym-klicem.\n\nTento a daleko více inspirativních nápadů a příběhů naleznete v knize https://www.kosmas.cz/knihy/146743/kniha-kodu-a-sifer/.',	'2013-12-22 12:08:24'),
(62,	'Představení projektu Vacuum - STATIC',	'Vzhledem k tomu, že vzrostl zájem o Vacuum projekty, rozhodl jsem se zde uveřejnit postup jak pracovat s projektem **Vacuum - STATIC** (https://bitbucket.org/mrtnzlml/vacuum-static). Věřím, že je daleko lepší projekt ukázat a lehce popsat, než popsat a lehce ukázat, jak si Nette komunita občas myslí...\n\nCo to vlastně je\n================\nVacuum - STATIC je projekt, který vznikl z úplně základního Nette skeletonu, který jsem používal pro jednoduché statické firemní prezentace jako je například http://www.businessservice.cz/. Postupem času jsem dodával vylepšení a když už tento projekt dosáhl svého maxima, rozhodl jsem se do něj napsat jednoduchou administraci. V současné době tedy Vacuum - STATIC vlastně vůbec není statická prezentace. Obsahuje vestavenou SQLite databázi, díky které není potřeba nějaké MySQL databáze. Web prostě funguje zdánlivě bez databáze. Toto je velmi zásadní. Vacuum - STATIC pravděpodobně nikdy nebude mít externí databázi, takže se bude stále tvářit jako jednoduchá webová prezentace, která má však navíc jednoduchou administraci.\n\nStažení, instalace, spuštění\n============================\nCelý projekt se dá stáhnout různě, asi nejjednodušší je využít funkcionalit GITu:\n\n/--code\n>> git clone https://mrtnzlml@bitbucket.org/mrtnzlml/vacuum-static.git folder\nCloning into \'folder\'...\nremote: Counting objects: 433, done.\nremote: Compressing objects: 100% (401/401), done.\nremote: Total 433 (delta 201), reused 0 (delta 0)\nReceiving objects:  92% (399/433), 636.00 KiB | 192 KiB/s\nReceiving objects: 100% (433/433), 664.47 KiB | 192 KiB/s, done.\nResolving deltas: 100% (201/201), done.\n\\--\n\nTím vytvoříte složku `folder`, která bude obsahovat aktuální verzi projektu Vacuum - STATIC. Pokud v tuto chvíli projekt sputíte, vrátí chybu, že nemůže najít soubor `autoload.php`. Je to proto, že projekt ještě neobsahuje žádné knihovny (například Nette). Ty totiž nemá smysl udržovat v repozitáři. Veškeré potřebné knihovny lze doinstalovat jednoduše pomocí Composeru:\n\n/--code\n>> composer update\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\n  - Installing nette/tester (dev-master a60c379)\n    Cloning a60c379836617422c8df9d9846fea4efa2ca9d1d\n\n  - Installing nette/nette (dev-master a748c3d)\n    Cloning a748c3d344767ed1f0cc9ee40019f6a6f81afa97\n\n  - Installing janmarek/webloader (dev-master 3d44d30)\n    Cloning 3d44d306d59591dc94f6fdcb98f55c0990d98326\n\n  - Installing texy/texy (dev-release-2.x 79d0e15)\n    Cloning 79d0e1517363ab32edf2db8ec515e3dc84f50f0a\n\nnette/nette suggests installing ext-fileinfo (*)\njanmarek/webloader suggests installing leafo/lessphp (Lessphp is a composer for LESS written in PHP.)\nWriting lock file\nGenerating autoload files\n\\--\n\nV tuto chvíli je projekt připraven k použití. V některých systémech však bude potřeba ještě nastavit práva k zápisu složkám `temp` a `log`. Dokonce není potřeba ani nějakého XAMPP serveru. Stačí v té samé složce využít integrovaného PHP serveru v příkazové řádce:\n\n/--code\nphp -S localhost:8888 -t www\n\\--\n\nFunkční Vacuum - STATIC pak naleznete na adrese http://localhost:8888/. Trapně jednoduché a překvapivě funkční. (-: Vzhledem k tomu, že již vidíte funkční stránku, můžete se přihlásit do administrace (link v patičce). Přihlašovací údaje jsou *demo*/*demo*.\n\nUpdate projektu\n===============\nNa tomto projektu stále pracuji a čas od času v něm něco doplním nebo upravím. Vzhledem k tomu, že doporučuji použít ke stažení GIT, je update projektu velmi jednoduchý. Stejně jako jsem nedávno zapomněl přidat nahrát dva soubory:\n\n/--code\n>> git pull\nUpdating ead4a56..2439d5f\nFast-forward\n www/js/codemirror.js | 5516 ++++++++++++++++++++++++++++++++++++++++++++++++++\n www/js/xml.js        |  338 ++++\n 2 files changed, 5854 insertions(+)\n create mode 100644 www/js/codemirror.js\n create mode 100644 www/js/xml.js\n\\--\n\nTo je asi tak vše co se k tomu dá teď napsat. Nic na tom není, jen je třeba vědět jak na to. Přeji hodně úspěchů při používání tohoto projektu ať už je to ke studijním účelům, nebo k reálné webové prezentaci. Zpětnou vazbu samozřejmě rád uvítám.',	'2014-01-28 18:10:34'),
(63,	'Vlna na webu',	'Vlna je program \"Petra Olšáka .{target:_blank}\":http://ftp.linux.cz/pub/tex/local/cstug/olsak/vlna/, který slouží k umístění nezalomitelné místo na místo v textu, kde by nemělo dojít k samovolnému zalomení řádku. Tento program slouží k dodatečné úpravě textů napsaných v LaTeXu. V tomto prostředí se nezalomitelná mezera nahrazuje znakem vlnovkou - tildou (~). U webového výstupu se používá zástupná entita <code>&amp;nbsp;</code>.\n\nKde by měla být nedělitelná mezera\n==================================\nV základu program Vlna umístí tildu za znaky <code>KkSsVvZzOoUuAI</code>. Více toho pokud vím nedělá. Podle Ústavu pro jazyk český AV ČR by však toto pravidlo mělo platit mimo jiné pro znaky <code>KkSsVvZzAaIiOoUu</code>. Neuvažuji další pravidla, která určují další nevhodné výrazy na konci řádku. Mezi tyto pravidla patří například mezery uvnitř číslic, mezery mezi číslicí a značkou, atd. Některá pravidla jsou totiž natolik specifická, že by je bylo náročné (nebo nepraktické) podchytit programově.\n\nImplementace\n============\nO samotné nahrazování se stará následující regulární výraz:\n/--code php\npreg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n\\--\nTento výraz říká, že nestojí-li bezprostředně před sadou znaků <code>KkSsVvZzAaIiOoUu</code> jiný alfanumerický znak a stojí-li za touto sadou jakýkoliv alfanumerický znak oddělený bílým znakem bude tento znak nahrazen entitou <code>&amp;nbsp;</code>. V konkrétní implementaci lze zaregistrovat Vlnu jako helper pro Latte šablony například takto (obsahuje i registraci Texy helperu):\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	$template->registerHelper(\'vlna\', function ($string) {\n		$string = preg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n		return $string;\n	});\n	return $template;\n}\n\\--\n\nVlna se pak v Latte šablonách používá jako jakýkoliv jiný helper:\n\n/--code\n{$post->title|vlna}\n\\--\n\nJeště by možná stálo za to vrátit se k tomu, jaké problémy by způsobovala implementace i dalších pravidel a jak by to bylo náročné. Ještě nad tím budu přemýšlet, každopádně již teď mě napadají určité problémy. Například u čísel. Jak přesně identifikovat, kdy se má použít nedělitelná mezera a kdy ne? Možná je toto právě ten důvod, proč takové rozšířené chování program Vlna nepodporuje...',	'2014-02-01 22:09:38'),
(64,	'Použití Texy s FSHL',	'Někdy (hodně dávno) jsem kdesi našel poměrně hezký a jednoduchý postup jak implementovat \"Texy .{target:_blank}\":http://texy.info/ s použitím \"FSHL .{target:_blank}\":http://fshl.kukulich.cz/ na webu. Rád bych se zde podělil o postup, který používám již na řadě projektů, které potřebují zvýrazňování syntaxe.\n\nPoužití samotného Texy\n======================\nBěžně by se Texy zaregistrovalo do šablony jako helper:\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	return $template;\n}\n\\--\n\nTento helper lze i nadále používat. Hodě se například pokud je potřeba Texy prvky naopak escapovat:\n\n/--code\n{$post->body|texy|striptags}\n\\--\n\nPoužití Texy s FSHL\n===================\nSamotné texy je sice geniální nástroj. Pro samotné zpracování se zvýrazněním se však hodí funkcionalitu Texy rozšířit, jelikož je potřeba zpracovat vstupující text a ty správná místa prohnat také tím správným lexxerem ve FSHL. K tomu dobře poslouží následující třída, která dědí právě od Texy:\n\n/--code php\n<?php\n\nclass fshlTexy extends Texy {\n\n	public function blockHandler($invocation, $blocktype, $content, $lang, $modifier) {\n		if ($blocktype !== \'block/code\') {\n			return $invocation->proceed(); //vstup se nebude zpracovavat\n		}\n\n		$highlighter = new \\FSHL\\Highlighter(\n			new \\FSHL\\Output\\Html(),\n			\\FSHL\\Highlighter::OPTION_TAB_INDENT | \\FSHL\\Highlighter::OPTION_LINE_COUNTER\n		);\n\n		$texy = $invocation->getTexy();\n		$content = Texy::outdent($content);\n\n		//Set correct lexer:\n		switch(strtoupper($lang)) {\n			case \'CPP\': $lexer = new \\FSHL\\Lexer\\Cpp(); break;\n			case \'CSS\': $lexer = new \\FSHL\\Lexer\\Css(); break;\n			case \'HTML\': $lexer = new \\FSHL\\Lexer\\Html(); break;\n			case \'JAVA\': $lexer = new \\FSHL\\Lexer\\Java(); break;\n			case \'JAVASCRIPT\': $lexer = new \\FSHL\\Lexer\\Javascript(); break;\n			case \'NEON\': $lexer = new \\FSHL\\Lexer\\Neon(); break;\n			case \'PHP\': $lexer = new \\FSHL\\Lexer\\Php(); break;\n			case \'PYTHON\': $lexer = new \\FSHL\\Lexer\\Python(); break;\n			case \'SQL\': $lexer = new \\FSHL\\Lexer\\Sql(); break;\n			case \'TEX\': $lexer = new \\FSHL\\Lexer\\Tex(); break; //WARNING: vlastní výroba!\n			case \'TEXY\': $lexer = new \\FSHL\\Lexer\\Texy(); break;\n			default: $lexer = new \\FSHL\\Lexer\\Minimal();\n		}\n\n		$content = $highlighter->highlight($content, $lexer);\n		$content = $texy->protect($content, Texy::CONTENT_BLOCK);\n\n		$elPre = TexyHtml::el(\'pre\');\n		if ($modifier) {\n			$modifier->decorate($texy, $elPre);\n		}\n		$elPre->attrs[\'class\'] = strtolower($lang);\n\n		$elCode = $elPre->create(\'code\', $content);\n\n		return $elPre;\n	}\n\n}\n\\--\n\nTato třída při správném použití zajistí, že se použije ten správný lexer a ještě na úrovni PHP zajistí změnu výstupu. Konkrétně obalí určitá klíčová slova (v závislosti na kontextu) tagem <code>&lt;span&gt;</code> se zvláštní třídou. Toho se následně lze chytit v CSS a HTML výstup obarvit. Použití této třídy například v metodě <code>render*()</code>:\n\n/--code php\n$texy = new \\fshlTexy();\n//registrace handleru z nové třídy:\n$texy->addHandler(\'block\', array($texy, \'blockHandler\'));\n//dále stejně jako klasické použití Texy:\n$texy->tabWidth = 4;\n$texy->headingModule->top = 3; //start at H3\n$this->template->body = $texy->process($post->body);\n\\--\n\nVýstup lze pak v Latte lehce podchytit a zobrazit:\n\n/--code\n{$body|noescape}\n\\--\n\nBarvy, barvy, barvičky\n======================\nProgramově je sice tělo dokumentu vypsáno s tagy <code>&lt;span&gt;</code> s příslušnou třídou. To se však nijak viditelně neprojeví. Celou krásu udělá teprve CSS. Lze použít výchozí hodoty FSHL a vložit je do vlastního souboru stylů:\n\n/--code css\n/* Common */\n.xlang { color: #ff0000; font-weight: bold; }\n.line { color: #888888; background-color: #ffffff; }\n\n/* CSS */\n.css-at-rule { color: #004a80; font-weight: bold; }\n.css-tag { color: #004a80; }\n.css-id { color: #7da7d9; font-weight: bold; }\n.css-class { color: #004a80; }\n.css-pseudo { color: #004a80; }\n.css-property { color: #003663; font-weight: bold; }\n.css-value { color: #448ccb; }\n.css-func { color: #448ccb; font-weight: bold; }\n.css-color { color: #0076a3; }\n.css-comment { background-color: #e5f8ff; color: #999999; }\n\n/* CPP */\n.cpp-keywords1 {color: #0000ff; font-weight: bold;}\n.cpp-num {color: #ff0000;}\n.cpp-quote {color: #a52a2a; font-weight: bold;}\n.cpp-comment {color: #00ff00;}\n.cpp-preproc {color: #c0c0c0;}\n\n/* HTML */\n.html-tag {color: #598527; font-weight: bold;}\n.html-tagin {color: #89a315}\n.html-quote {color: #598527; font-weight: bold;}\n.html-comment {color: #999999; background-color: #f1fae4;}\n.html-entity {color: #89a315;}\n\n/* Java */\n.java-keywords1 {color: #0000ff; font-weight: bold;}\n.java-num {color: #ff0000;}\n.java-quote {color: #a52a2a; font-weight: bold;}\n.java-comment {color: #009900;}\n.java-preproc {color: #c0c0c0;}\n\n/* Javascript */\n.js-out {color: #898993;}\n.js-keywords1 {color: #575757; font-weight: bold;}\n.js-num {color: #575757;}\n.js-quote {color: #575757; font-weight: bold;}\n.js-comment {color: #898993; background-color: #f4f4f4;}\n\n/* Neon */\n.neon-section {color: #598527;}\n.neon-sep {color: #ff0000;}\n.neon-key {color: #0000ff;}\n.neon-comment {color: #999999;}\n.neon-value {color: #000000;}\n.neon-quote {color: #884433;}\n.neon-num {color: #448ccb;}\n.neon-var {color: #ffaa00;}\n.neon-ref {color: #884433;}\n\n/* PHP */\n.php-keyword1 {color: #dd2244; font-weight: bold;}\n.php-keyword2 {color: #dd2244;}\n.php-var {color: #ffaa00; font-weight: bold;}\n.php-num {color: #ff0000;}\n.php-quote {color: #884433; font-weight: bold;}\n.php-comment {color: #999999; background-color: #ffffee;}\n\n/* Python */\n.py-keyword1 {color: #0033cc; font-weight: bold;}\n.py-keyword2 {color: #ce3333; font-weight: bold;}\n.py-keyword3 {color: #660066; font-weight: bold;}\n.py-num {color: #993300;}\n.py-docstring {color: #e86a18;}\n.py-quote {color: #878787; font-weight: bold;}\n.py-comment {color: #009900; font-style: italic;}\n\n/* SQL */\n.sql-keyword1 {color: #dd0000; font-weight: bold;}\n.sql-keyword2 {color: #dd2222;}\n.sql-keyword3 {color: #0000ff; font-weight: bold;}\n.sql-value {color: #5674b9;}\n.sql-comment {color: #ffaa00;}\n.sql-num {color: #ff0000;}\n.sql-option {color: #004a80; font-weight: bold;}\n\n/* Tex */\n.tex-func {color: #ffaa00; font-weight: bold;}\n.tex-comment {color: #999999; background-color: #ffffee;}\n.tex-attr1 {color: #dd2222;}\n.tex-attr2 {color: #0000ff; font-weight: bold;}\n.tex-math {color: #00AA00; font-weight: bold;}\n\n/* Texy */\n.texy-hlead {color: #4444bb; font-weight: bold;}\n.texy-hbody {background-color: #eeeeff; color: #4444bb;}\n.texy-hr {color: #bb4444;}\n.texy-code {color: #666666;}\n.texy-html {color: #66aa66;}\n.texy-text {color: #6666aa;}\n.texy-err {background-color: #ff0000; color: #ffffff;}\n\\--\n\nCelá krása tohoto řešení spočívá v tom, že nepoužívám žádné javascriptové knihovny, ale vše se provede pěkně na úrovni PHP a bude to tedy fungovat vždy, stejně tak jako Texy... (-:',	'2014-02-02 10:47:06'),
(65,	'Udržujete dokumentaci stále aktuální?',	'Již dlouho si v hlavě pohrávám s jednou myšlenkou, kterou stále nemohu dovést do zdárného konce. Již na samém začátku jsem již však věděl, že se zajisté nezalíbí velké skupině programátorů. Přesto si myslím, že má něco do sebe. Jen jsem ji ještě nedomyslel tak, aby jsem s ním byl spokojen. Třeba bude mít někdo nějaký geniální nápad.\n\nNa začátku byl problém\n======================\nA každý problém by se měl řešit. Mluvím teď o jednom konkrétním. *Jak udržet dokumentaci projektu aktuální?* To je problém, který některé projekty dokáží bez větších problémů. Obdivuji člověka, který napíše kus kódu a k němu napíše přehlednou a užitečnou dokumentaci. Ještě více však obdivuji toho, kdo aktualizuje kus kódu a opět se pustí na přepisování dokumentace. V praxi je toto však bolístka, která trápí většinu projektů, které používá menší než obrovské množství...\n\nMyslím si, že tento postup je částečně zcestný. Není problém napsat dokumentaci, ale problém je se pak vracet k napsaným textům a číst je znova a znova a stále je upravovat. Má tento problém vůbec nějaké řešení? Možná ano. Pokud zůstanu u myšlenky, že jednou napsat dokumentace a dost, může se leckomu zdát, že při tomto postupu není možné dokumentaci aktualizovat. Definjme tedy alespoň rámcově tyto pojmy. Pod dokumentací si představuji webovou stránku s případnou obsahovou strukturou, která obsahuje jak veškeré naučné texty, tak ukázky kódů. Praktické ukázky. Tak jak to ve skutečnosti funguje.\n\nBěžné zadání dokumentace, že? Nikde jsem však nenapsal, že tato dokumentace musí obsahovat přímo napsané povídání. Musí tento text ve výsledku obsahovat, ale nemusí být součástí!\n\nCo prosím?\n==========\nMyslím to přesně tak jak jsem napsal. Dokumentace musí na výstupu obsahovat veškeré texty a prostě všechno, ale nemusí je při tvorbě obsahovat. To zní možná trošku divně. Není ta věta v rozporu sama se sebou? Ne nutně. Dokumentaci bych si opravdu představoval jako soubor pravidel obsahující nadpis, několik programových direktiv a to by bylo v podstatě všechno. Mohlo by to vypadat například takto pro nějaký tutoriál:\n\n/--code\nToto je nadpis stránky v dokumentaci\n\nindex.php\nbootstrap.php\nHomepagePresenter.php:renderDefault\n\\--\n\nSchválně jsem zvolil všem tolik známý sandbox z Nette Frameworku. V souboru bych tedy jen definoval jen (omáčku okolo), nadpis, soubory odkud se má dokumentace generovat, popř. nějaký výběr. Zde je nutné říct, že by byl projekt po programové stránce poněkud zvláštní a nejsem si jist, jestli je to úplně OK. usel by totiž obsahovat onu dokumentaci viz např. *index.php*:\n\n/--code php\n<?php\n\n/**\n ** Zde je umístněna dokumentace.\n ** Obsahuje kompletní poučný text, který se pak vyfiltruje do dokumentace včetně\n ** řádků, popř. metod ke kterám se vztahuje. Pro lepší použití by bylo potřeba\n ** definovat několik zřejmě anotací jako např:\n **\n ** @doc-lines 12-14\n ** @doc-highlight 14\n **/\n$container = require __DIR__ . \'/../app/bootstrap.php\'; ///>label\n\n$container->application->run();\n\\--\n\nTakovýto soubor je pak jednoduché vzít, rozebrat, naservírovat text, aplikovat funkci entit a vykreslit i kód ke kterému se tento komentář vztahuje. Možná by šlo vytvořit i nějaká návěští pro odkazování se do kódu, protože číslo řádky není úplně nejvhodnější (<code>///>label</code>).\n\nPro et Contra\n=============\nJednoznačně by tento postup vedl k tomu, aby programátor kromě psaní kódu udržoval i komentář, který by byl běžně velmi blízko. Jednalo by se tak vlastně o jednu práci. Netřeba otevírat celou dokumentaci, stačí změnit pouze malou část, která se s pushnutím zobrazí i v dokumentaci. Na druhou stranu, nedovedu si tento postup představit v kombinaci s klasickým PHPDOC. Nenapadá mě jiné řešení, než udržovat klasický projekt a vedle projekt, který by sloužil pouze pro dokumentaci. Například onen sandbox z NetteFW. Při takovém postupu mi to však dává docela dobrý smysl. Dokumentace by byla doslova stejně aktuální jako zdrojové kódy a to včetně ukázek! Co je u takových projektů důležitější?\n\nMimochodem. PHP k tomuto má velmi blízko. Minimálně podle jejich dokumentačních \"slohokomentářů\". S tímto problémem také lehce souvisí verzování projektů o kterém bych se chtěl rozepsat jindy.\n\nTeď však zpět k myšlence. Jak moc je to hloupý nápad? Co je jeho překážkou? Proč by ho nešlo prakticky použít?',	'2014-02-03 21:50:55'),
(66,	'Kde se berou spamy?',	'<div class=\"alert alert-info\">Tento článek navazuje na článek \"Stáhněte si zdarma 897457 emailových adres\":http://zlml.cz/stahnete-si-zdarma-897457-emailovych-adres z ledna tohoto roku. Přečtěte si jej prosím, ať víte o co jde.</div>\n\nRád bych tímto všechny čtenáře poprosil o pomoc. Ačkoliv na internetu vystupuji veřejně a nemám s tím problém, jsem velmi háklivý na to, když někdo neoprávněně zneužívá mé osobní informace. Někteří přijmou moji žádost a problém odstraní - viz nedávno zrušená kopie tohoto blogu. Někteří však dělají všechno proto, abych pokračoval v rituálním podpalování válečné sekery a proto jsem neskončil tam kde jsem v minulém článku přestal psát.\n\nTrnitá cesta plná překážek\n==========================\nJe již známá věc, že jistý web má nemalou zásluhu na šíření reklamních emailů křížem krážem. Vzhledem k tomu, že takové email dorazil i ke mě a vzhledem k tomu, že upoutal moji pozornost, začal jsem zbrojit. Při prvních pokusech jsem oťukával jejich systém abych zjistil o co jde. Zde jsem mimo jiné udělal mylný myšlenkový pochod a vše jsem svedl na někoho kdo s tím nemá nic společného. Každopádně po několika minutách jsem měl celkem jasno a udělal jsem velkou chybu. Popsal jsem bezpečnostní chybu reklamního systému na G+, na což někdo velmi rychle zareagoval a já jsem dostal na tento reklamní server ban. Doufám, že to byla jen náhoda...\n\nToto řešení mi přišlo poněkud směšné, a tak jsem do tohoto systému přes IP anonymizér šťoural stále více. V tuto chvíli jsem to prakticky zabalil, protože chyba byla tak nějak opravena. Systém již při odhlašování nezobrazoval emailovou adresu, takže již nešlo použít něco jako:\n\n/--code php\npreg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n\\--\n\nNa necelý měsíc jsem to pustil z hlavy až včera jsem si na tento web opět vzpomněl. Také jsem byl již na jiné IP adrese což se mi stává celkem často, takže jsem opět vyzkoušel to co před měsícem a světe div se, bezpečností chyba opět funguje. To mě rozproudilo ještě víc, takže jsem opět usedl k editoru a začal jsem psát program, abych si ověřil, že jsem nekecal:\n\n/--code php\n<?php\ntry {\n    $db = new PDO(\'mysql:dbname=emails;host=127.0.0.1\', \'root\', \'\');\n    $stmt = $db->prepare(\"INSERT INTO emails (url_id, email) VALUES (:url_id, :email)\n							ON DUPLICATE KEY UPDATE url_id= :url_id, email= :email\");\n	$stmt->bindParam(\':url_id\', $url_id);\n	$stmt->bindParam(\':email\', $email);\n\n	//1300486 - 2197943\n	for ($i=2197943; $i > 1300486; $i--) {\n		preg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n		if (preg_match(\"#@#\", $match[1])) {\n			$url_id = $i;\n		    $email = $match[1];\n		    echo $i . \': \' . $email . \"\\n\";\n			$stmt->execute();\n		}\n	}\n\n} catch (PDOException $e) {\n    echo \'Connection failed: \' . $e->getMessage();\n}\n\\--\n\nNejsem žádný extra programátor, ale na takovou věc ani být nemusím. Je asi zřejmé, že by tento program trval poměrně dlouhou dobu. Nemá však smysl řešit nějaké paralelní zpracování, když se o to server při vhodně zvoleném programu postará sám. Napsal jsem tedy celkem tři velmi podobné programy. Jeden bral URL adresy od nízkého čísla, druhý od vysokého a třetí na obě strany od středu číselného intervalu. Právě je 17:00, dávám si něco k jídlu a vyrážím do města na hokej...\n\nJak to bylo dál?\n================\nPo tom co hokej nedopadl moc dobře, strávil jsem nějaký čas u piva a vrátil jsem se domů. Bylo pozdě a program pořád běžel. Šel jsem spát a ráno do školy. Program stále běžel. V tuto chvíli již 16 hodin. Odhadem až někdy po 20ti hodinách dolování emailových adres z tohoto serveru jsem opět dostal IP ban. V tu chvíli jsem měl však získáno více než čtvrt milionu unikátních emailových adres. Ono to funguje! **Zde bych měl říct, že jsem tyto emailové adresy nedoloval kvůli nějakému zneužití, maximálně z nich udělám nějakou statistiku**... (-: Chtěl jsem také napsat na email který mají vystavený na webu, to bohužel nefungovalo, protože tento email byl pravděpodobně zrušen.\n\nV tuto chvíli adresy stále zpracovávám, protože celý systém psal někdo moc \"šikovný\" a tak občas systém vrátil místo emailu *Invalid key!* a jindy zase mix náhodných speciálních znaků s čímž jsem nepočítal. Také já jsem byl šikovný, takže jsem sice v programu počítal s unique klíčem, ale v DB jsem ho neudělal a v reklamním systému je jich cca 10% duplicitních.\n\nŽádám tedy o pomoc. Víte komu patří emailová adresa `b2bdm@email.cz`? Komu patří `m-letter.eu`? Kdo zneužívá tak obrovské množství emailových adres? A kde je vůbec bere? Skutečně mě to zajímá, protože takto je to těžko představitelné, ale několik set tisíc adres je skutečně obrovské množství a já stále nevím, kde jsem se tam vzal...',	'2014-02-20 23:48:22'),
(67,	'Jaký email je nejvíce využívaný?',	'Včera jsem psal o bezpečnostní chybě, která umožňuje získat podle mého názoru nezanedbatelně velký vzorek emailových adres. Krom toho, že bych byl rád, aby byla tato chyba opravena, nemám co jiného s touto kolekcí adres dělat. Tak jsem se rozhodl vytvořit nějakou statistiku. Svým způsobem se totiž jedná o dosti specifické uživatele, protože se pravděpodobně jedná z naprosté většiny pouze o ČR a SK uživatele, takže kdo čeká, že bude např. gmail umístěn nějak dobře, možná bude překvapen.\r\n\r\nA protože po diskusích krouží mnoho rádoby matematiků, rád bych teď přesně definoval všechny vstupní a výstupní hodnoty včetně jejich chyb, čímž doufám minimalizuji to, že výsledky někdo špatně pochopí. Všechny data jsou brány z kolekce čítající **384 392 unikátních** emailových adres s tím, že uvažuji zejména u rozložení poskytovatelů emailových schránek chybu 1%. Je to dáno tím, že vstupní data nejsou úplně korektní a ukazuje se, že se dost často vyskytují emaily jako `@seznam.czsms`, `@seznam.cztel`, `@seznam.czwww`, `@seznam.czweb`, `@senam.cz` atd. Většinu takových prohřešků jsem se snažil eliminovat, každopádně není to dokonalé. Osobně bych chybu odhadoval na desetiny, možná ani ne setiny procenta, ale raději ji nechávám větší. Tato chyba je v prvním grafu také graficky znázorněna. Zajímavé je také to, že někteří lidé evidentně chápu input pro zadání emailu jako deník, takže jsou schopni napsat do tohoto řádku všechny své emailové adresy. Stojí za zamyšlení jak správně navrhovat formuláře... Dále jsou pak z výpočtů zastoupení četnosti znaků prvních písmen emailových adres vypuštěny čísla, takže tato dílčí statistika počítá s o něco menší vstupní kolekcí 382 338 emailových adres.\r\n\r\nRozložení poskytovatelů emailových schránek\r\n===========================================\r\nNásledující graf ukazuje počet emailových adres příslušejících ke konkrétní doméně. Konkrétně je zobrazeno prvních 20 největších poskytovatelů a i tak již mají poslední méně než jedno procento velikosti prvního, tedy Seznamu. Ten je v českém zastoupení naprosto bezkonkurenční. Všímejte si prosím takových věcí. Většina programátorů se totiž potkává pouze s lidma \"od gmailu\", ale to je na českém trhu pouze minoritní složka. A je to tak u všeho. Je až překvapivě obrovský nepoměr mezi tím co si většina lidí myslí a skutečností. A tento vzorek již považuji za dostatečnou skutečnost.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=744207493\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nKolikrát jsem slyšel, že jsou Centrum a Atlas mrtvé projekty. To už ani nemá smysl počítat, ale reálně se ukazuje, že tomu tak vůbec není a těmto číslům momentálně věřím, protože už je zde přehazuji několik desítek hodin... (-: Bohužel nemám představu o tom, kolik existuje emailových adres v ČR, ale veřím, že se tvarově graf moc nepohne. Pouze se bude měnit počet na svislé ose.\r\n\r\nDalší zajímavá data\r\n===================\r\nDalší graf ukazuje skutečně velkou hloupost. Ani nevím proč jsem jí vlastně dělal. Jde o početné zastoupení prvních znaků emailových adres. To jsou ty modré pruhy. Červené pruhy jsou pak předpokládaná četnost znaků pro českou abecedu podle \"Jana Králíka .{target:_blank}\":http://www.czech-language.cz/alphabet/alph-prehled.html. Není to poprvé co tuto tabulku četností používám a dá se říci, že s ní souhlasím. Každopádně mám v plánu tyto četnosti ověřit a zaktualizovat, takže se možná tento graf časem malinko pozmění.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=1555577201\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nDalší informací, která již však nemá pevně uchopitelný základ je počet TLD. Lze tedy pouze říci, že ze vzorku zkoumaných dat, tedy ze vzorku emailových adres českých uživatelů mají největší zastoupení koncovky `.cz` (290311), poté `.sk` (88764) a další v pořadí je `.com` (5183), která se však svojí četností již poněkud mimo hru. Zajímavé teké je, že většinu překlepů dělají češi. To může být tím, že jsme prostě nepozorní, nebo jsou programátoři lajdáci. Tato informace je založena na počtu korekcí doménových názvů.\r\n\r\nPoslední již nikterak využitelnou informací je délka adres. Nejdelší adresy jsou `butovice.zlicine.tel.728222069.pouzite.kalhotky@...`, `www.malirstvi.tym.czemail.malirstvi.hruby@...` a `martin.59kenvelo400500600300700800900201@...` Zakrývám alespoň domény, aby někdo neprskal, když už proti tomu tak zbrojím. Naopak nejkratší je adresa, která má se vším všudy 8 znaků: `in@.....`.\r\n\r\nZajímá vás ještě nějaká informace, která se dá z této kolekce emailových adres získat?',	'2014-02-21 17:12:09'),
(68,	'Omyly hashování hesel',	'Někdy minulý rok jsem si četl prezentaci \"Michala Špačka .{target:_blank}\":http://www.michalspacek.cz/ o \"hashování hesel .{target:_blank}\":http://www.slideshare.net/spaze/hashe-hesla-develcz-2013 a byl jsem z toho poněkud zklamán. Naprosto souhlasím se vším co tam je, přesto však nemám rád, když se dojde k závěrům, které sice na první pohled dávají smysl a fakt dobře se tak dá argumentovat, ale ve výsledku jsou podle mého názoru některé opravdu chybné. Nedávno kolem mě tato prezentace proplula znova a protože již mám celkem setříděné myšlenky, rozhodl jsem se je sepsat.\n\nTímto článkem nehodlám hatit již zmíněnou prezentaci. Naopak se chci opřít do všech prezentací a výstupů, které něco tvrdí a není to tak docela pravda. Zároveň je také nutno říct, že nebudu řešit funkce typu MD5, protože doufám, že všichni v dnešní době vědí, že funkce MD5 prostě není určena na hashování hesel. Přesto si neodpustím několik vět i o konkrétních implementačních problémech.\n\nOmyl první\n==========\nKdyž jsem se opět dožadoval matematického důkazu o problému cyklického hashování, byl jsem dokázán na \"stackoverflow .{target:_blank}\":http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367, což mě mělo uspokojit. Četl jsem to pozdě v noci, takže jsem to nechal na ráno a ani tak jsem s tím nesouhlasil.\n\nV podstatě se jedná o popsání preimage útoku, který se snaží najít stejný hash jako je hash známý a tím získat původní (nebo jinou fungující) hodnotu hesla, tedy v tuto chvíli jediný zajímavý způsob. Celý důkaz toho, že cyklické hashování není dobrý nápad je prováděn na vlastní funkci a směšně malé množině vstupů. To je první divná věc. Mnohem divnější však je závěr pokusu, který tvrdí, že nekonečný vstup lze namapovat na konečnou množinu. Jedná se tedy o surjektivní zobrazení první množiny na druhou, kdy se každý prvek z první množiny namapuje na všechny prvky menší výstupní podmnožiny. A právě v tomto kroku vidím celou teoretickou úvahu jako chybnou. Žádná hashovací funkce totiž nepočítá s libovolným, nebo dokonce s nekonečným vstupem. Když to rozvedu i na konkrétní funkci MD5, pak nekonečný počet vstupů mapuji na 2^128 výstupů. Reálně (což je to co nás primárně zajímá) však mapuji 2^64 vstupů na 2^128 výstupů (čti bitů). V tu chvíli se však bavíme o injektivním zobrazení, což bylo v původním textu odsouzeno. Jak jsem k tomumo názoru došel? Vycházím z \"RFC 1321 - The MD5 Message-Digest Algorithm .{target:_blank}\":http://www.faqs.org/rfcs/rfc1321.html\n\n> A 64-bit representation of b (the length of the message before the\n> padding bits were added) is appended to the result of the previous\n> step. In the unlikely event that b is greater than 2^64, then only\n> the low-order 64 bits of b are used. (These bits are appended as two\n> 32-bit words and appended low-order word first in accordance with the\n> previous conventions.)\n\nPak už je jen malý krůček k tomu uvědomit si, že 2^64 bitové heslo je jinak řečeno něco kolem 2 exabajtů, což je tak trošku hodně i na uložení, natož na zapamatování. A i kdybych to spočetl blbě - jakože doufám, že ne - několik řádů sem tam je úplně jedno, protože množina na kterou se to mapuje je daleko větší. Stejně tak mi přijde naprosto komická tato ukázka:\n\n/--code\n$output = md5($input); // 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n\\--\n\nPřepíšu to jinak:\n\n/--code\n$output = md5($input); // 340282366920938463463374607431768211456 possibilities\n$output = md5($output); // 340282366920938463463374607431768211455 possibilities\n$output = md5($output); // 340282366920938463463374607431768211454 possibilities\n$output = md5($output); // 340282366920938463463374607431768211453 possibilities\n$output = md5($output); // 340282366920938463463374607431768211452 possibilities\n\\--\n\nVycházíme tedy z 340 undecilionů 282 decilionů 366 nonilionů 920 octilionů 938 septilionů 463 sextilionů 463 quintilionů 374 quadrilionů 607 trilionů 431 bilionů 768 milionů 211 tisíc 456 možností. Jasné? Tuto teorii tedy považuji za čistě teoretickou. Klidně si to heslo zašifrujte undecilionkrát... Ostatně stejný problém byl při šifrování vždy. Klidně se mohlo stát, že klíč od zprávy zašifrované v Enigmě (nebo kdekoliv jinde) uhodnou. Ale nedělalo se to, protože je to prostě jen papírový nesmysl. Ostatně i když se to stane, tak je to prostě debilní smůla, jenže věří snad ještě někdo tomu, že se to stane u celé databáze?\n\nOmyl druhý\n==========\nNyní budu předpokládat, že bude nyní mým cílem zjistit skutečně takové heslo, jaké bylo před zahashováním. Úplně tím tedy odbourám fakt, že dva různé texty budou mít stejný hash. To se může stát, druhá možnost však bude svým charakterem tak úplně jinde, že ji stejně nepůjde např. při přihlašování použít. Pokud tedy chci zjistit heslo z hashe u kterého vím, že bylo několikrát hashováno, nezbývá mi, než jít postupně z hashe až k heslu:\n\n/--code\n7eaefb28c9c3fe4be6997cc5b7fb599f // původní hash\n92b7db0f6d7348d91e90651d31ff9e71\n651a9c9c86f3116a53e2bb6e80bfdf69\n1b929b62a2c822c4a59e688fde2a3a0b\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nJenže jaké teď skutečné heslo? Je to \"heslo\"? Pokud bych byl chytrý a uměl si zapamatovat 32 znaků, moje heslo by určitě bylo \"1b929b62a2c822c4a59e688fde2a3a0b\" a jen bych zmátl všechny okolo. A potom je celkem sranda to, když se vrátíme k čistě teoretickému uvažování a řekněme, že se může stát, že dva hashe budou totožné:\n\n/--code\n1b929b62a2c822c4a59e688fde2a3a0b // původní hash   <-\n... // dlouhá série hashů vedoucích k opakování     |\n651a9c9c86f3116a53e2bb6e80bfdf69                    |-- stejné hashe\n1b929b62a2c822c4a59e688fde2a3a0b   <-----------------\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nVěřte, že mé heslo je teď \"651a9c9c86f3116a53e2bb6e80bfdf69\". Při pokusu o zjištění původu hashe mám dvě možnosti. Mohu najít takový hash, který je před tím prvním, ale jiný než \"955db0b81ef1989b4a4dfeae8061a9a6\", nebo právě \"955db0b81ef1989b4a4dfeae8061a9a6\". V prvním případě je to stejné jako předchozí případ. V druhém však naleznu nejdříve jinou shodu a nejen že dojdu k jinému heslu, ale také úplně přeskočím to správné heslo. Takže v určitém případě může být opakované hashování dokonce ještě bezpečnější! Opět je to pouze teorie, ale chci tím ukázat, že některé argumenty mohou být sice silné, mají však vždy i obrácenou stranu, která není o nic slabší...\n\nChtěl jsem tedy vyvrátit několik zažitých předpokladů, což se mi doufám podařilo. Musím však dodat nesmírně důležitou věc. Neobhajuji zde použití MD5 ani jiné podobné funkce (která tak jako MD5 není k hashování hesel určena). Používejte spíše funkce, které mají složitou výpočetní náročnost a jejich výstup je pro dva stejné vstupy různý. Takovou dobrou funkcí je pro PHP funcke `password_hash`, která byla vytvořena právě kvůli tomu, že v tom programátoři dělají neskutečný bordel. Použití je úplně jednoduché:\n\n/--code php\n<?php\necho password_hash(\'heslo\', PASSWORD_DEFAULT);\n\\--\n\nTato funkce momentálně používá bcrypt, do budoucna je možné použít konstantu PASSWORD_BCRYPT, protože defaultní konstanta může způsob šifrování změnit na nějaký lepší. Stejně jednoduché je i ověření hesla:\n\n/--code php\nif (password_verify(\'heslo\', \'$2y$10$2YOiYB9vFd11vTRBtqqKE.TnrT1ydXuCGsSHXbAKRvUgnpE9VaoES\')) {\n    echo \'Password is valid!\';\n} else {\n    echo \'Invalid password.\';\n}\n\\--\n\nTyto funkce, stejně tak jako dobře použitý kompatibilní `crypt` považuji za naprosto dostatečná řešení a víc se o tom není třeba již <s>nikdy</s> bavit. Tečka.\n\n<span style=\"color:green\">A pod tečkou ještě něco. Čím musím napravit nešťastně volená slova v předchozí větě. Tím že se o tom není již třeba nikdy bavit je myšleno to o čem se ve větě píše, tedy že bcrypt funkce považuji za naprosto dostatečné (v současné době i blízké budoucnosti) a za tím si stojím. Neznamená to však, že teď házím za hlavu celou tuto problematiku. Pokud bych měl tedy předchozí větu opravit, napsal bych asi, že tyto funkce považuji za naprosto dostatečné, nicméně stále má smysl tuto problematiku řešit, protože věřím, že v zřejmě ne malém horizontu let bude i tato funkce nedostatečná. Teď ale není.</span>',	'2014-02-22 14:02:31'),
(69,	'Čteme QR kódy bez čtečky',	'[* 2139a61c-efc4-4e3c-b630-5c3cbf9258df/qrcode-ahoj.png 200x200 <]\n\nPatříte mezi lidi, kteří se nespokojí pouze se čtečkou QR kódů, ale chcete vědět jak fungují? Nebo co víc jak je přečíst bez použité takové čtečky? Tak to jste na správné adrese. Dnes budu řešit zejména právě čtení QR kódu bez použití čtečky. Celou dobu budu řešit tento QR kód na levé straně, takže doporučuji nepoužívat telefon a počkat až na konec, kde se jeho obsah dozvíte. Zároveň se nebudu nijak opírat o korekci chyb a další jinak důležité věci, ale budu se co nejvíce soustředit právě na přečtení kódu bez použití jakéhokoliv přístroje. Pojďme na to...\n\nTrocha nezbytné teorie\n======================\n[* 312d5904-ab94-4877-9743-8ec902fbc50a/qrcode-parts.png <]\n\nQR kód asi viděl každý. Stejně tak předpokládám, že spoustu lidí tuší, že QR kód dodržuji určitá pravidla, aby jej šlo přečíst strojově. Jedná se zejména o \"finder pattern\", tedy ty velké čtverce, které slouží k zaměření čtečky a určení orientace kódu. Díky tomu, že jsou tři, tak lze QR kód přečíst i pokud je vzhůru nohama. Dalším významným prvkem jsou separátory, které obklopují právě tyto čtverce a slouží k oddělení zaměřovačů od zbytku kódu. Žlutě jsem zvýraznil tzv. \"timing patterns\". Ty se táhnout z rohu do rohu zaměřovacích čtverců, kdy se celou dobu střídá černá a bílá barva a slouží opět pro čtečky například k určení velikosti celého kódu. Na takto malém kódu nejsou žádní informace i verzi, ani korekční body.\n\nNejdůležitější jsou však červené a zelené části. Zde jsou uloženy informace i formátu, které následně také využijeme. Je zajímavé, že se jak červená část, tak zelená část na kódu vždy dvakrát opakuje. Informace je očíslována čísly 1-15 s tím, že kolem levého horního zaměřovače je informace celá a ta samá informace je ještě rozdělena a umístěna kolem zbylých dvou zaměřovačů. Je zde ještě jedna zajímavost. V levém dolním rohu nad číslem 9 je černé místo, tzv. \"dark module\". Toto místo by mělo být na všech kódech černé. Jedná se přebytečné místo, které vzniká při zdvojování informace o formátu. Podle specifikace by to tak mělo být, ale ne vždy to platí. Pro nás je však zajímavá jediná část z celé 15 bitů dlouhé informace a to konkrétně bity umístněné na pozici 11, 12 a 13, tedy v zelené části. Právě ty si nesou tu nejdůležitější informaci o masce. Všechny ostatní části informace slouží ke korekci chyb. Celkově se ve výsledku ukáže, že kromě samotné informace je v QR kódu sloustu \"zbytečných\" věcí, které informaci nenesou. V mašem případě je tedy maska `111` (černé místo je 1 a bílé 0). Tuto informaci je však ještě potřeba dekódovat pomocí XOR součtu přičtením hodnoty `101`, tedy:\n\n/--code\n111\n101 /XOR\n---\n010\n\\--\n\nCelá dekódovací maska je `101010000010010`, ale pro naší potřebu je potřeba pouze část `101`. Ještě než vysvětlím co to maska je, uvedu zde všechny hodnoty jaké může maska mít:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr><td>Hodnota masky</td><td>Podmínka masky</td></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>000</td>\n      <td>(i + j) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>001</td>\n      <td>i mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>**010**</td>\n      <td>**j mod 3 = 0**</td>\n    </tr>\n    <tr>\n      <td>011</td>\n      <td>(i + j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>100</td>\n      <td>((i div 2) + (j div 3)) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>101</td>\n      <td>(i j) mod 2 + (i j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>110</td>\n      <td>((i j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>111</td>\n      <td>((i+j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n  </tbody>\n</table>\n\nTo může vypadat děsivě, ale hned vysvětlím. Podle toho jakou má kód masku vezmeme vzorec a dosadíme za **j** číslo sloupce. V našem případě se tedy bavíme o prvním a pak každém třetím sloupci. Pro tyto sloupce platí, že na nich musíme provést negaci, tedy otočit barvy. Tím QR kód odmaskujeme. Toto však platí pouze pro částí kde je opravdu nějaká informace, nikoliv pro zaměřovače, nebo například části nesoucí formátovací informaci. Toto maskování slouží k zamíchání barevných polí. Nestane se tak, že by byl kód nejednoznačný. Při kódování se totiž porovnávají jednotlivé masky, každá maska má nějaké skóré jednoznačnosti a ve výsledku se vybere ta nejjednoznačnější. Celé odmaskování je znázorněno na obrázku níže. Pravý černý QR kód je již odmaskovaný a nic nebrání jej přečíst. V tuto chvíli však již pouze bez použití čtečky.\n\n[* 63e85abb-b86a-4877-9640-fb70b4cd2542/qrcode-important.png 300x300 <]\n[* 3951a3ea-5f53-4af9-9c01-a45fd71dd5b0/qrcode-unmasked.png 300x300 *]\n\nHrajeme si na čtečku\n====================\n[* 0ed74ba7-ddec-40da-ab12-4e6b8d82103c/qrcode-decode.png <]\n\nPředchozí část byla možná trošku složitější, ale když se na to podíváte zpětně je to vlastně velice jednoduché. Stačí přečíst 3 bity z celého kódu, provést jednoduchý XOR a jak se ukáže dále, tak stačí invertovat pouze jeden sloupec, protože více jich není potřeba.\n\nPodívejte se nyní na levý obrázek. Ten ukazuje, jak budeme číst uloženou informaci. Barevně znázorněná část je kompletní informace. Zbytek kódu je pro nás v tuto chvíli jen odpad. Barevně zvýrazněná část se ještě dělí na tři podčásti. Červená oblast obsahuje informaci o módu. Bity čteme vždy podle čísel a šipek. Tento QR kód je tedy v módu `0100` což je mód \"BYTE\". Data tedy budeme rozdělovat tak, aby měla každý část 1 byte, tedy 8 bitů. Tyto módy a další informace jsou velmi podrobně popsány v oficiální dokumentaci. Modrá část nám ještě prozrazuje informaci o délce, binárně tedy `00000100` což je v desítkové soustavě číslo 4. Takže informace v tomto QR kódu má délku 4 znaky. Opíšeme si tedy řadu bitů:\n\n/--code\n01100001 01101000 01101111 01101010\n\\--\n\nZde by mohl být trošku zádrhel pro lidi, co neumí ASCII tabulku. Prozradím tedy malý fígl. Pokud binární čásla prevedeme do decimální soustavy, což je velmi jednoduché, získáme následující zápis:\n\n/--code\n97 104 111 106\n\\--\n\nA teď už je to jen posunutá abeceda, protože číslo 97 je malé **a**. Výsledkem je tedy po chvilce abecedování:\n\n/--code\na h o j\n\\--\n\nTo nebylo tak těžké, že? Je to sice absurdní a pravděpodobně nikdy nikoho neuvidím s tužkou a papírem před QR kódem, ale i tak si myslím, že je dobré tyto věci vědět, když už se QR kód používá tak často. Doporučuji všem přečíst si dokument *ISO/IEC 18004:2006*, který řeší právě QR kódy. Je to nesmírně zajímavý dokument plný obrázků a úplných popisků, ačkoliv je i v tomto dokumentu pár drobných chyb.',	'2014-02-28 12:49:05'),
(70,	'AJAX upload souborů v Nette pomocí Fine Uploaderu #2',	'\"Dříve\":http://zlml.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu jsem psal o tom, jak použít Fine Uploader jakožto nástroj pro AJAXové nahrávání souborů na server. Původní článek však platí pouze pro verzi `3.*`, která je dnes již zastaralá. Pojďme si dnes ukázat v podstatě to samé, ale pro novější verzi `4.3+`, která se v učitých směrech poměrně zásadně liší od svého předchůdce. Tentokrát se to však pokusím vyřešit co nejjednodušeji.\n\nZačátek je vlastně úplně stejný. Musíme nalinkovat javascriptové soubory:\n\n/--code html\n<!-- jQuery -->\n<script src=\"{$basePath}/js/jquery.fineuploader-4.3.1.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití je úplně jednoduché, ve zjednodušené formě:\n\n/--code html\n<div id=\"image-uploader\"></div>\n\\--\n\nSnažím se ukázat opravdu jen kritické minimum, protože ty základní věci jsou stejné, případně dohledatelné v dokumentaci, takže se dají oba dva návody z velké části doplnit. Minule jsem však zatáhl do ukázek i poměrně hodně balastu, takže ten u staré verze nechám, ale bude následovat opravdu jen to nejnutnější.\n\nStejně tedy jako v předchozí verzi následuje javascriptový spouštěcí kód. Zde již vznikají určité odlišnosti:\n\n/--code javascript\n$(function () {\n	$(\'#image-uploader\').fineUploader({\n		debug: true, //hodí se pro lazení\n		request: {\n			endpoint: \'pictures?do=uploadPicture\'\n		},\n		retry: {\n			enableAuto: true\n		}\n	});\n});\n\\--\n\nPoužití je tedy téměř stejné, až na to, že jsem úplně vypustil překlad textů. V této nové verzi jsou totiž novinkou šablony (ostatně proto také nové číslo verze). Uživatel-programátor má tak více pod kontrolou výsledný vzhled uploaderu:\n\n/--code html\n<script type=\"text/template\" id=\"qq-template\">\n	<div class=\"qq-uploader-selector qq-uploader\">\n		<div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n			<span>Přetáhněte soubory sem</span>\n		</div>\n		<div class=\"qq-upload-button-selector qq-upload-button\">\n			<div>Klikněte, nebo přetáhněte obrázky</div>\n		</div>\n        <span class=\"qq-drop-processing-selector qq-drop-processing\">\n           <span>Zpracovávám přetažené soubory...</span>\n           <span class=\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\"></span>\n        </span>\n		<ul class=\"qq-upload-list-selector qq-upload-list\">\n			<li>\n				<div class=\"qq-progress-bar-container-selector\">\n					<div class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n				</div>\n				<span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n				<img class=\"qq-thumbnail-selector\" qq-max-size=\"100\" qq-server-scale>\n				<span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"></span>\n				<span class=\"qq-upload-file-selector qq-upload-file\"></span>\n				<input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n				<span class=\"qq-upload-size-selector qq-upload-size\"></span>\n				<a class=\"qq-upload-cancel-selector qq-upload-cancel\" href=\"#\">Zrušit</a>\n				<a class=\"qq-upload-retry-selector qq-upload-retry\" href=\"#\">Opakovat</a>\n				<a class=\"qq-upload-delete-selector qq-upload-delete\" href=\"#\">Smazat</a>\n				<span class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n			</li>\n		</ul>\n	</div>\n</script>\n\\--\n\nA opět následuje zpracování v handleru:\n\n/--code php\npublic function handleUploadPicture() {\n	$uploader = new \\UploadHandler();\n	$uploader->allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\");\n	$result = $uploader->handleUpload(__DIR__ . \'/../../www/uploads\');\n	$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nZde celkem není co pokazit, ale pokud by bylo potřeba vrátit chybu, provede se to opět pomocí `JsonResponse`:\n\n/--code php\n$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse(array(\n		\'error\' => $exc->getMessage(),\n)));\n\\--\n\nSamotná třída `UploadHandler` je pak opět k nalezení na \"GitHubu\":https://github.com/Widen/fine-uploader-server/blob/master/php/traditional/handler.php. Tento návod tedy mohu zakončit vlastní citací:\n\n> A to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například podle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit. To konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2014-03-03 21:15:13'),
(71,	'Sbohem NDBT, vítej Doctrine',	'Byl jsem požádán, abych napsal nejenom důvod přechodu z Nette Database na Doctrine, ale obecně co mě k tomu vedlo a jak takový přechod vlastně učinit. Na úvod bych však chtěl zdůraznit, že nejsem žádný extra programátor, vlastně to ani nestuduji, takže vše co budu ukazovat a vysvětlovat je tedy z mého pohledu a lecjakého OOP znalce by tento text mohl pobouřit... (-:\n\nNásledující text používá \"Kdyby\\Doctrine\":https://github.com/Kdyby/Doctrine, nevidím důvod proč ve spojení s Nette používat něco jiného. Je to dobrá knihovna.\n\nSbohem NDBT\n===========\nNette Database Table a obecně celé Nette Database je úžasná část frameworku a spokojeně jsem ji používal po velmi dlouhou dobu. Nikdy jsem neholdoval pokřikům, že je NDBT zabugované (jako někteří) a i když jsem vyzkoušel i jiné alternativy, vždy jsem se spokojeně vracel právě k NDBT. Použití je velice intuitivní a dobře se s tím zachází:\n\nModel:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Nette\\Database\\Context */\n	private $database;\n\n	public function __construct(Nette\\Database\\Context $context) {\n		$this->database = $context;\n	}\n\n	public function getAllPosts() {\n		return $this->database->table(\'posts\')->where(\'release_date < NOW()\');\n	}\n\n}\n\\--\n\nPresenter:\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$this->template->posts = $this->posts->getAllPosts();\n	}\n\n}\n\\--\n\nJe to jednoduché a jasné. Takové věci mám prostě rád. V modelové třídě mám jak select metody, tak insert metody, takže bych tomu správně neměl říkat repository, ale abych byl upřímný, tak je mi toto názvosloví celkem volné. Do takové objektu si prostě dám to co chci (tak jak mi to dává smysl). Nepřijde mi to vůbec podstatné. Tahání dat z databáze má však ještě jednu vrstvu a tou je vykreslování.\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->related(\'posts_tags\')->order(\'tag_id ASC\') as $post_tag}\n			<a n:href=\"Tag:default, $post_tag->tag->name\">\n				<span style=\"background: #{$post_tag->tag->color}\">{$post_tag->tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nA to je věc, která mě dlouhou dobu trápila. Dá se čekat, že když v databázi existuje jakási vazba mezi příspěvkem a tagem, tak že tuto vazbu budu chtít nějak využít. A to pokud možno co nejvíce pohodlně. A co nejvíce pohodlně znamená, že v okamžik, kdy budu pracovat s příspěvkem a vzpomenu si, že potřebuji také tagy, tak tyto tagy také dostanu. Bohužel musím znát také spojovací tabulku, která nemá (minimálně v tomto případě) žádný faktický smysl a celkově práce s takto \"dopřivázanou\" tabulkou není vůbec pohodlná a už vůbec ne intuitivní. Dává to smysl a asi to tak být musí, takže proti NDBT žádná, ale tak nějak vnitřně jsem hledal něco lepšího (čti více vyhovujícího mým požadavkům).\n\nVítej Doctrine\n==============\nSchválně se snažím vše popisovat podle mých myšlenkových pochodů, proto i nadále budu řešit úplně ten samý problém, jen s použitím Doctrine. Nutno ještě dodat, že Doctrine rozhodně nebyla jasná volba. Opět mi dlouho trvalo, než jsem obecně ORM přišel na chuť. Ještě před Doctrine jsem nějakou dobu experimentoval s \"Lean Mapperem\":http://www.leanmapper.com/ od Vojtěcha Kohouta (Tharos). Malou nevýhodou je, že téměř veškerá dokumentace je v brutálně dlouhém vláknu na Nette fóru, které má v tuto chvíli **1023 příspěvků**, takže je to občas dřina, ale myslím si, že je to skutečně povedená knihovna. Vojtěch Kohout má skutečně dobré myšlenky. Nicméně jsem prostě chtěl přijít Doctrine na chuť, takže jsem i Lean Mapper opustil. Občas dělám radikální změny, pokud by však někdo vyloženě potřeboval důvod k tomu začít s Doctrine (alespoň dočasně), pak tedy jeden mohu nabídnout. A bude velmi krátký. Vidíte někdy jako požadavek na zaměstnance znalost Lean Mapperu, nebo ActiveRow? Pokud ne, tak začněte s tím co se tam ukazuje často. Doctrine.\n\nAle zpět k tématu. Pojďme si ukázat modelovou část podle mě:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Kdyby\\Doctrine\\EntityDao */\n	private $dao;\n\n	public function __construct(Kdyby\\Doctrine\\EntityDao $dao) {\n		$this->dao = $dao;\n	}\n\n	public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {\n		return $this->dao->findBy($criteria, $orderBy, $limit, $offset);\n	}\n\n}\n\\--\n\nVelmi podobné jako u předchozího modelu. Asi by šlo si napsat nějakou `__call` metodu, protože se dost často volá to co už je v DAO objektu (viz níže), ale kdo si to jak poslepuje, tak to bude mít... A co prezentační vrstva?\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$posts = $this->posts->findBy(array());\n	}\n\n}\n\\--\n\nTo je také dost podobné. Pole kritérií potom slouží k dodatečnému filtrování ve tvaru např. `[\'id\' => 21]`, tedy předává se to, co se má použít i v SQL WHERE klauzuli. Tento zápis je mi poměrně blízký, protože jsem ho používal při komunikaci s jedním SOAP serverem. Ok, co na to šablona?\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->tags as $tag}\n			<a n:href=\"Search:default, $tag->name\">\n				<span style=\"background: #{$tag->color}\">{$tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nTak to je podle mě úplně super výsledek. Maximálně intuitivní a nic víc splňuje to má očekávání. Je však asi zřejmé, že jsem úplně vypustil jakoukoliv informaci o spojovací tabulce. A také jsem ještě neřekl, co je to `EntityDao`, se kterým se pracuje v modelu. Vlastně je to úplně jednoduché. V konfiguračním souboru definuji, že chci pracovat s jakýmsi DAO objektem, tedy objektem, který oproti repository umožňuje data nejen číst, ale také ukládat (opět pouze OOP slovíčkaření).\n\n/--code neon\nservices:\n	- App\\Pictures(@doctrine.dao(Entity\\Picture))\n	- App\\Posts(@doctrine.dao(Entity\\Post))\n	- App\\Tags(@doctrine.dao(Entity\\Tag))\n	- App\\Users(@doctrine.dao(Entity\\User))\n\\--\n\nFajn, teď mám tedy v každé modelové třídě DAO objekt. Ten obsahuje několik metod, které výrazně usnadňují práci s Doctrine (\"source\":https://github.com/Kdyby/Doctrine/blob/master/src/Kdyby/Doctrine/EntityDao.php). Do tohoto objektu předávám jakousi entitu. To je objekt, který reprezentuje strukturu databázové tabulky. To možná není napsáno úplně šťastně, ale prakticky to tak skutečně většinou je. Taková entita může vypadat například takto:\n\n/--code php\nnamespace Entity;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name=\"posts\")\n */\nclass Post extends Doctrine\\Entities\\BaseEntity {\n\n	/**\n	 * @ORM\\ManyToMany(targetEntity=\"Tag\", inversedBy=\"posts\", cascade={\"persist\"})\n	 * @ORM\\JoinTable(name=\"posts_tags\")\n	 * @ORM\\OrderBy({\"name\" = \"ASC\"})\n	 */\n	protected $tags;\n\n	/**\n	 * @ORM\\Id\n	 * @ORM\\Column(type=\"integer\")\n	 * @ORM\\GeneratedValue\n	 */\n	protected $id;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $title;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $slug;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $body;\n\n	/** @ORM\\Column(type=\"datetime\") */\n	protected $date;\n\n}\n\\--\n\nZde je právě důležité to, že rovnou ukazuji, kde je entita reprezentující tagy (která vypadá podobně jako tato), jak se k ní dostanu a dokonce jak se má řadit. Tedy všechny tyto informace jsem ze šablony odstranil. Pro mě je to tedy úžasný pokrok, protože jsem dosáhl toho co jsem chtěl. Aby se mi s databází pracovalo dobře.\n\nNo dobře, ale...\n================\nA teď je právě čas na některé dotazy, které vznikly při přípravě tohoto článku. Tak například co když chceš položit vlastní dotaz, v Nette Database je to přeci snadné. V Doctrine \"také\":https://bitbucket.org/mrtnzlml/zlml.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/Posts.php?at=master#cl-128. V tom by ORM nemělo nijak zásadně bránit...\n\nDalší věc je, že v presenteru stále zůstává jistá závislost na struktuře tabulek. Konkrétně opět mluvím o poli kritérií. Jak se úplně zbavit této závislosti a mít pokud možno vše tak, aby když změním strukturu, tak to změním jen někde a ne všude? K tomu se dají použít třeba query objekty, které v sobě drží podobu potřebného SQL dotazu, takže místo toho, abych stále ťukal ten samý dotaz, jen jinde, tak jej schovám do třídy a právě tu pak používám. Budoucí změna se pak pravděpodobně bude týkat právě pouze toho objektu a případně entit. Ono toto asi nejde úplně odstínit (nebo spíš nevím jak), protože vždy je potřeba data i nahrávat a tedy stanovit určitou hranici mezi tím co je závislé na databázi a co už není. Nicméně uvážím-li, že budu měnit strukturu tabulky třeba kvůli tomu, že chci přidat nová data, stejně budu do kódu muset jít a někde ty data vzít a někam je dát. Proto je toto možná úplně zbytečné řešit, protože tato závislost nikdy nepůjde úplně odstranit.\n\nDalší věc je trošku záludná. Týká se tříd pro vazební tabulky. Pokud tedy ukládám M:N vazbu jako v předchozím textu, tím myslím, že mi jde pouze o to, že chci uložit do této tabulky cizí klíče, tak se o nic nemusím starat a stačí mi pouze onen dokumentační komentář v entitě `Post` nad proměnnou `protected $tags`, kde je definováno vše potřebné. Problémové je, když chci uložit data i do vazební tabulky. Zde bych rád citoval jeden příspěvek ze StackOverflow, protože si myslím, že tam je vše řečeno naprosto přesně.\n\n> A Many-To-Many association with additional values is not a Many-To-Many, but is indeed a new entity, since it now has an identifier (the two relations to the connected entities) and values.\n\nA přesně takto je s tím tedy potřeba zacházet. Už se nebavíme o vazební tabulce. Už se bavíme o normální tabulce, která vyžaduje svoji entitu a pouze obsahuje dva cizí klíče místo běžného jednoho.\n\nDoufám, že se mi v tomto článku svojí délkou limitně blížící se k nekonečnu podařilo zodpovědět všechny dotazy a objasnit všechny pochybnosti. Pokud ne, můžete se na celou problematiku podívat pod drobnohledem ještě \"zde\":https://bitbucket.org/mrtnzlml/zlml.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/?at=master. Máte na celou problematiku jiný názor, nebo to jak to dělám já je kompletně špatně? Sem s tím... (-:',	'2014-03-11 19:34:00'),
(72,	'Orion login stojí za prd',	'Když jsem dříve připravoval \"prezentaci o Nette Frameworku\":http://zlml.cz/prednaska-z-nette-na-zcu, hledal jsem nějaký vhodný příklad, na kterém bych demonstroval zranitelnost webových aplikací. Úspešně jsem vyzkoušel pár eshopů a jednu stránku, která slouží ke školním účelům, ale není nijak oficiálně vedená pod univerzitou. Právě zde mě napadlo vyzkoušet také univerzitní systémy. A nestačil jsem se divit.\n\nPozadí univerzitního přihlašování\n=================================\nVeškeré ověřování práv a identit putuje přes WebKDC server. Tento server komunikuje s Kerberosem a dohromady tvoří systém, který umožní přihlášení pomocí univerzitních loginů. Celkově proti tomuto systému nemám vůbec nic. Mám však hodně výhrad k jeho konkrétní implementaci. Konkrétní web servery (tam kde jsou umístěny aplikace vyžadující přihlášení) komunikují se vzdáleným WebKDC serverem. Tento server zajistí korektní ověření uživatele (spolupráce s Kerberos) a vráti informaci o úspěšném ověření. Paráda. Vnitřně velmi sofistikovaný systém funguje a umožňuje SSO (Single Sign-On) napříč celou infrastrukturou. Platí to tedy i pro aplikace mimo univerzitní doménu. Zjednodušeně popsáno, ale tématem tohoto článku není ta část, která \"spolehlivě funguje\":http://webauth.stanford.edu/, ale ta část, která nefunguje.\n\n/--code\n WEBKDC <----------> KERBEROS\n   |||\n   |||\n WEBAUTH (server s aplikací vyžadující přihlášení)\n    |\n    |\n STUDENT\n\\--\n\nJako poměrně zásadní fakt vidím to, že dokud student neklikne na \"LOGIN\", tak ho tento systém nepřihlásí (většinou). Nachází se tedy na úrovni \"WEBAUTH\", ale vidí jen omezenou stránku. Jakmile se chce přihlásit, aplikace jej přesměruje na WebKDC login-server, kde může vyplnit své přihlašovací informace, nebo je již přihlášen někdy z dřívější doby a v obou případech je přesměrován zpět na server s webovou aplikací. Už vidíte ten problém? :-)\n\nXSS\" onclick=\"alert(document.cookie); //:-)\n===========================================\nPrávě komunikace mezi WEBAUTH a WEBKDC je pro ověření naprosto zásadní, ale díky tomu, že zřejmě není nastavena žádná implementační laťka, tzn. že kdokoliv chce přihlašovat pomocí tohoto systému tak si to prostě nějak naprogramuje, vznikají bezpečnostní bublinky. Pravděpodobně neexistuje žádná konvence jak tento systém implementovat, takže neexistují ani takové funkce, jako je třeba ověřování již aktivního přihlášení atd. Může se tedy stát, že budu přihlášen (ověřen) ve webové aplikaci, ale na WEBKDC jsem odhlášen, protože WEBAUTH už se o to v tuto chvíli nestará (ten je přihlášen).\n\nDíky tomuto poznatku mohu velmi jednoduše vše co jsem teď napsal zapomenout, protože se dá celé složité schéma zjednodušit na toto:\n\n/--code\n WEBAUTH                   WEB-APP\n    |          resp.          |\n    |                         |\n STUDENT                   STUDENT\n\\--\n\nTak moment. Není to úplně normální přihlášení tak jako je na jakékoliv jiné úplně obyčejné stránce? Uživatel (student, profesor, administrátor) je přihlášen a teď už je to pouze nudná otrocká práce. Myslím, že mohu prozradit, že je stránka (čti univerzitní projekty) náchylná na session hijacking, na to přijde každý blbec, který o tom četl na wiki. A asi nemá smysl tajit, že XSS je naprosto reálná (a vyzkoušená) hrozba. Nebudu však říkat kde. A vzhledem k tomu, že tento systém webových portálů (IBM Web-Sphere Portal) není žádná domácí výroba, tak předpokládám, že stejný problém budou mít i další univerzity.\n\n/--code\n WEB-APP1     WEB-APP2\n    |            |\n    |----------EVA\n STUDENT\n\\--\n\nOd první chvíle, kdy jsem na tento problém upozorňoval poprvé jsou některé věci v současné době na serverech pozměněny, ale to zásadní zůstává pořád stejné. Nezáleží na tom co je v pozadí, když je řetěz tak silný, jak je silný jeho nejslabší článek a zvlášť, když ten silný zbytek řetězu skoro ani není potřeba...',	'2014-03-16 17:00:29'),
(73,	'Plzeňský Barcamp - láska na první pohled',	'Ačkoliv jsem z dřívějších barcampů sledoval záznamy, tak jsem byl fakticky na barcampu úplně poprvé a rovnou jsem měl tu čest přednášet. Než se však dostanu k samotné přednášce, rád bych zde napsal nějaký feedback. Celkově jsem z Plzeňského Barcampu skutečně nadšen. Skvělá atmosféra, fajn lidi, spoustu jídla, alkoholu možná až moc... :-))\n\nNa druhou stranu došlo i k pár přešlapům. Některé mě mrzí více, jiné ani tak ne, každopádně... Skutečně mě mrzí to, že nebyla nahrávána na video každá přednáška.\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/eshopkonzultant\">@eshopkonzultant</a> Honzo, máme to v plánu. Pokud nám ho nic nenaruší, chtěli bychom určitě záznamy dodat nejdéle do měsíce po skončení akce.</p>&mdash; Plzeňský Barcamp (@PlzenskyBarcamp) <a href=\"https://twitter.com/PlzenskyBarcamp/statuses/454275681665687552\">April 10, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nTo se moc nepovedlo. Mrzí mě to ze dvou důvodů. Jednak jsem tak nějak slíbil, že má přednáška bude potom na netu, to však není ten závažnější problém. Daleko více mě mrzí fakt, že se teď nemohu podívat na přednášky ostatních protože jsem byl jinde. Na barcampu bylo totiž spoustu zajímavých témat.\n\nDalší už jen krátce abych nezněl moc negativně, protože se mi na barcampu opravdu líbilo a zase tak moc mě tyto věci neštvou. Přístup k netu jen pro přednášející. Měl jsem možnost toho využít, nevyužil jsem, takže o nic nejde, jen bych veřejnou wifi na takových akcích čekal. Další jsou samolepky se jménem při registraci. No já nevím jak ostatním, mě prostě vůbec nedržela a než jsem došel do prvního patra, tak jsem měl na zádech jmenovku se jménem Martina. Bohužel bez čísla. Zdravím Martinu! :-) Poslední věc, která mě mohla dost uzemnit byla ztracená prezentace. Svojí prezentaci jsem na barcamp odeslal předem jak stálo v emailu, ale když jsem se po ní ptal, tak nebyla k nalezení. Naštěstí jsem měl plán B. Uff...\n\nPřednášky\n=========\nPostupně jsem se snažil projít ty nejzajímavější přednášky. Zde je jejich přehled:\n\n*Machine learning, aneb od našeptávače k porozumění řeči (\"Jan Švec .{target:_blank}\":https://twitter.com/honza_svec)* - přednáška o strojovém učení, porozumění řeči a chápání významu psaného i mluveného textu. Některým lidem tato přednáška přišla obsahově zajímavá a skutečně byla, každopádně tyto informace jsem z velké většiny již znal, protože jsem je slyšel již dříve a zase tolik se toho v tomto oboru nemění.\n\n*Procesory letajici, tikajici, hrajici a komunikujici (\"Radek Voltr .{target:_blank}\":https://twitter.com/crawlerdev)* - to je zase opak toho prvního. Některým lidem to nepřišlo moc zajímavé, protože tyto věci znají. Já je tolik neznám a i z důvodu svých budoucích prací do školy pro mě byla tato přednáška přínosným přehledem toho jak lze nacpat slušný výpočetní výkon na malou mršku.\n\n*Virtualizace a cloudy v dnešním IT (\"Milan Brych .{target:_blank}\":http://www.orgis.cz/cs/)* - nejvíce debatované a kontroverzní téma. Každopádně Milan se toho ujal dobře a ačkoliv tam bylo spoustu lidí z oboru, tak i v publiku došlo k debatám lidí s naprosto odlišným názorem. A zpětně musím dodat, že jednoznačně souhlasím s tím, že cloud jako takový je cloudem teprve tehdy, pokud je geograficky rozložen a má dostatečnou redundanci strojů. Někdo na přednášce zmiňoval cloud funkci u NAS serverů. V tu chvíli jsem se musel pousmát...\n\n*Věrnostní program a jeho odvrácená tvář (\"Marek Mencl .{target:_blank}\":https://twitter.com/mmencl)* - asi nejlepší přenáška. Zpětný pohled za projektem, který sice nějak dopadl, ale jeho průběh nebyl úplně hladký. Přednáška byla plná reálných problémů z praxe. Super. Prostě super. Jestli bude záznam, tak doporučuji!\n\n*Pracujte v trenýrkách z kavárny. Nebo ne? (\"David Šmehlík .{target:_blank}\":https://twitter.com/davidsmehlik)* - abych byl upřímný, tak na tuto přednášku jsem šel jen proto, že jsem neměl kam jinam a vybral jsem tak nejmenší zlo. Každopádně rychle jsem zjistil, že jsem udělal dobře, protože celé povídání bylo velmi zajímavé a motivující. I přes původní nedůvěru považuji tuto přednášku za druhou nejlepší. Sorry, Marek byl lepší... :-))\n\n*O e-shopech, o automatickém výpočtu nabídek za prokliky na Heurece a o tom, kde je problém doopravdy (\"Michal Janík .{target:_blank}\":https://twitter.com/michaljanik)* - zde to bylo celkem jednoduché. Jít na populární blbost (dle zpětných názorů ostatních), nebo na SEO (jak slyším SEO, tak utíkám), nebo na prezentaci neúspěšného portálu? Vybral jsem si tedy přednášku o e-shopech. Nejsem eshopista, takže to pro mě nemělo takovou přidanou hodnotu a myslím si, že kdokoliv nad problémy obchodu přemýšlí, tak dokonverguje ke stejným závěrům jako jsou v prezentaci. Každopádně říct, že to bylo nezajímavé by bylo nejen nefér, ale ani by to nebyla pravda.\n\nOpět musím zopakovat, že mě mrzí absence kamer u ostatních přednášek.\n\nOd Caesara ke QR kódům\n======================\nA konečně k mé přednášce. :-))\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Přednáška o kódování a Thomasu Youngovi na <a href=\"https://twitter.com/search?q=%23barcampcz&amp;src=hash\">#barcampcz</a> je kulervoucí.</p>&mdash; Pavel Pajkrt (@PavelAbbePajkrt) <a href=\"https://twitter.com/PavelAbbePajkrt/statuses/455008230444638208\">April 12, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nA zde je:\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/33460846\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nDěkuji všem posluchačům. Byl jsem skutečně nadšen, když za mnou pak někdo v průběhu dne přišel a děkoval. To bylo kouzelné. Nesmírně si toho vážím. Každopádně abych se jen nevychvaloval, tak cítím určitý dluh vůči posluchačům, protože ačkoliv se mi s tím Luboš Majner i Milan Brych snažili pomoct (díky!), tak jsem nedokázal závěrečnou problematiku úplně objasnit. A vzhledem k tomu, že jsem se pak ještě o těchto věcech několikrát bavil, tak přibližně tuším v čem byly problémy.\n\nTak prvně padl dotaz z kterého bylo jasné, že jsem něco řekl fakt špatně. Proč to šifrovat tak složitě? Proč neposlat rovnou surovou zprávu, když to nejde odposlechnout? To je velice jednoduché. Je sice pravda, že (alespoň v současné době) kvantový signál nelze odposlechnout, nic však nebrání Evě zastřelit Boba a zprávu si jednoduše přečíst. To se u šifrovaného signálu nemůže stát.\n\nA jak je tedy možné že ten signál nelze odposlechnout? Jde o to, že přenášená zpráva není ve formě informace, ale přenáší se pomocí nějakého fyzikálního principu. Takže se nelze připojit na optický kabel aniž by to nebylo zjistitelné. Každopádně jsem rád za závěrečnou diskusi, jelikož byla velmi přínosná a uvědomil jsem si věci, které jsem předtím neřešil. Například komunikaci po veřejném kanálu a ověření, že Alice skutečně mluví s Bobem a ne s Evou. Přečtěte si článek tento \"http://aldebaran.cz/bulletin/2005_14_kry.php .{target:_blank}\":http://aldebaran.cz/bulletin/2005_14_kry.php. Konkrétně poslední část o spolehlivosti metody. Již rozumím padlým dotazům a dávám posluchačům za pravdu. Beru to jako poučení a příští rok už budu tento problém schopen podat ještě líp. Doufám... :-)\n\nJo a přišel si to poslechnout i David Grudl. Yaaay! :-D',	'2014-04-13 13:31:22'),
(75,	'Stáhněte si lepší blog',	'Čas od času se na Nette fóru najde někdo, kdo hledá vzorový projekt do kterého by se mohl podívat. Vlastně se většinou hledá cokoliv, jakákoliv inspirace. Bohužel se zřejmě všichni bojí toho, že o svůj projekt přijdou, protože v něm někdo najde bezpečnostní chybu. Já se toho také bojím, ale lepší než před tím utíkat je se tomu postavit čelem. A tak je to tady.\n\nKdokoliv cokoliv\n================\nK dispozici je pro nahlédnutí tento blog. A nejen k nahlédnutí, ale také k \"volnému používání\":http://zlml.cz/develop.\nNa pozadí běží hned několik technologií, které si můžete prakticky osahat:\n\n+ Nette Framework (\"nette.org .{target:_blank}\":http://nette.org/)\n+ Nette Tester (\"tester.nette.org .{target:_blank}\":http://tester.nette.org/)\n+ Texy *(je sexy)* (\"texy.info .{target:_blank}\":http://texy.info/)\n+ FSHL (\"fshl.kukulich.cz .{target:_blank}\":http://fshl.kukulich.cz/)\n+ Webloader (\"addons.nette.org .{target:_blank}\":http://addons.nette.org/janmarek/webloader)\n+ Kdyby\\Doctrine 2 (\"GitHub\":https://github.com/Kdyby/Doctrine)\n\nK dispozici je i databáze, protože si myslím, že bych se i s únikem databáze neměl nijak ohrozit... :-) Účelem tohoto nápadu a následně rozhodnutí je poskytnout pokud možno funkční a aktivní projekt, který staví právě na těchto technologiích. Důvodem je pak moje zkušenost s tvrdým začátkem. Mám příležitost občas pracovat s někým kdo se přesně toto chce naučit, bohužel pár lidí už to prostě vzdalo, protože je toho *moc* a není mnoho lidí kteří skutečně pomohou (rozhodně ne na fóru). Snažím se tedy zaplnit toto prázdné místo a nabídnout tento blog jako jeden z možných začátků. Mimochodem neříkám, že moje řešení je nejlepší, nebo správné. Je jedno z možných a funkčních. Stáhnout si jej můžete ze své oblíbené verzovací služby:\n\n/---html\n<div class=\"row\" style=\"margin-top:50px;margin-bottom:50px\">\n	<div class=\"col-lg-6 col-md-6 col-sm-6 text-right\">\n		<a class=\"btn btn-default\" href=\"https://bitbucket.org/mrtnzlml/zlml.cz\" target=\"_blank\">\n			<img src=\"/img/loga/bitbucket.png\">\n		</a>\n	</div>\n	<div class=\"col-lg-6 col-md-6 col-sm-6\">\n		<a class=\"btn btn-default\" href=\"https://github.com/mrtnzlml/zlml.cz\" target=\"_blank\">\n			<img src=\"/img/loga/github.png\">\n		</a>\n	</div>\n</div>\n\\---\n\nPodrobnější popis najdete na \"samostatné stránce\":http://zlml.cz/develop věnované tomuto projektu. Byl bych moc rád, kdybych touto cestou pouze nenabídl něco chybějícího, ale také získal zpětnou vazbu. Nestojím o pochvaly. Ty samozřejmě potěší, ale mnohem přínosnější jsou praktické poznámky k implementaci, nebo funkcím. Nad takovou věcí se vždy rád zamyslím...',	'2014-05-19 11:00:51'),
(76,	'Disqus lazy loading',	'Tento článek ve skutečnosti odstartovalo zdánlivě nesouvisející vlákno na \"Nette fóru .{target:_blank}\":http://forum.nette.org/cs/19397-ako-sa-zbavit-fid-v-url-ak-sa-nemylim. V tomto vláknu se řeší parametr *_fid* v URL adrese, který tam Nette framework přikládá kvůli flash messages. Tato vlastnost někoho skutečně hodně štve, mě zase až tak moc ne. Jenže když jsem nad tím vláknem chvíli seděl, tak jsem si uvědomil, že mám komentářový systém Disqus implementovaný špatně. Čtěte dál a vyhněte se stejné chybě... (-:\n\nUniverzální kód\n===============\nDisqus poskytuje \"by default\" univerzální kód, který prakticky pouze zkopírujete na svůj web na požadované místo a je hotovo. Tento kód vypadá zhruba takto:\n\n/--code html\n<div id=\"disqus_thread\"></div>\n<script type=\"text/javascript\">\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = \'\'; // required: replace it with your forum shortname\n\n    /* * * DON\'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement(\'script\'); dsq.type = \'text/javascript\'; dsq.async = true;\n        dsq.src = \'//\' + disqus_shortname + \'.disqus.com/embed.js\';\n        (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n    })();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n\\--\n\nJe to pohodlné, ale je to úplně blbě. Nejenom pro Nette aplikace, ale myslím si, že tak nějak celkově pro všechny aplikace. Fungovat to sice bude, to ano. Ale jen tak zdánlivě. Problém je totiž v tom, že toto nastavení bere jako identifikátor diskuse URL adresu a pokud se jen drobně změní, tak se založí nová diskuse. Přehled těchto diskusí je pak vidět v Disqus administraci. To s sebou nese celou řadu problémů. Diskuse nejde pořádně zamknout a už to, že k jedné stránce může být více diskusí je problém. Každá diskuse totiž musí mít unikátní identifikátor \"disqus_identifier .{target:_blank}\":https://help.disqus.com/customer/portal/articles/472098-javascript-configuration-variables nezávisle na parametrech (pokud ovšem tyto parametry nejsou žádoucí).\n\nLazy loading\n============\nJá jsem sice nepoužil defaultní konfiguraci, ale udělal jsem prakticky tu samou chybu. Teď ale konečně k lazy loadingu. Na svém blogu to již používám dlouhou dobu a myslím si, že se to již osvědčilo. Inspirací k mé implementaci je \"tento gist .{target:_blank}\":https://gist.github.com/omgmog/2310982.\n\nStačí umístit následující kód do nějakého souboru *main.js*, který se spouští po načtení stránky:\n\n/--code javascript\nvar disqus_div = $(\"#disqus_thread\");\nif (disqus_div.size() > 0) {\n    var ds_loaded = false,\n    top = $(\'.load_disqus\').offset().top, //upravit podle potřeby\n    disqus_data = disqus_div.data(),\n    check = function () {\n        if (!ds_loaded && $(window).scrollTop() + $(window).height() > top) {\n            ds_loaded = true;\n            for (var key in disqus_data) {\n                if (key.substr(0, 6) == \'disqus\') {\n                    window[\'disqus_\' + key.replace(\'disqus\', \'\').toLowerCase()] = disqus_data[key];\n                }\n            }\n            var dsq = document.createElement(\'script\');\n            dsq.type = \'text/javascript\';\n            dsq.async = true;\n            dsq.src = \'http://\' + window.disqus_shortname + \'.disqus.com/embed.js\';\n            (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n        }\n    };\n    $(window).scroll(check);\n    check();\n}\n\\--\n\nTím to však nekončí. Je samozřejmě nutné určit kde se Disqus bude zobrazovat:\n\n/--code html\n<div class=\"hidden-print\">\n	<div id=\"disqus_thread\" data-disqus-shortname=\"mrtnzlml\" data-disqus-url=\"{link //this}\"></div>\n	<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n	<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n</div>\n\\--\n\nKlíčový je zde právě data atribut *disqus-url*. No a aby byl kod kompletní, tak je zapotřebí někam umístit CSS trídu *.load_disqus*. Tu doporučuji umístit někam nad diskusi a tím myslím třeba o celou viditelnou stránku. Disqus se tak začne načítat o něco dříve, než k němu čtenář doscrolluje, takže se stihne načíst a nebude to rušit. Ve výsledku se tedy Disqus nenačítá po otevření stránky, takže je načtení svižné, ale po např. přečtení článku je již načtený...\n\nA co vy? Máte Disqus na svém webu implementovaný správně? (-:',	'2014-06-12 21:36:26'),
(77,	'Čteme Data Matrix bez čtečky',	'[* 1fc11f25-abc2-453e-abb4-adb31d0ccf17/datamatrix.png <]\n\nDnešním článkem navazuji na dřívější článek \"Čteme QR kódy bez čtečky\":http://zlml.cz/cteme-qr-kody-bez-ctecky, ve kterém jsem řešil čtení QR kódu bez použití jakéhokoliv čtecího zařízení. A dnes budu řešit téměř to samé, ale s jiným kódem. Data Matrix není tolik známý, ale myslím si, že patří, hned po QR kódech, mezi nejpoužívanější kódy vůbec. Po tomto článku si jich zajisté začnete všímat více. Naposledy jsem jej viděl na balíčku od jahod... (-: Opět platí, že hlavním cílem je kód přečíst, nikoliv mu úplně porozumět, takže nebudu rozebírat velké detaily.\n\nLevý obrázek je kód o kterém bude celou dobu řeč.\n\nTrocha nezbytné teorie\n======================\n[* 0dd271b6-21ea-4c3c-a447-723b76257b50/datamatrix-key.png <]\n\nTento kód je oproti QR kódu velmi jednoduchý, takže i teorie bude stručná. Veškerá data a korekce chyb je ukryta uvnitř rámu, který je z části plný. To umožňuje čtečkám poznat kde všude je ještě kód a jak je natočen. Z pohledu \"ručního\" čtení je tato část nezajímavá. Modře jsou zvýrazněny 4 bity, které k ničemu neslouží a zaplňují jen prázdné místo. Ne vždy je tento úkaz vidět. Bohužel tentokrát nemám k dispozici originální specifikaci, takže nevím jakým přesným pravidlům to podléhá.\n\nNejpodstatnější jsou však červeně zarámované oblasti. Všechny mají takovýto tvar a vždy mají přesně dané umístění. Toto umístění je vlastně dáno první oblastí s číslem 2. Nicméně z hlediska umístění dat je nejdůležitější pátý bit v prvním sloupci od kterého vše startuje. Pokud obrazec přesahuje to timing zón, tedy do nažloutlého rámu, tak pokračuje na druhé straně, tedy dole, nebo na pravé straně.\n\nData se v kódu čtou podle čísel, tedy podél takové diagonální vlnovky a to až do obrazce s číslem 5. Tento obrazec určuje konec zprávy. V našem případě se tedy jedná o zprávu, která má 4 znaky. A jak už to tak bývá, tak jsou všechny znaky přenášeny v binárním formátu. Zbytek kódu, který není nijak zvýrazněn je klasicky Reed–Solomon korekce chyb. Možná bych o tomto mechanismu také mohl někdy napsat článek. Nicméně napovažuji to za úplně jednoduchá záležitost, takže si to zatím nechám v zásobě.\n\nHrajeme si na čtečku\n====================\n\nPřečíst zprávu v takto teoreticky rozebraném kódu už je otázka chvilky. Najdříve si vytáhneme všechny potřebné části. V tomto případě je zbytečné řešit pátý člen, jelikož se jedná o poslední ukončovací. Jeho hodnota je 129 v desítkové soustavě. Získané útvary jsou vidět na obrázku níže.\n\n[* 76028c59-4e5f-42f4-a411-3452844a30d2/last.png *]\n\nČísla určují pozici bitů v binárním čísle. Po přepsání do binární podoby mají znaky následující hodnoty:\n\n/--code\n01100010 01101001 01110000 01101011\n\\--\n\nV desítkové podobě jsou to tedy čísla:\n\n/--code\n98 105 112 107\n\\--\n\nNásledně je zapotřebí od těchto čísel odečíst jednotku. Abych řekl pravdu, tak jsem po dlouhém uvažování nedokázal přijít s rozumným vysvětlením proč se to tak dělá. Původně mě napadadlo, že je to kvůli lepšímu rozložení bitů ve výsledném obrazci. Stejně tak jako se u QR kódů bity ještě maskují. To ale nedává smysl. Je to jen posunutí o jedna. Nic víc... Nicméně je zřejmé, že spousta věcí je v takovýchto kódech minimálně na zamyšlení. Ale zpět k poslednímu kroku. Z předchozího článku již všichni vědí, že číslo 97 je v ASCII tabulce hodnota znaku **a**, takže po odečtení jednotky a přepsání do čitelné podoby získáváme řešení:\n\n/--code\n97 104 111 106\na  h   o   j\n\\--\n\nTento kód je pro čtení bez čtečky daleko snadnější, komplikuje to jen nezvyklé uspořádání bitů. Jaký další kód bych měl dostat pod drobnohled? Snad to půjde. Mám zde totiž rozpracovaný ještě jiný a nemohu k němu sehnat normu pro nahlédnutí, takže jsem se zatím zasekl... (-:',	'2014-06-15 16:34:13'),
(78,	'Novinky na blogu a extension RFC',	'Kdo pravidelně sleduje \"můj twitter\":https://twitter.com/mrtnzlml, tak už to ví. A je to skvělé! Včera jsem totiž \"mergnul\":https://github.com/mrtnzlml/zlml.cz/commit/b21775df522271e81302d2987ff44d5285b245eb důležitou část tohoto blogu a tím vydal verzi 1.1 snad stable... (-: Jedná se o celkem významný krok, ale stále je to nic oproti tomu co mám v plánu. V dnešním článku bych se rád podělil o většinu zajímavých novinek a v druhé části bych rád požádat o pomoc s rozvinutím jednoho zajímavého nápadu.\n\nNovinky v release 1.1\n=====================\nA hned první novinka je ta nejzajímavější. Zastávám názor, že by si měl programátor za svým kódem stát a to v každé situaci. Proto jsem se rozhodl, že pustím kohokoliv do své administrace. Ostatně proč ne. Je to výzva. Rád bych však napřed požádal kohokoliv kdo najde nějakou chybu, aby mi to dal vědět na základě nepsané programátorské etikety a nesnažil se celý blog hned zničit. Zálohu mám... :-) Administraci najdete na adrese zlml.cz/admin a přístupové údaje jsou `demo / demo`. Enjoy.\n\nAčkoliv je první představená novinka asi nejzajímavější pro kohokoliv jiného, pro mě osobně je nejzajímavější nový systém vkládání obrázků. To je něco co mi na blogu dlouho chybělo. Představoval jsem si to tak, že bych obrázky jednoduše a rychle nahrál a stejně jednoduše bych je vložil do aktuálně psaného článku. A přesně to teď můžu udělat. Použil jsem \"fineuploader\":http://fineuploader.com/, protože je to skvělý program. Můžu AJAXově nahrávat souběžně několik obrázků s velikostí klidně až za PHP limitem `upload_max_filesize` a nebo navázat na přerušené nahrávání. To vše vlastně díky chunk uploadu. Umí toto váš blog? Zkuste si na sdíleném hostingu nahrát soubor o velikosti třeba 50MB...\n\nToto jsou dvě nejdůležitější změny, na kterých jsem v desetinkové verzi pracoval. Správa uživatelů a cool image uploader. Dále jsem udělal opět několik designových změn a fixů, ale už se nejedná o nic tak důležitého aby to stálo za řeč.\n\nDalší kroky a žádost o pomoc\n============================\nSvůj blog mám rád. A mám ho rád až tak, že bych byl rád, aby ho časem používal i někdo jiný. To ještě nějakou chvíli potrvá, ale už nějaký čas mi leží v hlavě nápad, jak se k tomuto požadavku přiblížit. Rád bych totiž blog přepsal do Nette extensions. Včera jsem popré \"nakousl\":https://github.com/mrtnzlml/zlml.cz/commit/1ffc33bc5dddbadfc1b6ce7d30dccb09938800cb svojí myšlenku. Princip je jednoduchý. Přepíšu například funkcionalitu obrázků (nebo čehokoliv jiného) do extension a když bude někdo budovat nový blog, tak si jen v konfigu zvolí jaké moduly chce (to se dá snadno generovat):\n\n/--code neon\nextensions:\n	- ImageExtension\n    - SearchExtension\n    - ...\n\\--\n\nSamotné extension má potom za úkol se samo spustit (`afterCompile`) a přidat nějaké funkcionality do stacku (v metodě `initialize`). V prvním nakousnutí například přidávám položku do menu a skutečně to funguje tak jak píšu. Jakmile nějakou funkci nechci, prostě ji z konfigu zruším. Výhodné na tom je to, že můžu prošpikovat blog místy, kam lze nové feature zaregistrovat a dají se velmi jednoduše provázat přes composer. **Ale.** Má to háček.\n\nKdyž jsem si s touto myšlenkou hrál jen v hlavě, tak to bylo super, protože vše fungovalo perfektně. Bohužel jsem narazil na to, že nevím jak pěkně vyřešit šablony a routování na ně. Šablony jsou totiž jedna z dalších věcí které bych zde chtěl vyřešit. Bylo by fajn, kdyby mohl mít každý možnost si třeba šablony podědit a změnit si kompletně celý design. To zase takový problém není. Ale jak vyřešit to, když chci v extension např. přidat novou stránku? Kam umístit šablonu a jak ji naroutovat? Nějak jsem to dneska v noci už nedokázal vymyslet. Máte někdo prosím nějaký zajímavý nápad? Díky...\n\nNo a naposledy už snad jenom: \"Give me a star, please\":https://github.com/mrtnzlml/zlml.cz...',	'2014-07-13 14:00:51'),
(79,	'SračkoAPI',	'Následující řádky budou čistý hate na několik tvůrců API, který má posloužit budoucím tvůrcům API. Sám totiž musím obsluhovat několik služeb a získávat z nich data. A ačkoliv se nebráním složitostem, některé věci jsou tak absurdní, že až rozum zůstává stát...\n\nNo to si ze mě děláte...\n------------------------\nPrvní místo na žebříčku debility získává API pro obsluhu a registraci domén od Web4U. Jedná se o klasické SOAP API, které mě však místy přivádí k šílenství. Začnu pěkně od začátku. Aby bylo vůbec možné API volat, musíte nejdříve získat identifikátor služby. Kde jej sehnat? Napadá vás někde v aministraci? Kde jinde také, že? Omyl! Identifikátor služby se získává tak, že zavoláte jakoukoliv funkci z jejich API špatně a identifikátor najdete ve vrácené exception. A to si nedělám prdel. To fakt mají napsané v dokumentaci. A aby toho nebylo málo, tak vrácené ID je ve formátu `IDxxxxxxx, ...`. Koho by však napadlo, že ID je tich prvních 9 znaků, tak je na omylu. ID je totiž to ID bez úvodního ID, tedy `xxxxxxx`. Takto je to možná jasné, ale když k tomu poprvé sednete, tak nad tím sedíte půl dne. Následně lze funkci opět volat s vráceným ID. A právě volání je další sranda.\n\nV dokumentaci je totiž jasně napsáno co jsou povinné vstupní hodnoty, volitelné hodnoty a občas i co to vrací. Takže je to jasné, prostě tam pošlu pole hodnot key-value a je to. Hahaha. Ne. Do tohoto API se totiž posílá pole polí s tím, že je zapotřebí dodržovat přesně stanovený formát a to takovýto:\n\n/--code php\narray(\n	array(\'name\' => \'key\', \'data\' => \'value\'),\n	//...\n)\n\\--\n\nJe to jedna z věcí, která je prostě hloupá. Pokaždé se musím sám sebe ptát, proč to tak je? Nerozumím tomu, nemá to žádnou přidanou hodnotu. Jdeme dál. Řekněme, že potřebujete pomocí API zjistit nějakou informaci o doméně, například kdy skutečně expiruje. Na to se stačí jednou týdně zeptat a aktualizovat si informace v databázi. To pro případ, že byla doména prodloužena u třetí strany. No, nebudeme to rozebírat dále. Přes API nelze tuto funkci zavolat. Proč? Vyžaduje totiž captchu. Jo, ta funkce v API se fakt volá přes obrázkovou captchu. Jako jediná. Chápu jak to použít, ale prakticky všechny své projekty dělám plně automatizované, takže jediné řešení je zde najmout \"armádu Indů\":http://www.root.cz/clanky/potrebujete-obejit-captcha-zaplatte-si-armadu-indu/ a captchy louskat ručně.\n\nA takových perel je tam nespočet. Potřebujete vědět, jestli proběhla funkce v pořádku? Nope. Výstupem z funkce je totiž číslo požadavku. Chybu si totiž musíte poměrně nepěkně vydlabat z exception. Další věc je čistě logická. České domény lze registrovat pouze s NSSETem. Jinak to nejde. U jiných domén se zadávají jednotlivé NS servery. U CZ domény se musí nejdříve vytvořit identifikátor držitele kontaktu. U jiných domén se vytváří při registraci domény. To se všechno může zdát jako maličkosti, ale takové věci vše zbytečně komplikují a použití takového API je spíš otrava. Přitom si myslím, že největší příliv např. domén musí být právě strojově přes API.\n\n...ale už fakt prdel!\n---------------------\nRychlá otázka k zamyšlení. Jak uděláte API, aby bylo možné jej snadno testovat? Změníte například přístupové údaje na testovací, nebo budete posílat nějaký testovací token? OK. Myšlenka je jasná. Kdykoliv se to dá snadno přehodit např. změnou jednoho hesla do ostrého režimu. Jenom v debilním API se metody pro testování jmenují jinak, než metody pro ostré použití. Kurva! To je další věc, která to celé nepříjemně zkomplikuje.\n\n[* d10561e0-aeec-4dae-a21e-17eb7c4ca36d/gif.gif <]\nDobře, poslední příklad. Nedávno jsem zase něco nevyčetl z dokumentace. Napsal jsem tedy na technickou podporu ať mi poradí, že to tam nemají napsané. Konkrétně se jednalo o povolené vstupní hodnoty do jedné funkce. Na odpověď jsem čekal dva dny, což by ani tak nevadilo, ale hodně jsem se nasmál u odpovědi, která přišla v tomto formátu (původně zapsáno pod sebou):\n\n/--code\n\'cs\', \'sk\', \'bg\', \'hr\', \'da\', \'nl\', \'en\', \'et\', \'fi\', \'fr\', \'de\', \'el\', \'hu\', \'ga\', \'it\', \'lv\', \'lt\', \'mt\', \'pl\', \'pt\', \'ro\', \'sl\', \'es\', \'sv\'\n\\--\n\nWhat? Takže podpora také nevěděla a tak mi poslala kus vykopírovaného zdrojového PHP kódu z aplikace? V tuto chvíli už mi začíná být všechno jedno... \n\nJde to i jinak?\n---------------\nVím, že ano, ale stále častěji mě někdo přesvědčuje o opaku. Druhé ukázkové API jsem zvolil pro porovnání také typu SOAP. V tomto API je již většina věcí na které jsem do této chvíle nadával vyřešena. Dokonce jsem potěšen z toho, že se jedná o API poměrně inteligentní a tak se mohu dotazovat hodně podobně jako v Doctrine 2. Paráda.\n\nJenže pak přijde, jak říká kolega, další jobovka. API je totiž totálně bez dokumentace, takže téměř jediné místo, kde lze získat informace o vstupních a výstupních hodnotách je prohlédnout si celý dump dané funkce. Dobře, to není problém. Vidím datum ve známém formátu jako string. Posílám tedy také datum ve stejném formátu jako string. Nic. Dobře, poslím ho jako DateTime. Nic. Až po hodně dlouhé době a nahlášeném bugu jsem dostat fuck off odpověď, že to datum zadávám špatně a musí to být v následujícím formátu:\n\n/--code php\n//...\narray(\n	\'year\' => ...->format(\'Y\'),\n	\'month\' => ...->format(\'m\'),\n	\'day\' => ...->format(\'d\'),\n	\'hour\' => ...->format(\'H\'),\n	\'minute\' => ...->format(\'i\'),\n)\n//...\n\\--\n\nA dost vole, seru na to. Na to nemám nervy. Zase ta samá otázka. Proč? Vždyť... Ale nic. Už raději nic.\n\nProsím všechny programátory, **snažte se víc**. Cílem by mělo být **usnadnit používání**, nikoliv však sobě, ale **uživatelům**. Prosím...\n\nHowgh.',	'2014-07-17 21:58:50'),
(80,	'Za hranicí ORM',	'Již mnohokrát jsem slyšel, že je ORM \"antipattern\":http://www.zdrojak.cz/clanky/orm-je-antipattern/. Já si to nemyslím. Je to hloupý a uspěchaný názor. V dnešním článku však nechci rozebírat co je a co není antipattern. To je jen zbytečnou ztrátou času. Rád bych ukázal použití jednoho ORM systému, který mě naprosto uchvátil.\n\nKdyž jsou potřeba firemní procesy\n=================================\nZejména začínající firmy mají na svém startu náročný úkol. Je zapotřebí vytvořit vnitrofiremní procesy, které striktně řídí běh různých akcí jako je například výroba, reklamace, nebo třeba koloběh dokumentů. Ve firmě \"taková řešení nabízíme\":http://www.orgis.cz/sluzby/in-house a je o ně velký zájem. Má to svůj smysl. Není žádným tajemstvím, že používáme ERP systém \"Odoo\":https://www.odoo.com/, protože je to velmi silný nástroj. I přes neuvěřitelnou modifikovatelnost této aplikace je občas zapotřebí sáhnout k daleko více sofistikovanému řešení. Proč? Občas jsou totiž vnitropodnikové procesy velmi složité a navíc jich je velké množství. V takovém případě, je téměř jedinou možností napsat si pro tento ERP systém rozšíření, které tento těžký úkol zvládne.\n\n[* 393212dc-381f-4b3a-a06c-fb5d33d6dc29/workflow.png *] *** *Ukázka struktury klasického firemního workflow*\n\nNechci však psát návod na to, jak si takový modul naprogramovat. O tom třeba někdy příště. Pojďme se raději podívat na to, jak téměř celé Odoo funguje, protože je to skutečně pozoruhodné. Bez kódů to však nepůjde.\n\nZáplava tabulek\n===============\nAbych byl upřímný, tak jsem se ještě nikdy nesetkal s tím, aby byl **každý** objekt v projektu skutečně realizován tabulkou v databázi. Nebo o tom alespoň nevím. Je to v podstatě jako když máte entity a ty jsou pak skutečně v databázi. Rozdíl je však v tom, že zde je v \"entitě\" i celá potřebná logika (které většinou moc není) a hlavně žádné jiné objekty nejsou potřeba.\n\nV nejprostším tvaru může tedy třída modulu vypadat skutečně pouze jako entita:\n\n/--code python\nclass project_wkf_activity(osv.osv):\n    _name = \'project.wkf.activity\'\n    _columns = {\n        \'sequence\': fields.integer(\'Sequence\'),\n        \'name\': fields.char(\'Workflow Activity Name\', required=True, size=64, translate=True),\n        \'type\': fields.many2one(\'project.wkf.type\', \'Workflow Type\'),\n        \'fold\': fields.boolean(\'Folded in Kanban View\'),\n    }\n    # ...\n    def jumptoseq(self, cr, uid, ids, sequence, context=None):\n    	#...\n\\--\n\nPři programování modulů toto vede k extrémní explozi tabulek v databázi. 500 tabulek uděláte v databázi jako nic. Stačí nainstalovat pár modulů. A to už mi přijde dost netradiční. Kromě modulových tabulek je v základní instalaci asi 100 tabulek, které v sobě drží vše možné, mimo jiné také informace o workflow. A právě definice workflow je to nejzajímavější. Veškerá sranda se totiž odehrává v XML souborech. Ve výsledku stačí pro napsání složitého workflow včetně veškeré logiky pouze XML...\n\nXML programování (-:\n====================\nKdyž jsem toto poprvé viděl, párkrát jsem se zastavil a přemýšlel jsem, jak to vlastně může fungovat. Je to však velmi jednoduché. V inicializačním souboru modulu si stačí nadefinovat jaké XML soubory se mají načítat. Následuje definice workflow. Žádné psaní okolo. Prostě to hned funguje. Začátek takového workflow může vypadat například takto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<record id=\"wkf1\" model=\"workflow\">\n            <field name=\"name\">project.wkf1</field>\n            <field name=\"osv\">project.project</field>\n            <field name=\"on_create\">True</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nTím je workflow založeno a při spuštění převedeno do databáze. Jádro má pak za úkol se těchto tabulek chytit a pracovat s nimi. Jsou jasně daná pravidla, takže s tím není žádný problém. Následuje definice akcí (to jsou ty bubliny na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        \n        <record id=\"a_1_0\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_start\">True</field>\n            <field name=\"name\">start-wkf1</field>\n            <field name=\"kind\">dummy</field>\n        </record>\n\n        <record id=\"a_1_10\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"name\">nazev-activity</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">jumptoseq(10)</field>\n        </record>\n        \n        <record id=\"a_1_500\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_stop\">True</field>\n            <field name=\"name\">end</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">orgis_close()</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nA následuje definice transitions (spojení na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        <!-- viz definice aktivit -->\n        \n        <record id=\"t_1_9\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_40\"/>\n            <field name=\"act_to\" ref=\"a_1_50\"/>\n            <field name=\"signal\">a_1_40toa_1_50</field>\n        </record>\n        <record id=\"c_1_7\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_36\"/>\n            <field name=\"act_to\" ref=\"a_1_500\"/>\n            <field name=\"signal\">close_wkf</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nUkázky jsou nekompletní, protože by se to sem všechno ani náhodou nevešlo. Výsledný XML soubor vlastně stačí k tomu, aby celé workflow fungovalo. Stačí nadefinovat funkce v příslušných třídách viz například volání `jumptoseq`.\n\nDost často je také zapotřebí definovat tlačítka pro view, což se dělá také pomocí XML kde je opět originálně vyřešeno přepisování defaultní šablony. Tlačítka mají vždy nějakou akci, která zajistí, že se posuneme ve workflow dále. Na takové workflow lze pověsit úplně všechno. Poslání emailů, vygenerování faktur, založení akce v kalendáři atd. Pokud se jedná o vyloženě automatické kroky, akce se na tlačítku nemusí definovat a pak systém celé workflow proskáče a spustí všechny akce popořadě sám. Zajímavé je však to, že se po spuštění všechno nahrne do databáze a jádro Odoo se strará pouze o to, aby tento interně složitý systém fungoval správně. Všem lidem, kteří nadávají na ORM bych tedy položil následující otázku. Jak uděláte takto sofistikovaný systém bez ORM? Nebo že toto snad není ORM? A uvědomte si, jak jsem se strašně rychle dokázal dostat z ORM až na celý komplexní systém workflow. Je to proto, že jsem vůbec neuvažoval něco jako je ActiveRow... (-: I když z velké části je to spíše plnění tabulek.\n\nV tomto reálně fungujícím řešení je velmi hluboká myšlenka. A udivuje mě, že v jiných systémech toto funguje úplně obráceně. Všichni se snaží programovat spíše to jádro. Ukazuje se však, že využít kvalitní jádro, které se stará o všechno je daleko přínosnější. Vzpomeňte si na tento článek, až budete ťukat do klávesnice entity, mappery, repository, DAO objekty a další a to pouze kvůli tomu, aby bylo možné udělat nějaké takové workflow, jako jsem zde teď popsal. Už zase...\n\nPoužíváte také nějakou netradiční implementaci ORM?',	'2014-08-01 22:55:45'),
(81,	'Komunikace s ERP pomocí XML-RPC',	'Spousta lidí by se ráda připojovala na API ERP systému \"Odoo\":https://www.odoo.com/, ne vždy je to však procházka růžovým sadem, protože se očekává místy až přehnaná interní znalost tohoto systému. Přitom je to zbytečné. V dnešním článku se pokusím zdokumentovat právě tuto žalostně zdokumentovanou stránku věci tak, aby to zvládl každý alespoň trochu zdatný programátor.\n\nPrvně však několik málo slov o co vlastně jde. Odoo je ERP (\"Enterprise Resource Planning\":http://www.orgis.cz/sluzby/in-house) systém poměrně bohatý na funkce a má za úkol řešit zejména vnitrofiremní procesy a obecně všechny záležitosti, které se okolo jakékoliv firmy motají. Lze tedy řešit plánování projektů, jejich workflow, rozvrhování času, řízení zakázek, ale také například správu dokumentů, skladové zásoby, mass mailing, nebo tzv. \"Point of Sale\":https://www.odoo.com/page/point-of-sale což je jedna z těch nejvíce zajímavých věcí, alespoň z mého pohledu. Zjednodušeně řečeno lze udělat naprosto cokoliv. A co nejde, tak se jednoduše doprogramuje. Aby však šlo udělat cokoliv, je potřeba připojovat se na tento systém vzdáleně, protože občas se hodí propojit stávající webovou aplikaci právě s takovýmto systémem. To může mít několik důvodů. Například chcete mít ve webové aplikaci data sjednocená s ERP systémem, nebo si chcete vzdáleně stahovat faktury, popř. tlačit data do účtovacího systému. Jak již bylo řečeno - možné je naprosto cokoliv.\n\nHello API!\n==========\nOdoo poskytuje klasické XML-RPC API. Toto API je velmi jednoduché na obsluhu, nicméně ani tento druh API \"není můj favorit\":http://zlml.cz/srackoapi. S výhodou tedy můžeme použít lehce modifikovanou funkci \"Jakuba Vrány\":http://php.vrana.cz/webove-sluzby-v-php-xml-rpc-a-soap.php pro obsluhu tohoto API (PHP):\n\n/--code php\n<?php\n\nfunction xmlrpc($url, $method, $params = array(), $types = array(), $encoding = \'utf-8\') {\n    foreach ($types as $key => $val) {\n        xmlrpc_set_type($params[$key], $val);\n    }\n    $context = stream_context_create(array(\'http\' => array(\n        \'method\' => \"POST\",\n        \'header\' => \"Content-Type: text/xml\",\n        \'content\' => xmlrpc_encode_request($method, $params, array(\'encoding\' => $encoding))\n    )));\n    return xmlrpc_decode(file_get_contents($url, false, $context), $encoding);\n}\n\\--\n\nNásleduje krátká odbočka k tomu, co vše je možné přes API udělat. Opět bych mohl napsat, že cokoliv, ale zde už si nejsem jist a proto následuje výpis funkcí, které je možné přes api volat a hlavně které považuji za důležité. Existují totiž 4 služby a každá obsahuje jiné metody. Nejhlavnější služba je `common`. Zde jsou k dispozici mimo jiné funkce `login(db, login, password)`, `about(extended=False)`, `timezone_get(db, login, password)` a `version()`. Většina funkcí se dostatečně popisuje sama, pozor však na funkci \"about\", protože ta v době psaní tohoto článku \"obsahovala chybu\":https://github.com/odoo/odoo/pull/2028. Je tedy zřejmé, že tato skupina funkcí se hodí pro zalogování do systému, nebo pro zjištění časového pásma, popř. verze systému. Pojďme se tedy přihlásit:\n\n/--code php\n<?php\n//...\n$data = array(\'database\', \'username\', \'password\');\n$uid = xmlrpc(\"http://.../xmlrpc/common\", \"login\", $data);\n\\--\n\nVýsledkem volání je unikátní identifikátor uživatele, který si můžeme dočasně někam uložit, aby ho nebylo potřeba zjišťovat pořád znovu. To není potřeba. Nutné ja však upozornit na to, že přes API získáte taková přístupová práva, jaké by měl uživatel, kdyby se přihlašoval normálně pomocí loginu.\n\nJedeme dál\n==========\nNásleduje služba `object`. Ta má na starost práci s databází z hlediska ORM. Ačkoliv má tato služba pouze dvě pro mě zajímavé funkce, užije se s ní nejvíce srandy a patří asi k té nejdůležitější. Zmiňované funkce jsou `execute(db, uid, obj, method, *args, **kw)` a `exec_workflow(db, uid, obj, signal, *args)`. Právě pomocí `execute` lze například vyhledávat v databázi a to tak, že si nejdříve získáme ID hodnoty pro daný výraz a následně si vytáhneme veškeré informace, které jsou potřeba (pokud jsou potřeba). Příklad pro vyhledávání v zákaznících:\n\n/--code php\n<?php\n//...\n$data = array($database, $uid, $password, \'res.partner\', \'search\', [[\'name\', \'ilike\', \'hledanyvyraz\']]);\n$ids = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme IDčka\n\n$data = array($database, $uid, $password, \'res.partner\', \'read\', $ids, [\'image\', \'display_name\', \'function\', \'email\']);\n$users = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme zákazníky\n\n//ukázka vytváření klienta:\n$data = array($database, $uid, $password, \'res.partner\', \'create\', [\'name\' => \'John Doe\']);\nxmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data);\n\\--\n\nJe tedy zřejmé, že pomocí execute můžeme vyhledávat, číst, ale i vytvářet, nebo mazat záznamy (`create`, `search`, `read`, `write`, `unlink`). Zajímavý je způsob zápisu při hledání (<em>ilike</em>). K dispozici jsou následující operátory: `=`, `!=`, `>`, `>=`, `<`, `<=`, `like`, `ilike`, `in`, `not in`, `child_of`, `parent_left`, `parent_right`. Opět se jedná o \"samosepopisující\" názvy. Nejzajímavější je však právě <em>ilike</em>, který není case sensitive a obaluje dotaz procenty jako je tomu například klasicky v MySQL (`%hledanyvyraz%`). U použíté funkce <em>read</em> lze vyjmenovat jaké sloupce se mají vrátit, nebo se vrátí veškerá data (včetně obrázků v base64).\n\nPokročilé dotazování\n====================\nPodmínky dotazování lze ještě zpřesnit pomocí logických operátorů (`&` - and, default, `|` - or, `!` - not). Podmínky se zapisují klasicky prefixově, takže pokud chceme například vyhledat zákazníka s nenastavenou češtinou z čech a německa, položíme například následující prefixový dotaz:\n\n/--code python\n[(\'name\',\'=\',\'Adam\'),\'!\',(\'language.code\',\'=\',\'cs_CZ\'),\'|\',(\'country_id.code\',\'=\',\'CZ\'),(\'country_id.code\',\'=\',\'DE\')]\n# ekvivalentní k:\n[(\'name\',\'=\',\'Adam\'),(\'language.code\',\'!=\',\'cs_CZ\'),\'|\',(\'country_id.code\',\'=\',\'CZ\'),(\'country_id.code\',\'=\',\'DE\')]\n\\--\n\nTo v jakých modulech (<em>res.partner</em>) se bude vyhledávat právě záleží na tom, co je naintalováno za moduly a je třeba vědět jak jsou interně označeny, což je podle mého nešťastné, ale zde je přehled těch nejčastějších\n\n- Zákazníci: `res.partner`\n- Telefonáty: `crm.phonecall`, obch. příležitosti - `crm.lead`\n- Produkty: `product.template`, kategorie produktů - `product.category`\n- Projekty: `project.project`, úkoly - `project.task`, tagy - `project.category`\n- Faktury: `account.invoice`, smlouvy - `account.analytic.account`\n- Zaměstnanci: `hr.employee`, výdaje - `hr.expense.expense`\n- Znalostní báze: `document.directory`\n- Kalendář: `calendar.event`\n\nJe svělé, že stačilo pár ukázek a s celým ERP lze dělat téměř cokoliv. Tím to však nekončí, protože existují ještě dvě skupiny příkazů. Třetí skupinou je skupina pro obsluhu a generování reportů `report`. Tato skupina mi v současné chvíli nepřijde natolik zajímavá, ale jmenovitě se jedná o funkce `report`, `report_get` a `render_report`. Mnohem zajímavější, ačkoliv možná trošku vyšší dívčí, je skupina pro přímou práci s databází ERP. Jedná se o skupinu `db` a ta ovládá právě instance celého ERP. Tyto funkce nejsou přímo pro zákazníky, ani obsluhu ERP, ale spíše pro administrátory serverů, tzn. je nutné autorizovat se master helem. Databáze lze mazat, vytvářet, přesouvat, zálohovat, migrovat, duplikovat atd. viz následující výčet funkcí: `create`, `drop`, `dump`, `restore`, `rename`, `change_admin_password`, `migrate_databases`, `create_database` a `duplicate_database`. Zejména pak třeba <em>rename</em> se hodí, protože tato operace nejde jinak vykonat. U všech zmíněných funkcí je nutné se ověřit. U následujících informativních to nuté není: `db_exist`, `list`, `list_lang`, `server_version`. Velký pozor na funkci <em>db_exist</em>. Ve skutečnosti totiž kontroluje, jestli se lze k databázi připojit, nikoliv jestli existuje, což nutně nemusí být jedno a to samé...\n\nPokud si chcete o dané problematice přečíst více, doporučuji tuto zastaralou \"dokumentaci\":https://doc.odoo.com/6.1/developer/12_api/. Je dobrá, nikoliv však postačující. Obsahuje však ukázky i pro jiné programovací jazyky, než je PHP. Doufám, že tento článek vyjasnil všechny zákoutí komunikace s API ERP systému Odoo... (-:',	'2014-08-27 20:11:00'),
(82,	'Kdyby\\Console',	'Existují knihovny, bez kterých bych si vývoj webových aplikací již téměř nedokázal představit. Jedním z nich je \"Kdyby\\Console\":https://github.com/kdyby/console. Již dříve jsem sice napsal článek o \"Nette CliRouteru\":http://zlml.cz/nette-2-1-dev-clirouter, ale postupem času a hlavně také díky Doctrine jsem velmi rychle a rád přešel na jiné a dokonalejší řešení. Vzhledem k tomu, že na jednom projektu používám tuto knihovnu velmi hodně a vlastně na ní celý projekt stojí, rád bych alespoň prostřednictvím tohoto článku autorovi poděkoval (\"Filip Procházka\":https://github.com/fprochazka). Zároveň bych tímto počínáním rád postupně smazával věčný problém těchto knihoven, protože většinou z hlediska návštěvníka ani není jasné, na co ta knihovna je...\n\nProč uvažovat o konzoli?\n========================\nPro mě je tato otázka celkem jednoduchá, protože mám projekty, které nejedou jen na sdíleném hostingu, ale jsou to samostatně stojící aplikace. Z toho plyne, že je často zapotřebí vykonávat pomocí CRONu velké množství úkolů. Toto je hlavní část, proč vůbec o konzolovém nástroji uvažuju. Použití je totiž velmi jednoduché a právě samotná Doctrine nabízí prostřednictvím Kdyby\\Console celou řadu klasických příkazů a je škoda je nevyužívat. Stačí spustit z příkazové řádky `php index.php` u aplikace a pokud jsou příkazy zaregistrovány v konfigu, vypíše se jejich seznam včetně nápověd:\n\n/--code\nC:\\xampp\\htdocs\\zeminem.cz\\www>php index.php\nNette Framework version 2.2.3-RC2\n\nUsage:\n  [options] command [arguments]\n\nOptions:\n  --help           -h Display this help message.\n  --quiet          -q Do not output any message.\n  --verbose        -v|vv|vvv Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n  --version        -V Display this application version.\n  --ansi              Force ANSI output.\n  --no-ansi           Disable ANSI output.\n  --no-interaction -n Do not ask any interactive question.\n\nAvailable commands:\n  help                       Displays help for a command\n  list                       Lists commands\nblog\n  blog:install               Install database schema (set-up DB credentials in config.local.neon).\n  blog:update                Update database schema (set-up DB credentials in config.local.neon).\ndbal\n  dbal:import                Import SQL file(s) directly to Database.\norm\n  orm:clear-cache:metadata   Clear all metadata cache of the various cache drivers.\n  orm:clear-cache:query      Clear all query cache of the various cache drivers.\n  orm:clear-cache:result     Clear all result cache of the various cache drivers.\n  orm:convert-mapping        Convert mapping information between supported formats.\n  orm:convert:mapping        Convert mapping information between supported formats.\n  orm:generate-entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate-proxies       Generates proxy classes for entity classes.\n  orm:generate:entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate:proxies       Generates proxy classes for entity classes.\n  orm:info                   Show basic information about all mapped entities\n  orm:schema-tool:create     Processes the schema and either create it directly on EntityManager Storage Connection or generate the SQL output.\n  orm:schema-tool:drop       Drop the complete database schema of EntityManager Storage Connection or generate the corresponding SQL output.\n  orm:schema-tool:update     Executes (or dumps) the SQL needed to update the database schema to match the current mapping metadata.\n  orm:validate-schema        Validate the mapping files.\n\\--\nDíky této možnosti je možné rychle validovat Doctrine entity, nebo generovat SQL schéma přímo do databáze. Použití je opět jednoduché, např.: `php index.php orm:info`.\n\nTvorba vlastního příkazu\n========================\nPrvně je třeba si uvědomit, že tato knihovna je vlastně to samé jako je v \"Symfony Console Component\":http://symfony.com/doc/current/components/console/introduction.html, tzn. že potřebné informace se dají čerpat právě z této dokumentace a navíc existuje celá sada helperů, jako je například \"Progress Bar\":http://symfony.com/doc/current/components/console/helpers/progressbar.html, nebo třeba šikovný \"Table\":http://symfony.com/doc/current/components/console/helpers/table.html. Samotné napsání třídy (Commandu) je pak triviální záležitostí:\n\n/--code php\n<?php\n\nnamespace App\\Console;\n\nuse Doctrine;\nuse Entity;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass BlogInstall extends Command {\n\n	/** @var \\Kdyby\\Doctrine\\EntityManager @inject */\n	public $em;\n\n	protected function configure() {\n		$this->setName(\'blog:install\')->setDescription(\'Install database schema (set-up DB credentials in config.local.neon).\');\n	}\n\n	protected function execute(InputInterface $input, OutputInterface $output) {\n		try {\n        	// Zde vykonáme vše co je potřeba\n			// Zde vykonáme vše co je potřeba\n            // Zde vykonáme vše co je potřeba\n            //...\n			$output->writeLn(\'<info>[OK] - BLOG:INSTALL</info>\');\n			return 0; // zero return code means everything is ok\n		} catch (\\Exception $exc) {\n			$output->writeLn(\'<error>BLOG:INSTALL - \' . $exc->getMessage() . \'</error>\');\n			return 1; // non-zero return code means error\n		}\n	}\n\n}\n\\--\n\nZa povšimnutí stojí fakt, že tyto třídy jsou vedle presenterů dalším kandidátem na použití `@inject` anotace. V tomto příbadě bude tedy k dispozici příkaz `blog:install`, který je však nutné ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	-\n		class: App\\Console\\BlogInstall\n		tags: [kdyby.console.command]\n\\--\n\nTento způsob registrace je jedna z věcí, která mě štve a rád bych, kdyby se toto Console naučila hackovat sama a já nemusel tagovat, že se jedná o command. Když je totiž těchto příkazů hodně, konfigurační soubor tímto způsobem poměrně rychle roste na své délce a stává se nepřehledným... (-:\n\nA co je na tom?\n===============\nVždyť toto umí Symfony. To Kdyby nic jiného neumí? No, tak krom toho, že vůbec řeší integraci do Nette, což je asi hlavní úkol, tak jsou logicky součásti integrace i další části jako jsou například vlastní helpery. Není totiž nic horšího, než když v takovém commandu potřebujete presenter. Ale ono je to vlastně jednoduché:\n\n/--code php\n$presenter = $this->getHelper(\'presenter\')->getPresenter();\n\\--\n\nA stejný problém je pak s odkazy. Jak totiž v CLI pracovat s URL, když žádná není? I to Console řeší. Stačí v configu uvést:\n\n/--code neon\nconsole:\n	url: http://zlml.cz/\n\\--\n\nPak je tvorba odkazů v CLI úplná pohodička:\n\n/--code php\n$link = $presenter->link(\'//:Front:Homepage:default\');\n\\--\n\nPodívejte se na \"reálné ukázky\":https://github.com/mrtnzlml/zlml.cz/tree/6d1ad3de5b1f98067a38d2085e4939cd17cf5db5/app/commands příkazů pro Kdyby\\Console. Za sebe mohu tento nástroj jedině doporučit. Pokud potřebujete se svojí aplikací pracovat z příkazové řádky. Toto je jiná správná cesta. Díky! (-:',	'2014-08-30 16:30:52'),
(83,	'Hledá se obchodník',	'Tentokrát nebudu psát o ničem technickém, ale vezmu to hned od druhé věty vážně. Do \"Orgis IT\":http://www.orgis.cz/ scháníme obchodníka primárně pro Prahu / Plzeň pro rozšíření obchodního teamu. Po dlouhém rozmýšlení máme jasno co požadujeme. Nejedná se o nic zvláštního. Klasicky vyžadujeme samostatnost, pružnost a spolehlivost. To jsou celkem běžné požadavky, takže nemá smysl je zde řešit. Má však smysl řešit obchodní náplň. Jelikož se jedná o IT firmu, byl by vhodný alespoň základní přehled o tom co Orgis IT nabízí. Primárně se teď zaměřujeme na serverová řešení (opravdu velká) a vnitropodnikové ERP systémy o které je největší zájem. Jelikož se jedná o místy dost kompikovanou záležitost na pochopení, obchodník projde odborným zaškolením a i po zaškolení bude obchodník úzce spolupracovat se silnou technickou podporou a s lidmi z technické specifikace.\n\nŽivotopisy zasílejte na <span style=\"font-size:25px\"><a href=\"mailto:hr@orgis.cz\">hr@orgis.cz</a></span>\n\nUvítáme dlouhodobou spolupráci, protože se jedná o velice dynamický obor, kde je potřeba nemalá časová investice jak z naší strany, tak ze strany obchodníka. V případě oboustranné spokojenosti rádi navážeme spolupráci i pro rozvoj na zahraničním trhu. Preferujeme práci především na ŽL, kdy bude výše odměn závislá na obratu. Tato výše není omezena pásmově, ani žádnou horní hranicí.\n\nBtw, stav se pro více informací a zajdeme někam na pivko... (-:\n<br>\n(Plzeň)',	'2014-09-28 18:38:52'),
(84,	'Fígloidní odstranění záhlaví modulu',	'Dnešní článek bude spíše zápisek, protože jsem řešení tohoto problému hledal neskutečně dlouho a jak se později ukázalo, tak řešení je sice jednoduché, ale je zakořeněné hluboko v jádru Odoo ERP systému. O co jde. Občas je potřeba schovat záhlaví (viz obrázek) u některých modulů.\n\n[* ddfc321c-2190-4cf6-98a9-89852713e626/vystrizek.png 500x? <]\n\nTento panel má sice dobrý důvod, ale existují případy, kde je prostě nadbytečný. Typický případ takové nadbytečnosti je modul Dashboards (technický název `board`) kdy je tento prostor nijak nevyužívaný. Zřejmě by tento problém šel řešit nějaký hackem, ale to prostě není dobře. Problém je \"zde\":https://github.com/odoo/odoo/blob/8.0/addons/web/static/src/js/views.js#L905. \"Special case for Dashboards\"...\n\nJak na to\n=========\nAsi úplně nejjasnější bude, když popíšu posloupnost kroků, které vedou ke správnému řešení. Nejedná se o nic kompikovaného. Všechny níže uváděné postupy jsou klasické postupy při vývoji modulu. Jen je (do teď) pravděpodobně nikde nenajdete, nebo nad tím zbytečně vytuhnete na zoufale dlouhou dobu. Ostatně \"podívejte se\":https://searchcode.com/?q=views_switcher%20lang:Javascript, jak je výskyt tohoto kousku užitečného kódu \"používaný\":https://github.com/odoo/odoo/search?l=javascript&q=views_switcher&type=Code&utf8=%E2%9C%93 v public repozitářích... :-)\n\n<span style=\"font-size:2em\">1.</span> Registrace XML definice v `__openerp__.conf`\n\nTato záležitost je asi celkem jasná. Jednoduše musíme definovat, že se má při compile-time brát ohled na XML soubor, ve kterém zaregistrujeme JS soubor viz další bod.\n\n/--code python\n{\n    #...\n    \n    \'data\': [\n        \'views/header.xml\',\n    ],\n    \n    #...\n}\n\\--\n\n<span style=\"font-size:2em\">2.</span> Registrace JS souboru\n\nTo jsem to ale nazval blbě... (-: V předchozím bodě je tedy definovanám soubor v podadresáři `views`, jehož obsah je např. takovýto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data>\n        <template id=\"assets_backend\" name=\"queue assets\" inherit_id=\"web.assets_backend\">\n            <xpath expr=\".\" position=\"inside\">\n                <script type=\"text/javascript\" src=\"/module_name/static/src/js/header.js\"/>\n            </xpath>\n        </template>\n    </data>\n</openerp>\n\\--\n\nTato registrace je naprosto běžná. ERP se k tomu pak staví poměrně chytře, takže když je ERP v `?debug=` módu, tak souboru vrací tak jak jsou, jinak je všechny skládá do jednoho a provádí minimalizaci. V tomto případě je rozdíl signifikantní.\n\n<span style=\"font-size:2em\">3.</span> Javascript definice\n\nJe známá věc, že si toto ERP bez JS ani neuprdne. Na jednu stranu mě to trošku štve, na druhou stranu to nemá vůbec smysl řešit. Dalším krokem proto bude definice na straně JS, která zakáže tomuto konkrétnímu view vykreslení headeru:\n\n/--code javascript\nopenerp.module_name = function (instance) {\n    //var QWeb = instance.web.qweb;\n    if (!instance.module_name) {\n        instance.module_name = {};\n    }\n\n    //zde navíc např. definice pro instance.web.qweb\n\n    instance.web.ViewManagerAction.include({\n        init: function(parent, action) {\n            var flags = action.flags || {};\n            if (action.res_model == \'module_model\' && action.view_mode === \'form\') {\n                _.extend(flags, {\n                    views_switcher : false,\n                    display_title : false,\n                    search_view : false,\n                    pager : false,\n                    sidebar : false,\n                    action_buttons : false\n                });\n            }\n            action.flags = flags\n            this._super(parent, action);\n        },\n    });\n}\n\\--\n\nToto nastavení je vlastně úplně to stejné, jako je v jádru. Jedná se o naprosto korektní a čisté řešení. Bohužel je nutné jej řešit touto myškou, protože toto není funkce, která je (nebo by do budoucna měla být) přímo podporována. Dává to smysl, protože se jedná o skutečně krajní případ.\n\nA na závěr mám pro všechny čtenáře třešničku v podobě easter eggu. Vyzkoušejte si doplnit do URL parametr `?kitten=`, stejně jako se doplňuje například ten parametr pro zapnutí debug režimu... (-: *#yourewelcome*',	'2014-10-15 22:50:13'),
(85,	'Nastavení TIM3 na STM32F207xx',	'Tento článek už mám dlouhou dobu v hlavě, ale nikdy jsem se neodvážil jej sepsat. Má to svůj smysl. Jedná se o poměrně náročnou problematiku, kterou si myslím, že moc lidí nechápe. Rád bych tedy tímto popíchnul čtenáře o zpětnou vazbu a pokud by se ukázalo, že to smysl má, pokračoval bych někam dál do složitějších věcí, protože toto bude ve výsledku směšně jednoduché... (-:\n\n[* f34b6d82-9aaf-4089-afe6-81993d596885/stm32.png 400x? <]\n\nK dispozici mám momentálně dva procesory, ale budu řešit konkrétně `STM32F207xx`. Ten druhý je ze `4xx` řady, ale díky novým Cube knihovnám není v programech žádný rozdíl. Alespoň ne v tom, co bu ukazovat dnes. \"STM32F207\":http://www.st.com/web/catalog/mmc/FM141/SC1169/SS1575/LN9/PF245085 je procesor založený na 32-bit ARM(R) Cortex(R)-M3 od STMicroelecronics. Jedná se o procesor s 120 MHz jádrem, 1024 kB flash pamětí na program a 128 kB SRAM. Celkově se jedná o poměrně výkonnou mršku na které se toho nechá upočítat poměrně hodně a hlavně dokáže ovládat velké množství rozmanitých periferií viz obrázek. Na obrázku je přesně ta samá eval deska s tím samým procesorem, na kterou právě teď koukám. Nejzajímavější bude teď však právě onen procesor, který je uprostřed desky a SMD diody, které nejsou téměř vůbec vidět. Ty jsou umístěny nad Wakeup tlačítkem téměř pod displejem.\n\nA teď konečně o čem budu psát. TIM3 je timer ze skupiny TIM2-5. Jedná se o timer naprosto běžný a obyčejný. Celkem jich je k dispozici 14 ve 4 skupinách podle společných vlastností. Podívat se na ně můžete do \"referenční příručky\":http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf, ale pozor ať se vám z toho nezamotá hlava, je toho tam fak hodně... (-: Ukážeme jak tento timer nastavit tak aby bylo možné blikat diodou jednou za 1000 ms. Navíc k tomu nebudeme využívat výkonu procesoru, ale využijeme přerušení, takže nebudeme procesor vůbec ničím zdržovat. O zrovna čekání procesoru 1000 ms, než bude moci bliknout diodou by byl slušný zabiják výkonu.\n\nNastavení TIMx a diod\n=====================\nJe to jednudché. V souboru `main.c` existuje klasická viod metoda s while smyčkou, která bude na začátku i na konci tohoto programu prázdná:\n\n/--code cpp\n#include \"main.h\"\nint main(void) {\n	HAL_Init();\n    SystemClock_Config();\n	# ...\n	while (1) {\n	}\n}\n\\--\n\nCílem je neudělat žádnou blbost a nechat procesor nejlépe bez toho aby něco musel počítat, což je díky přerušení možné a doporučované. HAL (Hardware abstraction layer) vrstu a systémové hodiny nastavíme co nejdříve. `HAL_Init();` je systémová funkce Cube knihoven, která provede inicializaci HW abstraktní vrstvy. Ve skutečnosti HAL_Init spouští celou řadu dalších initů. `SystemClock_Config();` je již uživatelská metoda, která je umístěna v každém demu v Cube Examples, takže ji sem nebudu přepisovat. Je téměř vždy stejná. Následovat by však měla inicializace diod. Dalo by se to udělat i složitě, ale s využitím BSP (Board support package) je inicializace triviální:\n\n/--code cpp\nBSP_LED_Init(LED1);\n# LED2, LED3, LED4\n\\--\n\nTeď tedy máme nastartovanou desku, hodiny a připravené diody k použití. Nezbývá než se pustit do nastavování timeru:\n\n/--code cpp\n/*##-1- Configure the TIM peripheral #######################################*/\nTimHandle.Instance = TIMx;\nTimHandle.Init.Period = 10000;\nTimHandle.Init.Prescaler = (uint32_t)(((SystemCoreClock / 2) / 10000) - 1); //10kHz\n// T = 1/f = 1/10k = 0,0001 ; time = Period * T = 1s\nTimHandle.Init.ClockDivision = 0;\nTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;\nif(HAL_TIM_OC_Init(&TimHandle) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\n`TIMx` je v `main.h` nastaven na TIM3, period je délka intervalu a prescaler je předdělička frekvence, která je díky tomu výpočtu nastavena nezávisle na rychlosti hodin na jednotnou frekvenci 10 kHz. Teď si stačí jen oprášit středoškolskou elektroniku. Pokud víme, že `T = 1/f` a frekvence je 10 000 Hz, pak je perioda takového průběhu 0,1 ms. To je docela průser, protože je to srašně rychlé. Proto je zde právě ta perioda timeru, kde v podstatě říkáme, že toto má proběhnout 10 000x a pak až cvrnknout timerem. A voilà, máme 1 vteřinu. `TIM_COUNTERMODE_UP` přávě říká, že bude počítat dokud nenarazí na strop a pak timer přeteče. Snad jedině pozor na jednu zradu. TIM3 má prescaler 16 bitový, tzn. lze nastavit maximálně hodnotu 2^16 -1 = 65535! Vzhledem k tomu, že to z výpočtu není přímo vidět, tak se na to můžete snadno nachytat a timer pak poběží jinak než bylo požadováno. Dále si nastavíme kanál, který budeme využívat k blikání diodou, protože teď timer pouze dojede na 10 000 a vyresetuje se:\n\n/--code cpp\n/*##-2- Configure the Output Compare channels #########################################*/\nsConfig.OCMode = TIM_OCMODE_TOGGLE;\nsConfig.Pulse = uhCCR1_Val;\nsConfig.OCPolarity = TIM_OCPOLARITY_LOW;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK) {\n	Error_Handler();\n}\nsConfig.Pulse = uhCCR2_Val;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_2) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\nPřed vstupem do main metody je zapotřebí nastavit si ještě pulse hodnoty:\n\n/--code cpp\n__IO uint32_t uhCCR1_Val = 100;\n__IO uint32_t uhCCR2_Val = 200;\n\\--\n\nAbych to krátce vysvětlil. Tímto jsem si nastavil, že až timer dosáhne hodnoty 100 a 200, tak cvrnkne a to pokaždé do jiného kanálu. Při dosažení maxima (10 000) dojde k přetečení timeru a ten začne počítat znovu. Je jedno jak tyto hodnoty nastavím, ale musí být od sebe 100 ms. Chci totiž zapnout diodu a dned ji vypnout. Toto se bude opakovat každných 1000 ms viz předchozí nastavení timeru. Super, takže teď máme timer co počítá a v určitém okamžiku pošle dva signály. Tak to nahodíme a jedeme... (-:\n\n/--code cpp\n/*##-3- Start signals generation #######################################*/\n/* Start channel 1 in Output compare mode */\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_1) != HAL_OK) {\n	Error_Handler();\n}\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_2) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\nSkvělé na tom je to, že teď už to fakt cvaká a stačí se na to jen pověsit přepínání stavu diod.\n\nKonečně blikáme!\n================\nK tomu, aby bylo možné blikat, musíme se chytit callbacku, který je v HAL připraven. Zde se podíváme, jestli je daný kanál aktivní a pokud ano, znamená to, že můžeme něco udělat. V tomto případě tedy nejdříve zapnu diodu a za 100 ms přijde signál druhým kanálem a já ji mohu opět vypnout. Za 1s se celý proces opakuje. Paráda!\n\n/--code cpp\n/**\n  * @brief  Output Compare callback in non blocking mode \n  * @param  htim : TIM OC handle\n  * @retval None\n  */\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim) {\n	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {\n		BSP_LED_On(LED1);\n  	}\n	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) {\n		BSP_LED_Off(LED1);\n  	}\n}\n\\--\n\nJeště bych měl zmínit metodu `Error_Handler();`, která se zde často opakuje. Je to metoda, která se zavolá, když se něco nepovede a její obsah může být opět prázdná smyčka, aby procesor nezačal dělat nějaké nesmysly:\n\n/--code cpp\n/**\n  * @brief  This function is executed in case of error occurrence.\n  * @param  None\n  * @retval None\n  */\nstatic void Error_Handler(void) {\n	BSP_LED_On(LED4);\n	while(1) {}\n}\n\\--\n\nAsi není úplně hloupé zapnout i nějakou (červenou) diodu, která bude signalizovat error. Rád bych zmínil to, že by bylo možné v main metodě v cyklu spustit `BSP_LED_Toggle(LED4);` a počkat 1 vteřinu. To by bylo funkční, ale jak by se ukázalo časem, tak by tento program mohl sloužit pouze pro blikání diodou, což není moc užitečné. Pokud bych se k tomu dostal, tak si můžeme ukázat jak pracovat s ethernetem a zde se ukáže, že je prázdný while potřeba. Tímto způsobem mi však nic nebrání blikat si diodou a vedle toho ještě tlačit data ethernetem pryč...\n\nTak co, dalo se to vydržet? :-)',	'2014-10-19 00:02:30'),
(86,	'Heatmapy ve Wolfram Mathematica',	'[* 1bb55605-d567-4fe0-b1d1-69e921940e0d/heatmap1.png ?x300 <]\n\nPrávě teď jsem řešil jak vizualizovat nějaká data, která jsou v maticovém formátu. Pro mé účely jsou prakticky dva grafy. Prvním grafem je heatmapa (viz obrázek) a druhým klasický 3D graf, který data reprezentuje stejně dobře (možná lépe), ale v určitých případech je špatně čitelný. Zejména pak když není možnost s grafem otáčet. V mém případě bylo zapotřebí poměrně velké množství grafů, které jsem nakonec minimalizoval na počet 40, takže bylo nemožné je vykreslovat ručně. Zvlášť pokud jsem zajistit, že budou všechny grafy stejné.\n\nK tomu jak jsem postupoval se dostanu v další části. Teď však ještě pár úvodních slov k tomu, co jsem to vlastně měřil. Cílem měření bylo změřit s využitím jasoměrů hodnoty jasů *L [cd/m^2]* určitých objektů a jejich okolí v pravidelné síti kontrolních bodů při různém osvětlení (denní, sdružené a umělé) a různé vzdálenosti a úhlu. Z těchto jasů je zapotřebí spočítat kontrast *C [-]* a tuto kontrastní mapu také vizualizovat. Je tedy zřejmé, že stačí změřit pár objektů a počet grafů rychle roste.\n\nVizualizace dat\n===============\n[* 40a97326-5410-4385-821c-62dc8542387a/3d2.png 300x? >]\nTato část se sice jmenuje vizualizace dat, ale aby bylo co vizualizovat, je zapotřebí data připravit. Já jsem zvolil JSON formát vstupu, protože se velmi jednoduše parsuje a matici v něm mohu zapsat také jednoduše. Z měření jednoho objektu mi tedy stačí data v tomto formátu:\n\n/--code javascript\n{\n	\"Tabule - umělé osvětlení\": {\n		\"up\": \"STROP\",\n		\"down\": \"PODLAHA\",\n		\"left\": \"OKNA\",\n		\"right\": \"DVEŘE\",\n		\"values\": [\n			[121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7],\n			[96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5],\n			[82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5],\n			[63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5],\n			[62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5]\n		]\n	}\n}\n\\--\n\nTakových dat je již možné se chytit a vykreslit celou řadu průběhů. Samotný parser se však postupem času poměrně zkomplikoval. Prohlédnout si ho však můžete \"na GitHub Gistu\":https://gist.github.com/mrtnzlml/9ec02541555e419a8df9#file-parser7-php a to včetně kompletního vstupu a výsledného výstupu pro Wolfram Mathematica. Tento výstup je v zásadě jednoduchý. Například graf, který je v úvodu vykreslíme pomocí následujícího výstřižku:\n\n/--code php\nShow[MatrixPlot[{\n	{-0.063, -0.753, -0.706, -0.788, -0.443, 0.311, 0.327},\n	{0.619, 0.613, 0.671, -0.013, -0.162, 0.295, 0.344},\n	{0.297, 0.441, 0.351, 0.178, 0.087, 0.166, 0.339},\n	{-0.085, 0.27, 0.225, 0.155, 0.118, 0.163, 0.317},\n	{-0.033, 0.017, -0.015, 0.03, 0.019, 0.077, 0.198}\n}, PlotTheme -> \"Detailed\", Mesh -> Automatic, MeshStyle -> Directive[GrayLevel[0], Opacity[0.5], Dashing[{0, Small}]]],\nFrameLabel -> {{HoldForm[OKNA], HoldForm[DVEŘE]}, {HoldForm[PODLAHA], HoldForm[STROP]}},\nPlotLabel -> RawBoxes[\"Tabule - umělé osvětlení, zezadu (kontrast, Lp = 59.7)\"], LabelStyle -> {GrayLevel[0]}]\n\\--\n\n[* 79b1a8e3-1efc-42b0-bb79-3409b9acd49d/3d.png <]\n\nKromě nastavování popisek a záhlaví, tak je důležitý hlavně blok kde jsou data. V tomto grafu není žádná zrada. Malá zrada číhá až v 3D grafech. Zde je háček v tom, že občas relativně malá plocha grafu ustřelí mimo průměrnou hodnotu všech bodů a na grafu dojde k oříznutí. Aby se tomuto efektu předešlo, je bezpodmínečně nutné nastavit grafu `PlotRange -> All`. Tím se vykreslí celý graf nezávisle na tom, jaké obsahuje extrémní hodnoty. Je však otázka jestli je to žádoucí. V mém případě ano, ale umím si přestavit případy, kdy by velká špička totálně zničila celý graf a bylo by výhodnější spičku oříznout.\n\n/--code php\nListPlot3D[{\n	{62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5},\n	{63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5},\n	{82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5},\n	{96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5},\n	{121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7}\n}, ColorFunction -> \"DarkRainbow\", PlotRange -> All, PlotTheme -> \"Business\"]\n\\--\n\nPro vykreslení horního pohledu stačí přidat další atribut `ViewPoint -> Above`, čímž získáme teplotní mapu v trošku jiném zobrazení a díky Business tématu budou na grafu vidět i vrstevnice, což ulehčí představu o tom jak je graf tvarově rozložen. <span style=\"color:green\">Také pozor na to, že do funkcí `MatrixPlot` a `ListPlot3D` se zadávají matice v obráceném pořadí z hlediska řádek matice! Dojde tak ke vykreslení stejných map.</span>',	'2014-10-25 15:31:33'),
(87,	'Dependent select box',	'Občas je v Nette zapotřebí vyřešit dependent select box. Je to relativně málo častý požadavek a o to méně se o něm dá najít, když je to zrovna potřeba. V zásadě existují dvě řešení. Nudné - poctivé a pak zábavné - špinavé. Podívejme se na to, jak se dá takový dependent select box jednoduše vyřešit.\n\nČisté řešení\n============\n[* 51d212f2-5aa9-44b9-9085-f6267e1974e9/vystrizek.png >]\nToto řešení ukazuje jak by se takový problém měl zhruba řešit. Myšlenka je velmi jednoduchá. Prvně potřebujeme data do závislého select boxu. Ty se normálně vyřeší prostřednistvím databáze, v našem případě postačí jednoduché pole.\n\n/--code php\nprivate $database = [\n    [1 => \'2\', \'4\', \'9\'],\n    [4 => \'.\', \'∴\', \'…\'],\n    [5 => \'π\', \'€\', \'©\'],\n];\n\\--\n\nNásledně je potřeba vytvořit samotný formulář:\n\n/--code php\nprotected function createComponentForm($name) {\n    $form = new UI\\Form;\n    $this[$name] = $form; // <- Zde je celý fígl\n    \n    $form->addSelect(\'one\', \'One\', [\'Čísla\', \'Tečky\', \'Symboly\'])->setDefaultValue(1);\n    //dump($form[\'one\']->value);\n    \n    $form->addSelect(\'two\', \'Two\', $this->database[$form[\'one\']->value]);\n    \n    $form->addSubmit(\'send\', \'Odeslat\');\n    $form->onSuccess[] = $this->success;\n    return $form;\n}\n\\--\n\nA k formuláři také šablonu:\n\n/--code html\n{form form}\n    {input one, size => 3}\n    {snippet two}\n    	{input two, size => 3}\n    {/snippet}\n    {input send}\n{/form}\n\\--\n\nAby šlo použít snippet uvnitř formulářového makra, budeme muset udělat malý workaround:\n\n/--code php\npublic function beforeRender() {\n	parent::beforeRender();\n	$this->template->_form = $this[\'form\']; // form {snippet} workaround\n}\n\\--\n\nSnippet je však možné zatím úplně vynechat, protože bude potřeba až při ajaxifikaci.\n\nCelý fígl je v tom, že musíme zajistit, aby se hodnota druhého select boxu nastavovala podle hodnoty prvního. V tomto stavu je již možné formulář spustit. Po vybrání v prvním select boxu a odeslání formuláře se vybraná hodnota následně projeví v druhém select boxu. Celé kouzlo je pouze v té druhé řádce formulářové továrničky, který mi umožní přistoupit k hodnotám prvků. Je samozřejmě nesmysl odesílat celý formulář pro získání obsahu druhého select boxu, proto si napíšeme krátký javascriptový kód, který to za nás vyřeší (nette.ajax.js):\n\n/--code javascript\n$(function(){\n	$.nette.init();\n    \n	$(\'select[name=one]\').change(function () {\n		$.nette.ajax({\n			url: {link invalidate!},\n			data: {\n				\'value\': $(\'select[name=one]\').val(),\n			}\n		});\n	});\n});\n\\--\n\nJakmile se změní hodnota prvního select boxu, zavoláme si handler a předáme mu novou hodnotu. Tento handler bude mít za úkol nastavit hodnoty druhého select boxu a pouze tento prvek invalidovat:\n\n/--code php\npublic function handleInvalidate($value) {\n	$this[\'form\'][\'two\']->setItems($this->database[$value]);\n	$this->redrawControl(\'two\');\n}\n\\--\n\nTím je vlastně hotovo. Čistotu řešení ověříme tím, že si vyzkoušíme dump vybraných položek po odeslání formuláře:\n\n/--code php\npublic function success(UI\\Form $form, $vals) {\n	dump($vals);\n}\n\\--\n\nČistota spočívá v tom, že požadované hodnoty skutečně získáme. To není úplně samozřejmé, protože v Nette existuje bezpečnostní obranný mechanismus, který zabraňuje odeslání hodnot v select boxu, které na začátku neobsahoval. Pokud něco takového uděláme třeba javascriptem, zíkáme `NULL`. Aby se toto nedělo, musíme takto relativně složitě vyřešit továrničku pro formulář.\n\nŠpinavé řešení\n==============\nŠpinavé řešení se od toho čisté o moc neliší. Myšlenka je pořád stejná, tentokrát však stojíme před jiným úkolem. Vezměme si příklad, kdy nám zase až tolik nezáleží na tom, jaké získáme v select boxu hodnoty a chceme ho používat spíše jako text input, kdy nabídneme uživateli nějaký vstup. Typický příklad je text input pro URL adresu API, kdy po zadání kontaktujeme nějaké API a nabídneme v selectu vrácené hodnoty tak, aby je uživatel nemusel psát. Netvrdím, že by to nešlo vyřešit čistě, ale špinavé řešení je v tomto případě pohodlnější, rychlejší a mohu na něm ukázat i něco jiného. Tentokrát si vytvoříme úplně obyčejný formulář, tak jako již mnohokrát. Není potřeba žádného fíglu. Opět si připravíme šablonu pro formulář obdobně jako v předchozím případě. A obdobně doplníme nějaký ten javascript. Zde bych klidně mohl formulář upravit javascriptově, ale mě se hodí zavolat si (po napsání URL adresy) handler, v něm vyřešit vše potřebné a invalidovat část formuláře.\n\n/--code javascript\nvar timer = null;\n$(\'input[name=url]\').live(\'keyup\', function () {\n	if (timer) {\n		clearTimeout(timer);\n	}\n	timer = setTimeout(function () {\n		timer = null;\n		$.nette.ajax({\n			url: {link checkErp!},\n			type: \'POST\',\n			data: {\n				\"erpForm-url\": $(\'input[name=url]\').val()\n			}\n		});\n	}, 250);\n});\n\\--\n\nHandler nemá smysl uvádět. Jednoduše v něm vykonám nějakou logiku, vrátím data a invaliduji šablonu. Pozor na to, že předchozí javascriptová ukázka je tentokrát ze separátní komponenty.\n\nZbývá nám vyřešit pouze odeslání a zpracování formuláře. Jelikož jsem byl teď líný programátor a select v tomto případě beru spíše jako text input, nemohu získat hodnotu select boxu ve `$form->getValues()`, resp. v druhém parametru succeeded metody. Musím proto použít metodu `getHttpData`, která mi umožní získat jakákoliv data a zároveň mám jistotu, že jsou data ošetřena:\n\n/--code php\npublic function erpFormSucceeded(UI\\Form $form, Nette\\Utils\\ArrayHash $values) {\n	try {\n		$this->erpSystems->create([\n			ErpSystems::COLUMN_URL => $values->url,\n			ErpSystems::COLUMN_DATABASE => $form->getHttpData(UI\\Form::DATA_LINE, \'database\'), // <- náš select\n			ErpSystems::COLUMN_USER => $values->username,\n			ErpSystems::COLUMN_TOKEN => $values->password,\n		]);\n		//...\n	} catch (\\PDOException $exc) {\n		//...\n	}\n	//...\n}\n\\--\n\nV tomto špinavém řešení je však zapotřebí myslet na to, že v selectu může přijít naprosto cokoliv. To by však nikoho nemělo převapit. Ostatně i při vytváření formuláře stačí vytvořit select box prázdný, protože žádná vstupní data ani neexistují.',	'2014-11-01 20:09:57'),
(88,	'Nadvláda inteligentních procesorů',	'Pár dní zpátky jsem tweetoval o tom, nad čím právě teď trávím asi nejvíce času. Cílem celého mého snažení je dostat data z procesoru, který obsluhuje různé periferie na základní desce až do webového prohlížeče a zpět - vše v reálném čase. Právě dnes jsem dosáhl prvního milníku, tedy dostal jsem nějaká skutečně smysluplná data do prohlížeče a rád bych zde nastínil jak jsem postupoval a jaké technologie jsem volil. Již dříve se totiž ukázalo, že některé reakce na mé články jsou skutečně konstruktivní a tedy i velmi přínosné... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Procesor ➡Ethernet ➡NodeJS ➡Redis ➡ExpressJS ➡Socket.IO ➡Browser ✅ <a href=\"http://t.co/MAIlmMZEL9\">pic.twitter.com/MAIlmMZEL9</a></p>&mdash; Martin Zlámal (@mrtnzlml) <a href=\"https://twitter.com/mrtnzlml/status/531104236571230208\">November 8, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNěkolik slepých uliček\n======================\nPůvodně byl celý nápad úplně jiný a rozhodně ne real-time. A stejně jako je teď velký trend stavět vše pomocí *Raspberry Pi* nebo pomocí *Arduino*, tak i já jsem tak chtěl učinit. Důvod je jednoduchý. Napsat se s pomocí těchto desek dá všelicos velmi rychle a nestojí to moc námahy. Navíc jsem chtěl více času věnovat webové aplikaci, než nějakému mikročipu. Postupem času a po několika vážných rozhovorech jsem začal přemýšlet nad real-time přenosem informace v obou směrech. Takže bylo zapotřebí najít vhodnou desku. Jenže na real-time už jsem si jen s *Raspberry* nevěřil a proto jsem hledal nějakou lepší desku na kterou bych nahodil nějaký velmi lehký Linux a NodeJS. Po dalších vážných rozhovorech jsem však i z této cesty ustoupil a zvolil jsem něco, co jsem ze začátku vůbec neuvažoval. Chtěl jsem zvolit desky od ST z řady \"Nucleo\":www.st.com/stm32nucleo, ale tyto desky nemají ethernet a tak bylo lehčí vypůjčit si \"eval-boardy\":www.st.com/stm3220g-eval. Tyto desky mají stejné procesory, ale více periferií okamžitě k dispozici. Jenže to znamená, že musím opustit všechno hraní si a hluboce se ponořit do **C**čka...\n\nSprávná ulička?\n===============\nDesky a procesory jsou tedy jasné. Co dál? Nezbývá než stanovit, jak se bude informace přenášet až do prohlížeče. Zde je zřejmě jasná věc to, že mezi procesorem a prohlížečem musí být nějaký mezičlen. Ten u mě tvoří \"NodeJS\":http://nodejs.org/ server v kombinaci s \"Redis\":http://redis.io/ databází zhruba tak, jak je znázorněno na \"ASCII artu\":http://cs.wikipedia.org/wiki/ASCII_art níže:\n\n/--code\n------------      ----------      -----------\n| Procesor | ---> | NodeJS | ---> | Browser |\n------------      ----------      -----------\n        |             ^\n        |             |\n        |         ---------\n        --------> | Redis |\n                  ---------\n\\--\n\nJak celý přenos v současné chvíli probíhá? Procesor je teď aktivním prvkem, tzn. sbírá nějaká potřebná data (např. pomocí ADC snímá polohu natočení potenciometru) a pomocí UDP datagramů je odesílá na jasně danou IP adresu NodeJS serveru, kde se informace z datagramu uloží do dané struktury v Redis databázi. Tyto datagramy se skládají z klasické UDP hlavičky a datové části. Ta je v \"RESP\":http://redis.io/topics/protocol formátu, takže teoreticky bude někdy později možné NodeJS server úplně přeskočit a data ukládat přímo z procesoru do databáze jak je na diagramu naznačeno. Server však nikdy nepůjde úplně odstranit, protože na NodeJS serveru běží v této chvíli UDP server, ale také tam běží webový server (\"ExpressJS\":http://expressjs.com/), který mi umožňuje rovnou vytvořit webovou stránku a s pomocí \"Socket.IO\":http://socket.io/ si mohu otevřít websocket a z databáze opět informace odesílat bleskovou rychlostí do prohlížeče, kde je mohu javascriptem nějak dále zpracovat.\n\nK čemu to celé je?\n==================\nNevím. (-: Tento článek jsem napsal proto, abych si utřídil myšlenky a získal zpětnou vazbu. Celý projekt měl však původně být pro tzv. inteligentní domy, kdy by stačilo dům pouze zasíťovat a vše ostatní by již bylo vlastně hotovo (přes ethernet lze i napájet). Výhodné je to v tom, že můžete kdykoliv jakýkoliv prvek domácnosti odpojit, dát ho na jiné místo (v rámci IP rozsahu) a vše by stále fungovalo. Jenže jak často přesouváte vypínače (termostaty, světla, senzory)? Proto se chci spíše zaměřit na objekty kde se tyto věci často řeší, proto vidím správný směr spíše v (relativně) často se měnících kancelářských budovách, nebo tam kde je potřeba například rychle připojit nějaké senzory a sledovat je online. Každopádně věřím, že díky svým možnostem tento systém natrhne zadek i současným systémům pro ovládání \"inteligentních\" domů využívajících PLC-like systémy.\n\nBudoucnost je zatím celkem jasná. Teď chci naučit systém komunikovat i v opačném směru a následně jej budu pilovat, čímž završím první etapu práce. Cest pro rozšiřování je však ještě spoustu. Jednak chci systém naučit komunikovat bezdrátově, pak také IPv6, šifrovanou komunikaci a v neposlední řadě chci vyrobit nějaké senzory a akční členy pro reálné použití a zprovoznit funkční ukázku pro prezentování celé této srandy.\n\nTak co, máte dostatek odvahy šoupnout si takový systém do baráku? Upozorňuji, že to není žádná Arduino-like stavebnice, takže to je spolehlivé... (-:',	'2014-11-17 23:44:14'),
(89,	'Přednáška na ZČU - Node.js',	'Jak jsem slíbil, tak zveřejňuji přenášku na téma **Node.js**, kterou jsem měl dnes na Západočeské univerzitě pro lidi studující předmět **KIV/WEB**, tedy Webové aplikace. Tato přednáška volně navazuje na předchozí obsah tohoto předmětu. Studenti se pozvolna seznamují s webovým prostředím od úplně základní práce s HTML a CSS až k pokročilým webovým frameworkům. Podívejte se na záznam této přednášky:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/eakg5THIbcI\" frameborder=\"0\" allowfullscreen></iframe>\n\nA prohlédněte si také připravenou prezentaci:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42314371\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nRád bych také poděkoval \"Honzovi *chemix* Černému\":http://honzacerny.com/ za zapůjčení kamery.\n\nA příště? Příště se podíváme na skvělý PHP framework \"Nette\":http://nette.org/! Tak doufám, že opět dorazíte... (-:',	'2014-12-03 20:55:04'),
(90,	'Poslední přednáška na FAV - Nette',	'Tak a je to... (-:\n\nZveřejňuji mojí poslední přednášku v tomto roce, kterou jsem měl na ZČU na fakultě aplikovaných věd pro studenty předmětu KIV/WEB. Tentokrát jsem si pohrál trošku se zvukem, takže by to oproti \"minulému týdnu\":http://zlml.cz/prednaska-na-zcu-node-js mělo být o mnoho lepší.\n\nTématem této přednášky byl můj oblíbený Nette Framework, konkrétně ve verzi 2.3-dev. Cílem bylo seznámit studenty se základní myšlenkou MVC/P a rychle nastínit o co vlastně v Nette jde a  jak se v něm staví jednoduché aplikace. Přednáška nakonec utekla rychleji než jsem čekal a nemohl jsem ukázat vše, proto jsem připravil repozitář na \"GitHubu\":https://github.com/mrtnzlml/kivweb-nette-fcbk ze kterého by mělo být vše jasné (pokud není, můžete se ještě dodatečně ptát).\n\nKonec písmenek, podívejte se sami:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/GdATlrmoPRM\" frameborder=\"0\" allowfullscreen></iframe>\n\nA samozřejmě nesmí chybět samotná prezentace:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42574181\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nOpět také děkuji \"Honzovi *chemix* Černému\":http://honzacerny.com/ za zapůjčení kamery.',	'2014-12-10 20:53:10'),
(91,	'RESP protokol - přímý přístup k Redis databázi',	'\"**RESP**\":http://redis.io/topics/protocol (**RE**dis **S**erialization **P**rotocol) je něco, s čím se asi většina lidí nepotká. Důvod je prostý. Tento protokol je většinou zabalen hluboko v knihovně, která pracuje s Redis databází. Existují však situace, kdy se tento protokol hodí. Jednou ze situací je stav, kdy potřebujete předat, nebo naopak získat z Redisu nějaká data a všechno ostatní vyjma RESP komunikace je zbytečné zdržování (u mě třeba sypání dat z procesoru přímo do Redisu). Druhý případ nastane v okamžiku, kdy potřebujete zajistit komunikaci klient-server a potřebujete zvolit vhodný formát přenosu informací. Jedná se tedy o použití tohoto protokolu úplně mimo Redis. Důvodů může být celá řada, nejhlavnější by však byl asi ten, že se s RESP formátem dat dá snadno pracovat, protože používá prefixový zápis.\n\nFormát RESP protokolu\n=====================\nRESP používá celkem 5 způsobů jak zaobalit přenášenou informaci. Vždy však platí, že první byte je byte určující o jaký formát se jedná:\n\n- `+` jednoduchý string\n- `-` error\n- `:` integer\n- `$` bulk string (binary safe)\n- `*` array\n\nNásleduje samotný obsah, nebo dodatečné informace, například o délce a vše je ukončeno pomocí CRLF (`\\r\\n`). Postupně tedy přenášené informace moho vypadat například takto:\n\n- `+PONG\\r\\n`\n- `-Error 123\\r\\n`\n- `:54986\\r\\n`\n- `$4\\r\\nPING\\r\\n` (první část určuje délku bulk stringu, NULL je pak `$-1\\r\\n`)\n- `*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n` (první je délka pole, následuje kombinace předchozích)\n\nTo je celé, žádná věda v tom není. Je to skutečně jednoduchý protokol a to je super, protože se s ním dá snadno pracovat. Navíc lze poslat celý dlouhý text obsahující více příkazů v jednom spojení.\n\nImplementace v Node.js\n======================\nV Node.js by teď měla být realizace velmi jednoduchá. Napíšeme si krátký TCP client, který se nám napojí na Redis databázi (většinou port 6379) a budeme posílat/přijímat data:\n\n/--code javascript\nvar net = require(\'net\');\n\nvar client = net.connect({port: 6379}, function() {\n	console.log(\'Connected to the Redis server.\');\n\n	client.write(\'*1\\r\\n$4\\r\\nPING\\r\\n\');\n	client.write(\'*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nxxxxx\\r\\n\');\n	client.write(\'*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n\');\n	client.write(\'*5\\r\\n$5\\r\\nPFADD\\r\\n$11\\r\\nHyperLogLog\\r\\n$3\\r\\nxxx\\r\\n$3\\r\\nyyy\\r\\n$3\\r\\nzzz\\r\\n\');\n	client.write(\'*2\\r\\n$7\\r\\nPFCOUNT\\r\\n$11\\r\\nHyperLogLog\\r\\n\');\n\n	client.write(\'*1\\r\\n$7\\r\\nFLUSHDB\\r\\n\');\n});\n\nclient.on(\'data\', function(data) {\n	console.log(data.toString());\n	client.end();\n});\n\nclient.on(\'end\', function() {\n	console.log(\'Disconnected from the Redis server.\');\n});\n\\--\n\n<span style=\"color:green\">Ještě jednu poznámku, kterou jsem do původního článku nezahrnul. Proč jsou udesílaná data zabalena v RESP poli? Vychází to z toho, že podle dokumentace, by klient měl posílat na server pole bulk stringů. Nicméně dobře funkční a validní zápis je i bez pole (`client.write(\'GET key\\r\\n\');`) jen musí být opět ukončen pomocí CRLF.</span>\n\nOdesíláme do Redis databáze celkem 6 příkazů. První je obyčejný `PING`, následuje `SET` a `GET` klíče, `PFADD` a `PFCOUNT` z HyperLogLog datového dypu a nakonec jen smazání databáze. Co bude výstupem?\n\n/--code\n+PONG\n+OK\n$5\nxxxxx\n:0\n:3\n+OK\n\\--\n\nJak je možné, že server vrátil 7 odpovědí? Je to prosté, upravíme si datový callback ať je zřejmé, co skutečně dostáváme za data:\n\n/--code javascript\nclient.on(\'data\', function(data) {\n	console.log(JSON.stringify(data.toString()));\n	client.end();\n});\n\\--\n\nTeď už bude výstup o něco jiný:\n\n/--code\n\"+PONG\\r\\n+OK\\r\\n$5\\r\\nxxxxx\\r\\n:0\\r\\n:3\\r\\n+OK\\r\\n\"\n\\--\n\nA vše již dává smysl. První odpověď je `PONG` (na `PING`), následuje reakce `OK` na nastavení klíče, odpověď ve formě bulk stringu, který má dvě části - délku a samotnou textovou odpověď (proto to odřádkování navíc), následuje odpověď z `PFADD` (0 nebo 1 podle situace) a také odpověď z `PFCOUNT` (mohutnost množiny v HyperLogLog). Poslední `OK` je reakce na `FLUSHDB`. Jak je vidět, tak i v odpovědi je prvním znakem formát dat dané odpovědi.\n\nTakto jsem to celkem zbytečně (ale pro přehlednost) rozepisoval. Celá komunikace směrem k serveru by se dala napsat do jednoho požadavku:\n\n/--code\n*1\\r\\n$4\\r\\nPING\\r\\n*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nxxxxx\\r\\n*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n*5\\r\\n$5\\r\\nPFADD\\r\\n$11\\r\\nHyperLogLog\\r\\n$3\\r\\nxxx\\r\\n$3\\r\\nyyy\\r\\n$3\\r\\nzzz\\r\\n*2\\r\\n$7\\r\\nPFCOUNT\\r\\n$11\\r\\nHyperLogLog\\r\\n*1\\r\\n$7\\r\\nFLUSHDB\\r\\n\n\\--\n\nOdpověď by zůstala stejná.',	'2014-12-23 23:53:54'),
(92,	'Dva příklady toho, proč není JS připravený',	'Tento článek nastartoval jeden hloupý tweet. Měl jsem jej na \"to do\" listu již nějaký čas, ale čekal jsem až to někdo tweetne... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/MartinSadovy\">@MartinSadovy</a> Možná ale to není podstatné. Podstatné je, že JS běží v prohlížeči i na serveru. Isomorphism ftw. PHP je evoluční mrtvola.</p>&mdash; Daniel Steigerwald (@steida) <a href=\"https://twitter.com/steida/status/551431843560824832\">January 3, 2015</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNebudu řešit jak je hloupý. Neznám totiž žádnou objektivní stupnici kam bych jej mohl zařadit. Pomůže mi však oprášit pár věcí, které mě štvou a třeba se ukáže, že to dělám úplně špatně. Poslední dobou totiž kopu za \"Node.js\":http://nodejs.org/ (potažmo \"Express.js\":http://expressjs.com/), C i \"Nette\":http://nette.org/ tábor. Vše v jednom projektu. Nicméně jsem odkojen na Nette a tak některé věci řeším v jiném frameworku téměř až se slzou v oku.\n\nRád bych upozornil na to, že nejsem žádný superprogramátor, takže je skutečně možné, že k problému přistupuji špatně. Proto bych byl rád za rozumné podněty a připomínky, nikoliv osobní výstřednosti v komentářích...\n\n1. Odkazy\n=========\nA hned pěkně z ostra. Jak jsem již zmínil, jsem odkojen na Nette a proto jsem náležitě rozmazlen. Ale rozmazlen v dobrém slova smyslu. Považuji totiž framework za věc, která mi má pomoci. Nikoliv házet klacky pod nohy. Jednou z takových věcí je tvorba odkazů. Jak by to mělo být správně? Přesně tak jak je to v Nette, čili je zapotřebí najký systém, který mi umožní stavět odkazy a zároveň mi umožní je kdykoliv změnit bez zásahu do šablon. Jak je tomu v takovém Exresss.js, webovém frameworku pro Node.js? V Express.js je defaultně šablonovací systém \"Jade\":http://jade-lang.com/. Nemluvě o tom, jaký je to nešťastný systém, odkazy se v něm vytvářejí zhruba takto:\n\n/--code html\na(href=\'/\') Home\na(href=\'/about\') About\n\\--\n\nUž asi tušíte kam mířím a proč je to podle mého soudu fatální. Takový hard-code odkazů je totiž perfektně pomalá cesta do blázince. Ve skutečnosti je však mnohem větší anekdota označování aktivních odkazů. Podívejte se na \"6 WTF rad\":http://stackoverflow.com/questions/10713923/node-js-jade-express-how-can-i-create-a-navigation-that-will-set-class-acti, jak tento triviální problém vyřešit. Celý princip spočívá v tom použít hard-code odkazů na více místech v šabloně:\n\n/--code html\nul.nav.navbar-nav\n	li(class=path == \'/\' ? \'active\' : undefined)\n		a(href=\'/\') Home\n	li(class=path == \'/about\' ? \'active\' : undefined)\n		a(href=\'/about\') About\n\\--\n\nKde se bere `path`? Ten si musíte předat v routeru, např.:\n\n/--code js\nrouter.get(\'/\', function (req, res) {\n	res.render(\'homepage\', {\n		path: \'/\'\n	});\n});\n\\--\n\nTak to máme celkem 4 místa kde je to pěkně natvrďáka. Proč ne? **Proč jo?** Jistě, existuje možnost jak si to naprogramovat lépe, jinak, znova. Jen si říkám, kde se stala chyba a proč to framework nezvládá nějak lépe?\n\n2. Formuláře\n============\nJedna z věcí, která se v tomto světě řeší poněkud laxně jsou formuláře. Na to nejsem zvyklý a trošku mě to děsí. Funguje to zhruba tak, že vytvoříte v šabloně formulář:\n\n/--code html\nform(id=\'save-form\', method=\'POST\', action=\'/save\')\n	.form-group\n		label(for=\'xxx\') XXX\n		input(type=\'text\', name=\'xxx\', class=\'form-control\', id=\'xxx\', placeholder=\'xxx\', required)\n	.form-group\n		button.btn.btn-default Odeslat\n\\--\n\nA následně se napíše router pro zpracování dat:\n\n/--code js\nrouter.post(\'/save\', function (req, res) {\n	console.log(req.body.xxx); // <<< !\n	res.render(\'save\', {\n		path: \'/save\'\n	});\n});\n\\--\n\nJistě, je to jednoduché. Ale to prostě \"není ok\":http://stackoverflow.com/questions/19030220/is-it-ok-to-work-directly-on-the-data-in-req-body. Kromě toho, že je v kódu opět hard-code, tak se jedná o nádherně \"ošetřený\" vstup. Takový krásně čistý `$_POST`. Takto si framework nepředstauji. Možná je to proto, že je Express.js ještě moc low-level, možná také proto, že ještě neuzrál.\n\nNení to tak zlé\n===============\nMusím však utlumit některé pobouřené čtenáře. Nebylo by totiž fér jen něco hejtovat. Bez Node.js bych danou aplikaci naprogramoval jen velmi těžko. Je totiž super, že mohu využít \"event-driven, non-blocking I/O model\". Toto je však věc, kterou podle mého názoru moc lidí nevyužije, protože jí prostě nepotřebuje. Kolikrát něco takového programujete? Proto když jsem měl na téma Node.js \"přednášku\":http://zlml.cz/prednaska-na-zcu-node-js, jen velmi těžko jsem lidem vysvětloval k čemu je to vlastně dobré. A právě proto jsem použití Node.js paradoxně neukazoval na webové aplikaci. Třeba proto, že se s ním nepracuje úplně nejlépe, zároveň je však v určitých směrech nenahraditelný.\n\nAčkoliv jsem tedy začínal jedním hloupým tweetem, není toto rekace na něj a je mi celkem hluboce ukradený. Spíše mě zajímá jestli to co jsem zde popisoval (a celá řada dalších problémů) je normální všední den server-side JS programátora, nebo se s těmito problémy vypořádáváte jinak?\n\nEvoluční mrtvola FTW!',	'2015-01-03 23:43:09'),
(93,	'Generované továrničky - definitive guide',	'No dobře, možná ne úplně definitivní, ale užitečná příručka snad. Pokusím se zde rozebrat všechny potřebné stavy generovaných továrniček, které považuji za důležité a jejich co nejjednodušší zápis v configu. Jedná se hlavně o pohled z hlediska předávání parametrů. Doufám, že to ještě někdo doplní o nějaké vylepšení, nebo další příklad, abych mohl tento seznam rozšířit. To je jeden ze dvou důvodů tohoto typu článků. Ten druhý je, abych měl kam odkazovat, až se mě někdo bude opět ptát.\n\nCelkem rozebírám tyto jednotlivé případy:\n- \"Předání parametru z presenteru\":#toc-predani-parametru-z-presenteru\n- \"Předání parametru z konfiguračního souboru\":#toc-predani-parametru-z-konfiguracniho-souboru\n  - Metodou \"create\"\n  - Metodou \"arguments\"\n- \"All in One\":#toc-all-in-one\n\nPředání parametru z presenteru\n==============================\nToto považuji za asi úplně nejčastější požadavek. Komponenta je jednoduchá:\n\n/--code php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n	public function __construct(array $xxx) {}\n}\n\ninterface IParameterComponentFactory {\n\n	/** @return ParameterComponent */\n	function create(array $xxx);\n\n}\n\\--\n\nDůležité je, že jak datový typ, tak název proměnné se musí shodovat. Config pak není o nic složitější:\n\n/--code neon\nservices:\n	- IParameterComponentFactory\n\\--\n\nKontejner se potom vygeneruje dle očekávání:\n\n/--code php\nfinal class Container_59ca411ae5_IParameterComponentFactoryImpl_28_IParameterComponentFactory implements IParameterComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create(array $xxx) {\n		$service = new ParameterComponent($xxx);\n		return $service;\n	}\n\n}\n\\--\n\nSamotné použití je velmi jednoduché. Stačí si nechat v presenteru předat interface `IParameterComponentFactory` například pomocí anotace `@inject` a nad ním volat metodu `create`. Fígl je právě v tom, že vygenerovaný kód v kontejneru tento interface implementuje a odvádí tak zbytečnou práci za vás. Bez dalších změn lze využít autowire zaregistrovaných služeb. Předání parametru z configu a zároveň získání další závislosti pak může vypadat třeba takto (pouze upravená předchozí komponenta):\n\n/--code php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n	public function __construct(array $xxx, App\\Model\\UserManager $userManager) {}\n}\n\\--\n\nPředání parametru z konfiguračního souboru\n==========================================\nToto je trošku horší, ale pořád snadno pochopitelné. Kód komponenty bude opět podobný:\n\n/--code php\n<?php\n\nclass ConfigComponent extends Nette\\Application\\UI\\Control {\n	public function __construct($configParam) {}\n}\n\ninterface IConfigComponentFactory {\n	function create();\n}\n\\--\n\nVšimněte si, že je v tomto případě úplně zbytečná `@return` anotace. Co má factory vytvářet lze totiž specifikovat v configu:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n\nservices:\n	- implement: IConfigComponentFactory\n	  create: ConfigComponent(%testkey1%)\n\\--\n\nZde by skoro šlo přestat interface úplně psát. To ale není v současné době možné a vygenerovaný kód je pak přesně takový, jaký by měl být:\n\n/--code php\nfinal class Container_59ca411ae5_IConfigComponentFactoryImpl_33 implements IConfigComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new ConfigComponent(\'testvalue1\');\n		return $service;\n	}\n\n}\n\\--\n\nAlternativně lze zvolit populárnější způsob a upravit konfigurační soubor takto:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n\nservices:\n	- implement: IConfigComponentFactory\n	  arguments: [%testkey1%]\n\\--\n\nVygenerovaný výsledek je stejný. V tomto případě je však nutné dát pozor na to, že při psaní interface je nutné psát jej i s `@return` anotací.\n\nOk, toto je snad jasné. Co to trošku zkomplikovat?\n\nAll in One\n==========\nToto snad bude dostatečně krajní případ. Pokusíme se vytvořit továrničku pro komponentu, která bude ke svému vytvoření vyžadovat parametr z configu, parametr z presenteru, službu a opět parametr z configu - vše přesně v tomto pořadí. A nebudu se v tom snažit hledat závislosti. Je vyžadováno něco takového:\n\n/--code php\n<?php\n\nclass AllInComponent extends Nette\\Application\\UI\\Control {\n\n	public function __construct($configParam1, array $userParam, App\\Model\\UserManager $userManager, $configParam2) {}\n\n}\n\ninterface IAllInComponentFactory {\n\n	/** @return AllInComponent */\n	function create(array $userParam);\n\n}\n\\--\n\nJe tedy jasné, že musím vytvořit `create` metodu s parametrem, který naplním v presenteru. Zde by opět `@return` anotace nemusela být. Je úplně zbytečná. A jak na ty parametry z configu? To už je přece vyřešené viz dřívější ukázky:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n	testkey2: testvalue2\n\nservices:\n	- implement: IAllInComponentFactory\n	  create: AllInComponent(configParam2: %testkey2%, configParam1: %testkey1%)\n\\--\n\nZde jsem si to ještě zkomplikoval tím, že jsem zadal parametry v obráceném pořadí (což by přesně takto fungovalo). Abych docílil správného pořadí, musím parametry správně pojmenovat (shodně s konstruktorem komponenty). A vygenerovaný kód? Radost pohledět:\n\n/--code php\nfinal class Container_59ca411ae5_IAllInComponentFactoryImpl_32 implements IAllInComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create(array $userParam) {\n		$service = new AllInComponent(\'testvalue1\', $userParam, $this->container->getService(\'27_App_Model_UserManager\'), \'testvalue2\');\n		return $service;\n	}\n\n}\n\\--\n\nI v tomto případě je možné zvolit jiný (úspornější) zápis v konfiguračním souboru. Vygenerovaný výstup je opět stejný:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n	testkey2: testvalue2\n\nservices:\n	- implement: IAllInComponentFactory\n	  arguments: [configParam2: %testkey2%, configParam1: %testkey1%]\n\\--\n\nTeď mě nenapadá, jestli je někdy (běžně) potřeba ještě něco složitějšího. Toto jsou však dva základní přístupy zkombinované do jedné ukázky. Podívejte se na všechny tyto \"příklady podrobněji na GitHubu\":https://github.com/mrtnzlml/generated-factories.',	'2015-03-24 22:15:22'),
(94,	'Barák budoucnosti',	'Aneb jak jsem poprvé a naposledy přešlápl. Je to jednoduché, nebudeme si nic nalhávat. Ještě jsem nepochopil smysl Barcampu. A tak se stalo, že jsem si připravil povídání o něčem, co nikdo moc nechápal. Jistě že mě to trošku mrzí, zároveň mi však přijde absurdní, že někdo přijde na přednášku, kde jsem upozorňoval v anotaci na použité technologie, které budou ve vyprávění zahrnuty a pak jsem slyšel, že někdo vůbec nevěděl o čem je řeč. To je ale kapitola sama pro sebe... (-:\n\nPoučím se a děkuji za feedback. Bylo to tak půl na půl. Půl lidí mi opakovala vlastně jednu a tu samou věc. Že to bylo moc složité. Že bylo potřeba znát hodně věcí okolo, aby se mohl člověk chytat. To je jeden z důvodů, proč už si nikdy nevezmu takovou přednášku na akci jako je Barcamp. Spektrum posluchačů totiž bylo extrémní. Od lidí úplně mimo mísu až po lidi, kteří této problematice perfektně rozumí (lépe než já). Proto jsem rád i za druhou polovinu feedbacku. Potkal jsem se totiž zhruba se stejným počtem lidí, ale s obráceným postojem, takže jsem měl prostor některé věci ještě dovysvětlit a vyjasnit. Bylo fakt super, když mě někdo zastavil na chodbě a chtěl vědět jak je technicky možné pořešit některé věci o kterých jsem mluvil, nebo si chtěl povídat o tom, jak jsou ty koncentrátory vlastně implementované a jak to funguje podrobněji, **že se mu to líbí!**\n\nZjednodušeně - nejsem spokojený se svým výstupem, ale jsem rád, že jsem mohl potkat několik inspirativních lidí a dobře si popovídat. Díky. Nebudu to zde více rozpatlávat. Podívejte se na prezentaci... (-:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/46412746\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nPřikládám ještě odkazy na zmiňovaný \"referenční manuál\":http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf od mikrokontrolérů a dokument pojednávající o myšlence Fog Computingu: \"Fog Computing and Its Role in the Internet of Things\":http://conferences.sigcomm.org/sigcomm/2012/paper/mcc/p13.pdf.\n\nA co ostatní přednášky?\n=======================\nNo tak všechny skvělé. Já si vážím toho, když někdo vystoupí a ukáže co dělá a je z toho nadšený. Některé přednášky jsem tedy jen proseděl a nic nového jsem se moc nedozvěděl (a to právě nevím, jestli mám od Barcampů čekat). Ne všechny přednášky pro mě mají takovou informační hodnotu. Ale lidem se to líbí, takže za mě dobré.\n\nSoučástí Barcampu byl i \"Arduino Day 2015\":https://day.arduino.cc/#/. Tam jsem byl pouze na přednášce o Superkondenzátorech. Kamarád z toho byl úplně nadšený. Pokud vás zajímá elektronika a nejlépe ještě rádi bastlíte, tak doporučuji vyhledat si záznam. Já osobně považuji za nejlepší přednášky \"8 a půl roku přednášení pro Microsoft\":https://plzenskybarcamp.cz/2015/prednasky/5cd9cd30 a \"Od zadání k release za dva dny: jak se programuje v novinách\":https://plzenskybarcamp.cz/2015/prednasky/8eba3b56 aneb jak se hledá balanc mezi náprasem a perfektním kódem... (-:\n\nA když opomenu přednášky? No tak Afterparty byla super. I zde jsem měl příležitost prohodit pár zajímavých rozhovorů. Nakonec se to trošku protáhlo a do postele jsem ulehal až v 6 ráno. Ale s hezkým pocitem, že nedělám úplné hovadiny, jen se musím naučit své myšlenky lidem lépe prodat...',	'2015-03-29 14:15:21'),
(95,	'Doctrine pro non-doctrine programátory',	'A také o tom proč jsem se ptal kdo studoval, studuje, nebo bude studovat elektrotechnickou fakultu a proč jsem si až pak uvědomil, že jsem se vlastně zeptal úplně blbě.\n\nAle napřed k samotné přednášce. Nemá smysl zde psát dlouhosáhlé slohy o tom co jsem říkal, počkejte si na video. Pár slov si však neodpustím. Myslím si, že jsem málo zdůraznil to, aby si každý koho to alespoň trošku zajímá Doctrine vyzkoušel. Ale ne jen tak si něco uložit a přečíst z databáze. Já jsem si například přepsal tento blog. Kompletně. Udělejte něco podobného. Teprve potom se ukáže jaké jsou výhody/nevýhody a hlavně - teprve teď se můžete rozhodnout co vám více sedí, protože už máte vyřešené nějaké konkrétní problémy, ne jen modelové situace. Výměnou za hvězdičku se můžete inspirovat například \"zde\":https://github.com/mrtnzlml/zlml.cz.\n\nA co když si nevíte rady? To nevadí. Stává se to často, proto existuje spoustu míst kde se ptát. Jedno je samozřejmě zde. Existuje však \"Nette fórum\":http://forum.nette.org/cs/ a pak (a to hlavně) \"Kdyby HELP fórum\":https://help.kdyby.org/. Na všech místech vám určitě někdo poradí.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/79L3O5KfQJxyOc\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nJeště než prozradím jak je to s tou FEL, rád bych ještě jednou poděkoval lidem z \"ANT studia\":http://www.antstudio.cz/, protože bez nich bych si PoSobotu nemohl tolik užít a nemohl bych zajít na afterpivo - i když jen nealkoholické. Těší mě to i z toho důvodu, že právě s \"ANT studiem\":http://www.antstudio.cz/ začínám, po vyřešení všech studijních formalit, spolupracovat na zajímavých projektech v Nette... (-:\n\nA teď už konečně k oné nešťastné otázce. Správně měla znít:\n\n> Kdo studoval, studuje, nebo bude studovat nějakou **neprogramátorskou** školu?\n\nBylo totiž krátkozraké omezit se jen na elektro, ale tam to vše vzniklo a už jsem to neřešil dál. Upozornil mě na to až \"@stekycz\":https://twitter.com/stekycz. A proč jsem se na to ptal? Inu nastal čas kdy jsem se potřeboval posunout někam dál a začal jsem obcházet firmy v Plzni. Měl jsem tak příležitost potkat spoustu zajímavých lidí a skutečně si vybrat něco co by mě mohlo bavit. A při tomto kolečku mě zaujal často se opakující rozhovor:\n\n> Takže vy studuje asi FAV, že?\n>\n> Ne, FEL.\n>\n> Aha, to my také...\n\nA bylo to častější, než bych si byl kdy býval pomyslel. Došel jsem pak s kolegou k jednoduchému závěru. Zřejmě všichni kdo programují dobrovolně, tedy všichni které do programování nepřinutí škola, jsou prostě dobří. Mají obrovskou naději na uchycení se. Viděl jsem to i z pozice kdy jsem dělal pohovory s lidma. Je skutečně obrovský rozdíl potkat borce z FAV a programátora z FEL nebo odkudkoliv kde programování zase až tak nefrčí.\n\nA naposledy ještě jednou velké díky \"@chemix_cz\":https://twitter.com/chemix_cz! Odvádíš neuvěřitelnou práci.',	'2015-04-26 12:38:53'),
(96,	'Fixněte si databázi',	'Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?\n\nPrvní přístup\n=============\nNebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:\n\n/--code sql\nREPLACE INTO `options` (`key`, `value`)\nVALUES\n(\'option1\', \'value1\'),\n(\'option2\', \'value2\'),\n(\'option3\', \'value3\');\n\\--\n\nTo jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. //(Jo správně, blog jde nainstalovat na více databází...)// A to je voser.\n\nAle jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).\n\nLepší přístup pomocí fixtures\n=============================\nZnáte \"Doctrine Data Fixtures Extension\":https://github.com/doctrine/data-fixtures? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:\n\n/--code\ncomposer require doctrine/data-fixtures\n\\--\n\nSamozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna \"Kdyby/Console\":https://github.com/Kdyby/Console, která integruje \"command ze Symfony\":http://symfony.com/doc/current/components/console/introduction.html. Už jsem o tom psal něco málo \"dříve\":http://zlml.cz/kdyby-console. A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil \"někdo jiný\":https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php. A trošku si to zjedoduším:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor;\nuse Doctrine\\Common\\DataFixtures\\Loader;\nuse Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger;\nuse Kdyby\\Doctrine\\EntityManager;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass DefaultData extends Command\n{\n\n	/** @var EntityManager @inject */\n	public $em;\n\n	protected function configure()\n	{\n		$this\n			->setName(\'orm:demo-data:load\')\n			->setDescription(\'Load data fixtures to your database.\');\n            //->addOption...\n    }\n    \n    protected function execute(InputInterface $input, OutputInterface $output)\n	{\n		try {\n        	$loader = new Loader();\n			$loader->loadFromDirectory(__DIR__ . \'/../basic\');\n            $fixtures = $loader->getFixtures();\n\n			$purger = new ORMPurger($this->em);\n            \n            $executor = new ORMExecutor($this->em, $purger);\n			$executor->setLogger(function ($message) use ($output) {\n				$output->writeln(sprintf(\'  <comment>></comment> <info>%s</info>\', $message));\n			});\n			$executor->execute($fixtures);\n			return 0; // zero return code means everything is ok\n        } catch (\\Exception $exc) {\n			$output->writeLn(\"<error>{$exc->getMessage()}</error>\");\n			return 1; // non-zero return code means error\n		}\n	}\n}\n\\--\n\nOk, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí `loadFromDirectory`. Jedná o objekty, které implementují interface `FixtureInterface`, nebo možná lépe dědí od abstraktní třídy `AbstractFixture`. Obojí je v `Doctrine\\Common\\DataFixtures` namespace. Objekt obsahující defaultní uživatele může vypadat takto:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse Nette\\Security\\Passwords;\n\nclass UsersFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n	public function load(ObjectManager $manager)\n	{\n		$admin = new \\Users\\User(\'admin@nette.org\');\n		$admin->setPassword(Passwords::hash(\'admin\'));\n		$admin->addRole($this->getReference(\'admin-role\'));\n		$manager->persist($admin);\n\n		$demo = new \\Users\\User(\'demo@nette.org\');\n		$demo->setPassword(Passwords::hash(\'demo\'));\n		$demo->addRole($this->getReference(\'demo-role\'));\n		$manager->persist($demo);\n\n		$manager->flush();\n\n		$this->addReference(\'admin-user\', $admin);\n		$this->addReference(\'demo-user\', $demo);\n	}\n\n}\n\\--\n\nV čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce `addReference` a `getReference`. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nclass RolesFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n	public function load(ObjectManager $manager)\n	{\n		$user = new \\Users\\Role();\n		$user->setName(\\Users\\Role::DEMO_USER);\n		$manager->persist($user);\n\n		$admin = new \\Users\\Role();\n		$admin->setName(\\Users\\Role::ADMIN);\n		$manager->persist($admin);\n\n		$manager->flush();\n\n		$this->addReference(\'demo-role\', $user);\n		$this->addReference(\'admin-role\', $admin);\n	}\n\n}\n\\--\n\nVidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...\n\nJen pozor na jedno věc. Ohlídejte si \"pořadí těchto objektů\":https://github.com/doctrine/data-fixtures#fixture-ordering. To lze vyřešit implementací rozhraní `OrderedFixtureInterface`, nebo `DependentFixtureInterface`, což je o něco lepší přístup.\n\nA jak toto celé použít? Však už to znáte:\n\n/--code\nλ php index.php\nλ php index.php orm:schema-tool:create\nλ php index.php orm:demo-data:load\n\\--\n\nPrvní příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:\n\n/--code\nλ php index.php orm:demo-data:load --demo\nCareful, database will be purged. Do you want to continue Y/N ? y\n  > purging database\n  > loading RolesFixture\n  > loading UsersFixture\n  > loading ArticlesFixture\n  > loading ProductsFixture\n  ...\n\\--',	'2015-05-21 11:24:01'),
(97,	'Vzhůru dolů! A pak zase nahoru...',	'Na relativně dlouhou dobu jsem se teď odmlčel. Psal jsem totiž někam jinam než na blog a svůj příděl písmenek na měsíc jsem odevzdával právě tam. Ale stálo to za to. Totiž jak se to vezme. Projděme si sled událostí. Událost první. Poprvé jsem \"představil\":http://www.slideshare.net/MartinZlmal/nodejs-42314371 svůj projekt na FAV, kde studenty zaujal a na konci přednášky se kolem samotného projektu utvořil hlouček zvědavců toužící prohlédnout si zařízení lépe. Událost druhá. Představil jsem tento projekt \"širší veřejnosti\":http://www.slideshare.net/MartinZlmal/barcamp2015 na Barcampu v Plzni a získal jsem velkou spoustu negativních reakcí. Samotná zadávající firma se dále přestala o tento projekt více zajímat a musel jsem se s tím chvíli pasovat, abych věděl na čem jsem. Událost třetí. I když mi to chvíli trvalo, tak jsem se vzpamatoval, implementoval jsem ještě několik cool věcí a tento projekt uvedl do finální fáze, kdy bych byl ochoten se s ním pochlubit před odborným publikem. Tak jsem také u SZZ udělal a práci úspěšně obhájil. Událost čtvrtá a poslední. Tato práce \"vyhrála soutěž\":http://www.abb.cz/cawp/seitp202/67b19426a3ab3b8fc1257e6e004f2d33.aspx ABB University Award 2015 - soutěž o nejlepší technicky zaměřenou vysokoškolskou práci v ČR.\n\nProč to vůbec říkám? Abych si trošku zamachroval... (-: Ale také proto, abych s lehkým úšklebkem poděkoval všem lidem, díky kterým jsem se chvíli cítil fakt špatně a díky kterým jsem tu práci po Barcampu přihlásil do soutěže. Chtěl jsem vědět, jestli je to fakt taková sračka a bude to jasná tečka za mým snažením, nebo ta práce (resp. myšlenka) má nějaký smysl. A smysl to mělo. Hodnotil se nápad, zpracování a to jak jsem to ústně přednesl (pravděpodobně). Pokud máte čas, tak si tuto práci můžete přečíst. Budu rád pokud tak (alespoň nějak rychle) učiníte a můžeme si o tom popovídat více.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/q1xdPbSZTIUXQ\" width=\"600\" height=\"750\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nCo celá práce velmi jednoduše řečeno řeší? Jak co nejrychleji dostat data z nějaké elektroniky (koncentrátoru) až do webové aplikace a zpět. K tomu by mělo být (a je) možné změnit zapojení sítě, tzn. jedná se o logickou síť, která není závislá ani na fyzickém zapojení, ani na použitých zařízeních a technologiích. Ve výsledku je to triviální problém, ale ne každý jej dokáže vstřebat, nebo si něco takového vůbec připustit.\n\nCo dál ještě nevím. Uvidím, jestli se to nějaké firmě zalíbí více, než té současné a bude schopna se za to postavit. Pokud ne, tak celý nápad postrádá smysl a vrhnul bych se asi do nějakých myšlenek uvedených ke konci práce, jako je například \"Li-Fi\":https://en.wikipedia.org/wiki/Li-Fi, nebo částečně decentralizovaný přístup sítě. Jedno vím ale jistě. Na Barcamp už s tím ani nepáchnu... :-))',	'2015-06-27 20:10:33'),
(98,	'Dynamické routování URL adres',	'A když říkám dynamické, tak tím myslím opravdu kompletně. Jinými slovy to znamená, že chceme jakoukoliv cestu za doménou přeložit na jakýkoliv interní požadavek (\"Application\\Request\":http://api.nette.org/2.3.3/Nette.Application.Request.html). Kousek routovací tabulky tedy může vypadat následovně:\n\n/--code\n/						=> 	Front:Homepage:default\n/neco.html				=> 	Front:Page:default\n/neco-jineho-8			=> 	Front:Page:default(id=56)\n/neco/treba/takoveho	=> 	Front:Page:default(id=96)\n/a/b/c/d/e/f 			=> 	Admin:Dashboard:new\n...\n\\--\n\nTím jsem doufám dostatečně přesně nastínil zadání a od toho se odvíjející požadavky na router. V URL může přijít jakákoliv cesta a aplikace ji musí umět správně naroutovat.\n\nJak funguje routování v Nette\n=============================\nPokusím se to vysvětlit trošku jinak než je to vysvětlováno jinde. Většinou se totiž dočtete, jak pracovat s \"třídou Route\":http://api.nette.org/2.3.3/Nette.Application.Routers.Route.html. To je samozřejmě správně, protože takto se routování v Nette aplikacích naprosto běžně dělá. Nicméně pro tento účel mi přijde vhodnější napsat si router vlastní - o něco hloupější, ale pasující na toto zadání lépe. Proto opustíme tuto třídu a budeme se raději zajímat o \"IRouter interface\":http://api.nette.org/2.3.3/Nette.Application.IRouter.html.\n\nTento interface má dvě metody - `match` a `constructUrl`. Metoda `match` má za úkol přeložit HTTP request na již zmíněný \"Application\\Request\":http://api.nette.org/2.3.3/Nette.Application.Request.html. Jedná se tedy o překlad ve směru šipky viz zadání. Podívejte se, jak to řeší třída Route, v tomto konkrétním prípadě však bude potřeba pracovat s databází a napsat si jinou logiku. Oproti tomu metoda `constructUrl` má přesně opačný úkol. Překládá příchozí Application request na (absolutní) URL adresu.\n\n[* 9ab04acb-febc-4901-aaad-5b554f77e529/vystrizek.png 610x? <]\n\nZatímco Route dokáže tyto překlady sestavit pouze z masky routy a namapovat je na interní odkazy v aplikaci, v tomto případě bude nutná databáze. Po chvíli laborování a asi pěti variantách jsem nakonec udělal ústupek a zvolil tu nejjednodušší (ale dostatečnou) variantu viz obrázek. Stačí si tedy uchovávat cestu, interní odkaz a interní ID. To je vše, co by mělo být potřeba.\n\nKonkrétní řešení\n================\nNechci sem dávat celé zdrojáky (jen útržky), protože je tento článek hlavně o teorii. Proto se podívejte na nějakou jinou již hotovou implementaci IRouteru, třeba na \"StaticRouter\":https://github.com/nextras/static-router/blob/master/src/StaticRouter.php. Ostatně s dobrým nápadem je samotná implementace jednoduchá. V `match` si stačí podle cesty vytáhnout interní odkaz třeba nějak takto:\n\n/--code php\n$destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\nif ($destination === NULL) {\n	$this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n	return NULL;\n}\n\\--\n\nSamozřejmě je fajn si tu cestu ještě před dotazem nějak upravit, podle toho jak jí máte v databázi. Já je tam mám třeba bez úvodního lomítka. Tato cesta odkazu směrem do aplikace je velmi jednoduchá, protože pouze na základě cesty v URL si natáhnete vše, co je potřeba a už vlastně jen sestavíme Application request:\n\n/--code php\n$params = $httpRequest->getQuery();\n$params[\'action\'] = $action;\nif ($destination[$internalDestination]) {\n	$params[\'id\'] = $destination[$internalDestination];\n}\nreturn new Application\\Request(\n	$presenter,\n	$httpRequest->getMethod(),\n	$params,\n	$httpRequest->getPost(),\n	$httpRequest->getFiles(),\n	[Application\\Request::SECURED => $httpRequest->isSecured()]\n);\n\\--\n\nNedělá se zde nic zvláštního, prostě postavím request a přibalím do něj cílový presenter (ten jsem si vytáhl z databáze), do parametrů je třeba přidat action a volitelně ještě to interní ID. Stanovil jsem si takovou konvenci, že aplikace bude používat interně pouze ID. Proč? Prvně je to velmi jednoduché a neřeším žádné hovadiny. Nepotřebuji něco jako je slug, protože jsou adresy konstruovány jinak. Takové je zadání. No a potom práce s ID je i z hlediska Doctrine \"velmi přirozené\":http://forum.nette.org/cs/23681-kdyby-doctrine-use-cases-best-practices-a-jak-vam-to-dava-smysl#p159096. Jeden příklad za všechny. Mám aplikaci rozsekanou na komponenty co nejvíce to šlo. Je jich fakt hodně - stránku vlastně jen skládám z komponent. To považuji za skvělý návrh, ale vede k tomu, že se jednolivé komponenty od sebe aplikačně trošku vzdalují. No a když bych chtěl třeba v každé komponentě vytáhnout něco stejného, tak při nevhodném dotazu by Doctrine položila dva stejné dotazy na databázi. Je však možné využít ID a zeptat se jinak. Porovnejte následující dotazy:\n\n/--code php\n$this->em->getRepository(File::class)->findOneBy([\'id\' => 930]);\n$this->em->getRepository(File::class)->find(930);\n\\--\n\nNejsou stejné. Ten druhý můžete použít kolikrát chcete, ale pokud již Doctrine zná odpověď, tak se nezeptá databáze znova. Obdobně (ještě lépe) to funguje s `getPartialReference`. Takže bod pro práci pouze s ID.\n\nJe třeba zajistit i obrácený překlad. Ten mi vždy přijde náročnější a měl jsem vymyšlený fakt pěkný nápad, ale neuměl jsem ho zrealizovat. Ale díky tomu, že se využívá interně jen ID, mohu jej uložit jako třetí sloupec do databáze a je možné jednoduše patřičnou cestu dohledat. Je však třeba uvědomit si, že existují čtyři možné stavy:\n\n1) Odkaz nemá žádné ID, hledáme cestu pouze podle destination (např. Front:Homepage:default - ID je volitelné)\n2) Odkaz má ID, hledáme cestu podle destination a ID\n3) Odkaz sice má ID, ale v databázi takový záznam není, v tom případě použít první bod a parametry pověsit do query odkazu (fallback)\n4) Odkaz se nepodařilo najít ani odhadnout v dalších bodech, routa vrací NULL\n\nProč vrací v posledním bodě routa NULL? Určitě víte, že při definování klasického routeru záleží na pořadí rout. Je to právě kvůli tomuto. Když první routa nedokáže příchozí požadavek sestavit, vrací NULL a na řadě je další routa, která se o to pokusí. Požadavek propadne dále. Tak to jde až do okamžiku, kdy už není žádná jiná možnost a to je chybový stav (404). Vzhledem k tomu, že používám pouze tento vlastní router, tak NULL je ekvivalent právě k chybě 404. Ale napsal jsem si to tak, aby routa byla hodně žravá a pokusila se za každou cenu nějaký odkaz postavit. Třetí bod je navíc stav, který se loguje.\n\nJeště je důležitá poslední věc. Jak jsem psal dříve, tak se v `match` metodě přidává do Application requestu action a volitelně ID. V metodě `constructUrl` je potřeba zvolit opačný přístup a zase je zrušit. Nedostanou se tak do URL. V tom je celé kouzlo takto volně definovaných adres. Na vstupu přidám nějaké informace navíc (action, ID), s nima aplikace pracuje a na výstupu je zase z adresy odstraním.\n\nBez cache ani ránu\n==================\nZatím je to docela fajn. By default mám v databázi nějaké základní odkazy a například při ukládání článku vytvořím odkazy nové, které se pak naroutují. Výhoda je jednak v tom, že mohu mít úplně libovolné adresy. Mohu je ale také různě upravovat podle nastavení a pak co je asi nejdůležitější, adresy jsou unikátní a když ji u článku změním, mohu starou (automaticky) přesměrovat na novou. Po tomto musí SEO odborníci čvachtat blahem... :)\n\nProblém je však v tom, že je to spousta práce a bez nějaké alespoň jednoduché cache by to bylo moc komplikované, skoro až nepoužitelné. Řešení je však jednoduché. Prostě cache použijeme:\n\n/--code php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n	$destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\n	if ($destination === NULL) {\n		$this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n		return NULL;\n	}\n	return [$destination->destination => $destination->internalId];\n});\nif ($destination === NULL) {\n	return NULL;\n}\n\\--\n\nJe to vlastně stejný kód jako v první ukázce, ale výsledek si uloží do cache a příště už ví jaký odkaz použít. Trošku nevýhoda je, že to vygeneruje cache soubůrek pro každý individuální odkaz. Myslím si však, že je to správně, protože skutečně každý odkaz může být úplně jiný. Takže jsem si alespoň pro dobrý pocit vyrobil ještě upravený \"FileStorage\":http://api.nette.org/2.3.3/Nette.Caching.Storages.FileStorage.html, který cache zanořuje ještě o úroveň níže podle prvních dvou znaků (resp. podle druhého a třetího). No a celá ta sranda se chová tak, že při načtení stránky vyřeší ty dotazy, které je potřeba vyřešit a při dalším načtení již nic nedělá, pouze je přečte z cache. Při průchodu stránkou pouze dochází k řešení dalších - ještě nevyřešených odkazů. Pak to se postupně vyřeší všechny a už se na to nikdy nebude sahat (není to moc žádoucí).\n\nPár důležitých poznámek\n=======================\nVzhledem k tomu, že v tomto konkrétním případě chci používat pouze tuto routu, tak je možné všechny ostatní úplně vyhodit pryč. Fakticky stačí z rozšíření vyhodit definici původní nativní routy:\n\n/--code php\n$containerBuilder->removeDefinition(\'routing.router\');\n\\--\n\nUdělal jsem to teď, takže to ještě nemám pořádně vyzkoušené a doufám, že jsem tím nic nerozbil. Ale neměl bych. Po zaregistrování této vlastní routy v configu vše začne krásně fungovat. Stačí, že implementuje IRouter a tato implementace je jediná v celém projektu (což je po této úpravě pravda).\n\nNo a na závěr ještě úvaha, kterou jsem sice ještě neimplementoval, ale asi bych to tak rád udělal. Jedná se o jazykové mutace. Jednak je mohu ovlivňovat přidáním nějakého `/en/` do cesty (což se tento router jednoduše naučí), ale pak může přijít složitější požadavek. Máme dvě domény směřující na jednu aplikaci a každá doména představuje jinou jazykovou mutaci. To je docela naprd, ale vzhledem k tomu, že do `match` metody v argumentu vstupuje HTTP request, mohu tuto jazykovou mutaci nastavit pouze na základě adresy zase velmi jednoduše. Jediná modifikace bude v tom, že začnu v Application requestu posílat i locale proměnnou pro translátor.\n\nPoslední nejdůležitější upozornění\n==================================\nMožná si již někdo všiml, že jsem změnil doménu. Nová doména je `zlml.cz`. Vzhledem k tomu, že původní byla pouze dočasná (i když na několik let) a nepodařilo se mi získat tu co jsem moc chtěl, zvolil jsem tuto. Jak si jí snadno zapamatovat? Je to jednoduché. Prostě moje příjmení bez samohlásek. Původní doména je přesměrována 1:1 a ještě ji budu docela dlouhou dobu držet. Ale až uvidím, že to nemá takový smysl, tak bych jí třeba za pár let zrušil. Pokud tedy chcete mít jistotu, že se k vám vždy nové články dostanou, změňte si prosím ve svých RSS čtečkách adresu na \"http://zlml.cz/rss\":http://zlml.cz/rss.\n',	'2015-07-05 14:21:48'),
(99,	'Hierarchický router',	'Tento článek volně navazuje na \"předchozí\":http://zlml.cz/dynamicke-routovani-url-adres. Zde jsem ukázal, jak vytvořit routy tak, aby bylo možné mít zcela libovolnou adresu a routovat ji na jakoukoliv akci v aplikaci. Dnes to trošku vylepšíme. Přidáme totiž další dva požadavky s tím, že první je ten důležitější:\n\n1) Když se změní adresa (například článku), musí se stará přesměrovat na novou. To se může dít opakovaně a nechceme mít mnohonásobný redirect. Redirect může být maximálně jeden a to pro jakoukoliv starou (i původní) adresu.\n2) Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nDruhý požadavek je vlastně jen speciální (zjednodušený) případ toho prvního. Co to znamená? Podívejte se na následující ASCII art. Obsahuje pět obrázků znázorňujících postupné změny přesměrování při přidávání dalších přesměrování. Nebudeme již řešit routování na akce v presenterech, ale práci se samotným URL a jak se bude chovat, když se přesměruje aktuální cílové URL jinam.\n\n/--code\nURL-1\n\n\nURL-1 ----> URL-2\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-4 <---- URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-5 <---- URL-3\n             ^\n             \'----------URL-4\n\\--\n\nSlovy řečeno, nesmí se **nikdy** stát, aby byla cesta od staré adresy k nové delší, než je jeden skok. Je zřejmé, že původně byla pouze URL-1. Ta byla přesměrována na URL-2. V okamžik, kdy se přesměruje URL-2 na URL-3, původní propojení mezi URL-1 a URL-2 se musí úplně zrušit a naměrovat URL-1 až na URL-3. A tak to pokračuje dále. Z toho je zřejmé, že nazývat tento router hierarchickým je poněkud zavádějící, protože ve skutečnosti se udržuje takový obrácený les. S troškou režie na začátku je to však vhodnější, protože se tím hezky mění průběžně struktura redirectů a je to lepší, než například takto, to je asi všem jasné:\n\n/--code\nURL-1\n \'--> URL-2\n       \'--> URL-3\n             \'--> URL-4\n                   \'--> URL-5\n\\--\n\nPřepočet odkazů\n===============\nV tom to vlastně celé vězí. Je nutné při vytváření redirectu najít všechny staré odkazy a změnit je na nové. Vrátíme se však k předchozímu článku a trošku vylepšíme cache. Tedy cache zůstane stejná, ale vylepšíme její invalidaci následovně:\n\n/--code php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n    $destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\n    if ($destination === NULL) {\n        $this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n        return NULL;\n    }\n    $dependencies = [Nette\\Caching\\Cache::TAGS => [\'route/\' . $destination->getId()]];\n    return $destination;\n});\n\\--\n\nPřidáme ke každému uložení cache tzv. tag, díky čemuž bude možné později tuto cache snadno najít a zrušit její platnost. V closure je nutné dělat to takto přes dependencies proměnnou. Jsou samozřejmě i jiné možnosti \"jak cache zneplatnit\":http://doc.nette.org/cs/2.3/caching#toc-expirace-a-invalidace, ale tento způsob považuji za dostatečný. Hodí se to proto, že až budeme upravovat staré odkazy, tak je (a pouze je) smažeme z cache, čímž zapříčiníme jejich opětovné vytvoření, tentokrát však s jiným přesměrováním.\n\nDo entity URL adresy je třeba přidat další vlastnost - odkaz na sebe.\n\n/--code php\n/**\n * @ORM\\ManyToOne(targetEntity=\"Url\", cascade={\"persist\"})\n * @ORM\\JoinColumn(referencedColumnName=\"id\", onDelete=\"SET NULL\")\n * @var Url\n */\nprotected $redirectTo = NULL;\n\\--\n\nTento odkaz využijeme v routeru, který v případě existence tohoto odkazu bude pracovat právě s ním. V opačném případě router pracuje normálně viz předchozí článek. To už tu nebudu řešit. Spíše se podíváme na samotnou tvorbu redirectů. Tu mám umístěnou v `@RedirectFacade::createRedirect`. Tato metoda přijímá dvě čísla (ID) a to odkud se přesměrovává a kam se přesměrovává. Bohužel není možné předat si parciální entitu, protože není možné ji naplnit a odeslat do databáze (vlastnost Doctrine). No a předávat celé entity je zbytečné. Proto jen ID. Zjednodušeně vypadá tato metoda takto:\n\n/--code php\npublic function createRedirect($from, $to)\n{\n    $this->em->transactional(function () use ($from, $to) {\n        /** @var Url $oldLink */\n        foreach ($this->em->getRepository(Url::class)->findBy([\n            \'redirectTo\' => $from\n        ]) as $oldLink) {\n            $oldLink->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n            $this->cache->clean([Nette\\Caching\\Cache::TAGS => [\'route/\' . $oldLink->getId()]]);\n        }\n\n        /** @var Url $from */\n        $from = $this->em->find(Url::class, $from);\n        $from->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n        $this->em->flush();\n        $this->cache->clean([Nette\\Caching\\Cache::TAGS => [\'route/\' . $from->getId()]]);\n    });\n}\n\\--\n\nDalo by se to optimalizovat z hlediska databázových dotazů lépe, ale jednak to není (zatím nebylo) potřeba a pak se hodí tahat si jednotlivé záznamy postupně právě kvůli invalidace cache. Jak to funguje? V první části si vytáhnu všechny odkazy, které ukazují na odkaz ze kterého budu přesměrovávat. To jsou ty staré, které je třeba zrušit. Ty jsou nahrazeny odkazy na nové stránky a jejich cache je samozřejmě smazána. To je ta důležitější část. V druhé polovině dojde jen k uložení nového přesměrování a opět smazání cache pro tento odkaz. Za povšimnutí stojí funkce `getPartialReference` o které jsem psal už minule. Je to funkce, která nevrací celou entitu, ale pouze nenaplněnou entitu s ID (parciální). Nic víc totiž dost často není potřeba...\n\nDruhá část řešení\n=================\nDruhá část řešení je již jednoduchá.\n\n> Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nStačí entitě povolit, aby mohlo být NULL `destination` (tedy interní odkaz na presenter a akci) a `internalId`. To jsou totiž informace, které nejsou známé a pro tetno účel jsou i zbytečné. Důležitá je totiž jen cesta a odkaz na cílovou URL. A to je vlastně vše, protože vše ostatní už přirozeně umí dříve napsaný router.\n\nJeště jsem nedávno narazil na zajímavý router, který umožňoval smazat jakoukoliv část cesty a on si jí domyslel a přesměroval. Nekoukal jsem úplně do střev, ale asi tak, že vyhledá přesně znění cesty a když ji nemůže najít, tak položí nějaký LIKE% dotaz ve snaze alespoň ji odhadnout. To už ale považuji za zbytečné a nevyužitelné. Osobně se mi ještě více líbí routy, které jsou na ČSFD. Obsahují totiž přirozený zkracovač adres viz tyto dvě adresy, které jsou stejné:\n\n/--code\nhttp://www.csfd.cz/film/5911\nhttp://www.csfd.cz/film/5911-tenkrat-na-zapade/\n\\--\n\nVyzkoušejte \"si\":http://www.csfd.cz/film/5911 \"to\":http://www.csfd.cz/film/5911-tenkrat-na-zapade/. První přesměruje na druhou. Bohužel ne všem se čísla v adresách líbí (i když podle mého názoru bezdpůvodně).\n\nAčkoliv budu na routeru dále pracovat, tak k němu zatím nemám v plánu další komentáře. Pokud tedy něco není jasné, teď je ta správná chvíle zeptat se. Jo mimochodem. Předchozí router už není obyčejnou implementací `\\Nette\\Application\\IRouter`, ale dědí od `\\Nette\\Application\\Routers\\RouteList`. Je to z toho důvodu, že se bez toho Kdyby\\Console \"nerozjede\":https://github.com/Kdyby/Console/blob/master/src/Kdyby/Console/CliRouter.php#L124. Pokud bych tedy nepoužíval tuto knihovnu, tak by to nebyl problém. Samotná quick\'n\'dirty úprava spočívá v přidání tohoto kódu na začátek match metody:\n\n/--code php\n/** @var Application\\IRouter $route */\nforeach ($this as $route) {\n    /** @var Application\\Request $applicationRequest */\n    $applicationRequest = $route->match($httpRequest);\n    if ($applicationRequest !== NULL) {\n        return $applicationRequest;\n    }\n}\n\\--\n\nA to je vše...',	'2015-07-11 14:38:21'),
(100,	'Návrhový vzor Legacy code',	'Asi každý se k tomuto návrovému vzoru jednou dostane. Zatím jsem vždy takovou práci striktně odmítal, ale tentokrát šlo o jinou situaci a svolil jsem k poklesu od OOP frameworku ke špagetě. Ačkoliv má pojem \"legacy code\" celou řadu definic, já osobně jej chápu jako kód, který je prostě starý. Vhodnější by však bylo asi říci, že se jedná o kód se kterým teď musím pracovat, ale nenapsal jsem ho. Zůstaňme však u první definice. Zde platí, že (stejně tak jako jakýkoliv jiný navrhový vzor) obsahuje celou řadu opakujících se poznávacích prvků.\n\nNapříklad mezi vývojáři panuje pozoruhodná pasivita. Nikdo se nepostaví na zadní a nepřijde s něčím novým. Nemyslím novou fičuru, ale nějakou systémovou věc. Na druhou stranu se to dá pochopit. Je to ta nejdražší změna a zase až tak ničemu to z vnějšího pohledu neprospěje. Nepovažuji to za správný přístup, ale taková je asi realita. Bohužel se pak často argumentuje (totální) zpětnou kompatibilitou. Dále tento návrhový vzor předpokládá, že se používá nějaký vypíčený verzovací systém a nikoho to netrápí (viz pozoruhodná pasivita vývojářů). O coding standardu ani nemluvě a globální prostor je samozřejmostí. No a pak samozřejmě klasické věci jako RY přístup (opak \"DRY\":https://cs.wikipedia.org/wiki/Don%27t_repeat_yourself - Don\'t Repeat Yourself), šablonovací systém (pokud vůbec existuje) je stejně debilní jako ten verzovací a v neposlední řadě neotestovaný/neotestovatelný kód.\n\nV mém konkrétním případě jsem se musel potýkat ještě s něčím. Jednak jsem se musel poprat s opačným smýšlením vývojářů. Takže například zatímco všude se direktiva `magic_quotes_gpc` \"vypínala\":http://php.vrana.cz/vypnuti-magic_quotes_gpc.php, zde se globálně zapínala atd. No a pak samotný globální prostor to je písnička sama pro sebe. Myslel jsem si, že to až takový problém nebude, ale neuvědomoval jsem si, co to vlastně obnáší. Pokud stejně jako já nikdy globální proměnné nepoužíváte, zde je příklad na připomenutí.\n\nJakákoliv globální proměnná, která není nijak dále zabalená je automaticky globální:\n\n/--code php\n$x = \'y\';\ndump($GLOBALS[\'x\']); //y\n\\--\n\nTo dává smysl a není na tom nic divného. Za mnohem větší problém však považuji fakt, že to funguje i obráceně:\n\n/--code php\n$GLOBALS[\'x\'] = \'y\';\ndump($x); //y\n\\--\n\nProč je to problém? Protože druhý případ je striktně závislý na použitém kontextu. Tím pádem tato pseudoglobální proměnná funguje ve špagetě, ale když chcete takový kód jinak uspořádat a nedej bože ještě obalit, tak je to problém. Vzhledem k tomu, že bylo mým úkolem integrovat \"Nette Framework\":https://nette.org/ do takového systému, musel jsem trošku upravit start aplikace a tím jsem hodně věcí rozbil.\n\n[* d6ca5ea3-5c1a-43af-8488-73d4fae836f1/strip-wordpress-550-finalenglish.jpg <]\n\nJak jsem na to šel\n==================\nNebudu zde rozebírat přesně důvody proč jsem to udělal tak a ne jinak. Většinou mě to k tomu řešení jasně dovedlo, protože dělat to jinak by bylo nesmyslně složité - pokud vůbec možné. Berte to jako inspiraci. Myslím si, že se to bude ještě nekomu hodit, protože je tento návrhový vzor rozšířen více, než si přiznávám.\n\nV první řadě bylo nutné do projektu přidávat závislosti pomocí Composeru. Jednak se tak projekt trošku vyčistil od zbytečně nakopírovaných knihoven a potom jsem mohl s výhodou používat jednotlivé Nette komponenty. Pak je velmi důležité celý projekt poznat trochu hlouběji. Na to není vždy čas. Začal jsem proto tak, že jsem napojil na systém jednodušší části frameworku jako je třeba Tracy, Cache, Utils, RobotLoader atd. S tím se samozřejmě svezlo několik úprav, jako je například zapnutí error reportingu nebo vypnutí zahazování výjimek a další podobné hovadiny. Samotné zapnutí error reportingu je neskutečný oser, protože se tím ukáže, jak se daná aplikace hrozně sype (\"však jsou to jen notices\":https://media.giphy.com/media/11c2hRHwmvgFOg/giphy.gif, co se může stát). Každopádně už třeba použitím cache na správných místech a úpravou několik funkcí se aplikace rozjela daleko rychleji.\n\nDalší čeho bych se rád zbavil jsou `mysql_*` funkce a nahradil je PDO. To není úplně jednoduchý úkol a pořád je to \"in progress\". Zde jsem zvolil NDB, ale nejsem si tou volbou vůbec jistý. No a pak nastal čas, kdy je třeba přistoupit k hlubší integraci frameworku. To jsem chtěl udělat jako štít před celou aplikací. Tím jsem samozřejmě polovinu věcí rozbil, ale naštěstí už to tak nějak funguje. Co to vlastně znamená? V první řadě například startování aplikace z jednoho místa (což nebylo normální a rozbilo to všechno) a potom napsání LegacyPresenteru, který se stará o zpětnou kompatibilitu se starým jádrem (což zase rozbilo pseudoglobální kontext). No a potom bylo potřeba vyřešit také routování. To však ve výsledku bylo velmi triviální a stačilo napsat několik základních pravidel, za která se schová jakákoliv URL v systému. Jednoduchá implementace takového presenteru může vypadat třeba takto:\n\n/--code php\n//dodatečná nastavení ve startup()\n\npublic function renderDefault($fakePath = NULL)\n{\n    if (NULL !== $fakePath) {\n        if (file_exists($file = SITE_ROOT . DS . $fakePath)) {\n            require $file; //bacha na Local File Inclusion\n        }\n    }\n}\n\\--\n\nTato implementace vlastně kopíruje původní chování. Napsání routovacích pravidel je fakt jednoduché:\n\n/--code php\n$router[] = new Route(\'<? index(\\.html?|\\.php)>\', \'Legacy:default\', Route::ONE_WAY);\n$router[] = new Route(\'[<fakePath .+>]\', \'Legacy:default\');\n\\--\n\nMnohem zajímavější je však implementace Smarty šablonovacího systému. K tomu je vhodné napsat si vlastní implementaci render metody objektu \"Template\":https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.Template.php.html. Zde se rozhodne, jak se bude šablona vykreslovat. V mém případě jestli pomocí Latte, nebo Smarty. Je samozřejmě nutné upravit i TemplateFactory hlavně kvůli \"této řádce\":https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.TemplateFactory.php.html#56.\n\nŠpatné pořadí\n=============\nVšechno špatně. Teď vím, že jsem měl začít obráceně a nejdříve si na to napsat testy. Alespoň dodatečně (klasicky po prvním problému) jsem si na to ještě napsal jednoduché scénáře pro akceptační testy v Codeception. A pak jsem si měl stát za svým a neústupně odstranit všechny weird věci, protože ty prostě nejsou kompatibilní s moderním frameworkem a způsobuje to jen nepředvídatelné problémy.\n\nJsou vlastně nějaké výhody takové integrace frameworku do starého systému? Vyjma těch klasických, které přináší framework sám o sobě, je teď možné psát nové věci Nette stylem a využívat všechny možnosti (hlavně asi DIC a Latte). Se starým kódem se kromě vyčištění od hovadin vlastně zase až tak dít nic nebude a je možné jej přepisovat do nového kabátku. Osobně bych nejraději odstranil globální proměnné úplně, to je ale na tak velkém projektu skoro nemožné.\n\nNo a pak je zde psychická stránka věci. Jak se budou tvářit ostatní vývojáři až zjistí, že framework nemá jen pomáhat, ale i omezovat, aby programátor nedělal píčoviny? Najednou je programování náročnější. Spousta objektů, žádný `$GLOBALS`, dependency injection... Skvělé však je, že má takovýto úkol i svá nesporná pozitiva. Jedině zde budete pracovat s frameworkem skutečně po částech a tím spíš se nechají jednotlivé části poznat.\n\nMáte také nějaké zkušenosti s legacy projektem?',	'2015-08-30 15:16:00'),
(101,	'Crazy JavaScript PDF generator',	'Kdysi mi někdo řekl, že správný programátor by měl být tak trošku děvka pro všechno. Nestačí jen umět PHP. Nestačí jen umět JavaScript. S tímto názorem jsem od samého začátku souhlasil. Ostatně je to jeden z důvodů, proč se občas zajímám i o věci, které v nejbližší době nevyužiju a zase tolik jim nerozumím (také to podle toho pak vypadá). Jednou z takových věcí je \"React\":http://facebook.github.io/react/index.html. Nedávno jsem si hrál také s \"PhantomJS\":http://phantomjs.org/ a když už jsme u toho, tak ani \"NodeJS mi není cizí\":http://www.slideshare.net/MartinZlmal/nodejs-42314371. A co se stane, když se jednoho večera rozhodnete spojit všechno dohromady? Něco šíleného... (-:\n\nKrátké seznámení\n================\nVzhledem k tomu, že tento blog byl vždy zacílen spíše na začátečníky, bylo by vhodné jednotlivé projekty krátce přiblížit.\n\n\"React\":http://facebook.github.io/react/index.html vytvořený Facebookem se sám prezentuje jako knihovna pro stavění uživatelských rozhraní. V sekci \"Why React?\":http://facebook.github.io/react/docs/why-react.html se lze však dočíst zajímavější skorodefinici: *\"Many people choose to think of React as the **V** in MVC.\"* Celá myšlenka Reactu je postavená na komponentách. A já mám \"komponenty rád\":https://doc.nette.org/cs/components. Myslím si, že je to dobrý směr jak udržet v aplikaci chaos na rozumné úrovni. Než abych to zde však dlouhosáhle popisoval, doporučuji pojet si \"Getting Started\":http://facebook.github.io/react/docs/getting-started.html.\n\n\"PhantomJS\":http://phantomjs.org/ je oproti tomu úplně něco jiného. Jedná se o tzv. \"headless browser\" - velmi volně přeloženo prohlížeč bez grafického rozhraní. Je to takové Safari bez Safari. Prohlížeč, kterému úplně chybí (jinak pomalá) renderovací vrstva. Nejedná se tedy o prohlížeč, který by chtěl kdokoliv používat, ale spíše o nástroj, kterým lze skutečný prohlížeč nahradit třeba na serveru. Primárně se tedy používá pro testování aplikací, ve fantazii se však meze nekladou. Je tak možné např. tvořit screeny webů, nebo spouštět plně JavaScriptové stránky a koukat se na jejich obsah. Já jej začal používat kvůli rychlosti (oproti Seleniu), v tomto konkrétním případě však slouží právě pro spuštění čistě JavaScriptové stránky.\n\nNo a konečně \"NodeJS\":https://nodejs.org/en/ - JavaScriptové prostředí pro server. Zatímco ostatní jej využívají pro tvorbu aplikací, které jsou napsány v JS prakticky kompletně (server,  klient), já jej využíval kvůli svým vlastnostem spíše na rychlou komunikaci elektronika - server. To se mi na JS líbí. Dnes se nechají napsat i velmi složité věci pomocí pár řádek, ale třeba práce s časem a datumem bude vždy oser... (-:\n\nNěco šíleného\n=============\n[* e80e305e-8431-4c0e-9c79-5db761c22608/199aff3.jpg 300x? >]\n\nTo je tak když se sejde několik věcí najednou. Vytvořit si faktury, otestovat aplikaci, neustálý přirozený hlad po NodeJS. A pak to přišlo. Co si tak vytvořit \"generátor faktur\":https://github.com/mrtnzlml/js-invoice-generator, který bude samotnou fakturu stavět pomocí Reactu, server bude tvořit NodeJS a PDF budu generovat tak, že si tu stránku otevřu v PhantomJS a uložím (čímž snad získám velmi přesný výsledek)? Samozřejmě jsem se pokukoval i po již hotových řešeních jako je třeba \"Fakturiod\":https://www.fakturoid.cz/. A kdybych byl jen o kousek línější, tak bych asi nic takového netvořil. Nakonec jsem se však pouze inspiroval \"peckovým designem jedné z jejich faktur\":https://www.fakturoid.cz/blog/2015/08/25/nova-verejna-stranka-faktury (protože k designu mám asi tak daleko jako k Praze z Azor) s tím, že jí komplet napíšu znova pomocí komponent v Reactu a budu se modlit, aby to nikoho z Fakturoidu (až si tento článek přečte) neurazilo... (-:\n\nPrvním krokem bylo \"naškytnout samotný server\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/run.js. Zde bylo potřeba nastartovat ještě samotný PhantomJS pomocí \"child_process\":https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options. Mohl jsem to udělaj jakkoliv jinak, ale takovou opičárnu jsem si vždy chtěl vyzkoušet. Samotná příprava stránky pro PhantomJS je pak \"jednoduchá\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.js. Takže server funguje a PhantomJS běží. Co dál?\n\nChtělo by to něco co by šlo renderovat. Takové minimální rozumné HTML může vypadat fakt jednoduše:\n\n/--code html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <script src=\"react.js\"></script>\n</head>\n<body>\n    <div id=\"react-root\"></div>\n    <script src=\"build/index.js\"></script>\n</body>\n</html>\n\\--\n\nKde `react.js` je samotný React a `build/index.js` obsahuje definici komponent:\n\n/--code jsx\nvar LikeButton = React.createClass({\n	render: function () {\n		return (\n			<button>LikeButton</button>\n		);\n	}\n});\n\nReact.render(<LikeButton />, document.getElementById(\'react-root\'));\n\\--\n\nJe to fakt minimální, ale funkční kód, takže si to může vyzkoušet každý. Přechozí zápis samozřejmě není JavaScript, ale \"JSX\":https://facebook.github.io/jsx/, takže je třeba jej ještě přeložit (`jsx --watch src/ build/`). Výsledný kód je pak v tomto konkrétním jednoduchém případě velmi podobný:\n\n/--code javascript\nvar LikeButton = React.createClass({displayName: \"LikeButton\",\n	render: function () {\n		return (\n			React.createElement(\"button\", null, \"LikeButton\")\n		);\n	}\n});\n\nReact.render(React.createElement(LikeButton, null), document.getElementById(\'react-root\'));\n\\--\n\nPokud se vrátím zpět k faktuře, tak její HTML \"je také velmi jednoduché\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.html a celá sranda se odehrává \"zde\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js. Zde jsem si také schválně chtěl vyzkoušet, jak reálně funguje \"Inline Styles\":https://facebook.github.io/react/tips/inline-styles.html. Samotná faktura je tedy tvořena pouze krátkým HTML a pěknou kopou JavaScriptu. Žádné CSS. Abych řekl pravdu, tak se mi s tím moc dobře nepracuje, ale to je dáno spíše tím, že zase až tolik CSS nehovím a proto bylo místy komplikované přemýšlet nad tím jak funguje React a zároveň držet v hlavě to, jak má faktura nakonec vypadat. Koukal jsem se, jak se to řeší na jiných webech jedoucích na Reactu a asi se o zase až tak nepoužívá. Ale konec naříkání. Podívejte se \"na výsledek\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.pdf.\n\nQR kód\n======\nJeště bych se rád zaměřil na samotný QR kód, který je na faktuře (\"komponenta\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js#L246-L269). Použil jsem \"stejnou knihovnu\":https://larsjung.de/jquery-qrcode/, kterou používám zde na blogu v záhlaví (nejlepší). Protože se jedná o QR, tak se nedá čekat, že by obsahoval něco složitého (\"podrobný popis formátu\":http://qr-platba.cz/pro-vyvojare/specifikace-formatu/):\n\n/--code\nSPD*1.0*ACC:CZ4101000000123456789101+KOMBCZPPXXX*AM:2750.00*CC:CZK*MSG:PLATBA FAKTURY 2015-0001*X-VS:20150001\n\\--\n\nJe to takový hloupý \"RESP\":http://redis.io/topics/protocol. Řetězec začíná označením formátu `SPD*1.0*` a následuje vždy výčet položek `klíč:hodnota*`, které chceme do QR kódu dostat. Povinný je pouze `ACC`, což je IBAN, popř. IBAN+BIC. Následuje částka, měna, zpráva pro příjemce a variabilní symbol.\n\nTakže úkol někdy na příště. Přepsat **V** u blogu do Reactu? (-:',	'2015-10-03 12:54:28'),
(102,	'Ještě lepší struktura Nette aplikace',	'Každý, kdo postavil pár aplikací, musel vždy řešit ten samý problém. Jakou strukturu by měla aplikace mít? A co když se začne projekt rozrůstat? Měl bych se držet toho jak to dělá \"sandbox\":https://github.com/nette/sandbox (resp. \"web-project\":https://github.com/nette/web-project)? Postupem času jsem dokonvergoval k relativně přijatelnému výsledku a vzhledem k tomu, že projekt na kterém jsem to poprvé pořádně rozjel byl ukočen, \"rozhodl jsem se jej zveřejnit\":https://github.com/mrtnzlml/CMS-lite. Už je to sice nějaký čas, ale v době největšího vrcholu tohoto projektu jsem jej považoval za takovou osobní špičku. A to hned z několika důvodů. K tomu se ale dostanu postupně. A vezmu to pěkně od těch nejmenších částí.\n\nPresentery a komponenty\n=======================\nU presenterů se mi vlastně docela líbí jak to dělá sandbox. Ve složce presenterů jsou logicky presentery a také složka `templates`, která obsahuje šablony právě k těmto presenterům:\n\n/--code\npresenters/\n    templates/\n        Homepage/\n            default.latte\n        @layout.latte\n    BasePresenter.php\n    HomepagePresenter.php\n\\--\n\nDříve to bylo jinak. Šablony a presentery měl dříve sandbox na stejné úrovni, ale souhlasím s tím, že šablony patří spíše (a poměrně úzce) k presenterům. Je tedy nutné zmínit, že díky tomu jak je Nette framework chytrý, tak je v podstatě jedno jakou bude mít projekt strukturu, protože bude fungovat vše. Za chvíli se však začne vše nabalovat a bude třeba neustále udržovat pořádek. Proto je nutné mít jasno i v takto triviálních otázkách.\n\nKomponenty se od presenterů tolik neliší. Spíše naopak. Komponenty mohou být poměrně komplikované, ale rád je dělám co nejjednodušší. U komponent používám několik návrhů. Pro velmi triviální komponenty zachovávám plochou strukturu:\n\n/--code\nContactForm/\n    ContactForm.latte\n    ContactForm.php\n\\--\n\nJe totiž otrava vytvářet spoustu zbytečných složek. To platí i pro soubory. Proto jsou generované továrničky vždy k nalezení pod třídou komponenty v jednom a tom samém souboru. Jakmile se však komponenta jen o trošku zkomplikuje, automaticky přepínám do klasického presenterového stylu:\n\n/--code\nContactForm/\n    providers/\n        IContactFormTemplateProvider.php\n    templates/\n        ContactForm.latte\n    ContactForm.php\n\\---\n\nDobře, základní stavební kameny jsou položeny. Co by však mělo být okolo. A kde jsou vlastně položeny? Inu pojďme na to opět postupně.\n\nSupercore věci\n==============\nFakt nevím jak to nazvat jinak, protože ke core záležitostem se ještě dostanu. O co tedy jde? Jedná se o části aplikace, které tvoří to nejzákladnější jádro. Jádro, na které je pak možné napojovat další věci. Tuto část aplikace nechávám ve složce `app`:\n\n/--code\napp/\n    AdminModule/\n        presenters/ <-- viz první ukázka (je zde jen BasePresenter)\n    AuthModule/\n        presenters/ <-- jen SignPresenter\n    FrontModule/\n        presenters/ <-- viz první ukázka (Base, Contact, Homepage)\n    components/\n        ContactForm/ <-- také už známe (viz druhá ukázka)\n        AControl.php\n    config/\n    extensions/\n    bootstrap.php\n\\--\n\nJak je vidět, tak všechny moduly obsahují jen kritický základ. Žádné další presentery. Tak kde je zbytek? Zbytek se nechází v rootu aplikace, konkrétně ve složkách `custom` a `src`. Je celkem jedno jaký je název těchto složek, vtip je v tom nějaké mít a vše sem přesunout. Důvod proč jsou dvě je prostý. Zatímco v `src` jsou části aplikace, které tvoří jádro (tedy spoustu funkčnosti), v `custom` jsou velmi podobné částí aplikace, bez kterých lze však žít. Původní myšlenka byla taková, že se pak custom složka zruší a vše v ní se velmi elegantně rozpadne na composer balíčky. Obě složky jsou však strukturálně stejné, proto budeu řešit jen `custom`.\n\nBusiness logika\n===============\nOk, to jsem také nazval pěkně debilně. Alespoň však vysvětlím jednu důležitou věc, se kterou jsem v začátcích bojoval a kterou je potřeba se odnaučit. Sadbox vždy totiž vedl k takovéto podobné struktuře:\n\n/--code\napp/\n    config/\n    forms/\n    presenters/\n    model/\n    router/\n\\--\n\nTo nikomu nemám za zlé. Je to jednoduše pochopitelné a to je dobře. Takže s tím vlastně spíš souhlasím. Problém je v tom, že u rozrůstající aplikace už to začíná být děsný mrdník, protože `presenters` najednou obsahují všechny presentery a `model` obsahuje všechnu logiku. Ale v tom aby se prase vyznalo. Tento efekt se nechá trošku umírnit rozdělením aplikace na moduly a s tím už jsem byl (a vlastně do dneška jsem) spokojen. Jenže co s tím modelem? Fuck model! Rozdělte si model podle logických částí, které na sobě nejsou závislé a vše oddělte. Třeba takto:\n\n/--code\ncustom/\n    Error/\n    Eshop/\n    Files/\n    Notes/\n    Pages/\n\\--\n\nJak řekl kdosi moudrý, existují dva nejnáročnější problémy v programování a to správná invalidace cache a pojmenovávání věcí. Naprosot s tím souhlasím. Moc mi to nejde, ale mělo by být zřejmé, že jsou zde části, které se starají (výhradně) o eshop, o poznámky, stránky atd. Pojďme se tedy zanořit hlouběji:\n\n/--code\nPages/\n    AdminModule/\n        presenters/\n            CategoryPresenter.php\n            PagePresenter.php\n    components/\n        PageForm/\n        PagesGrid/\n    DI/\n    FrontModule/\n    listeners/\n    Category.php\n    Page.php\n    ...\n\\--\n\nA voilà, máme tu zase strukturu složky `app`. Nebo alespoň její obdobu. A v tom je síla toho návrhu. Mělo by už teď být jasnější, proč jsou v `app` právě ty věci co tam jsou. Celém vždy bylo mít v systému místa, které obsahují velmi podobné věci, ale nic dalšího. Drobné niance se zde najdou, to je jasné, ale základ zůstává. Jenže jak to sakra funguje?\n\nJak to sakra funguje\n====================\nPrávě teď je ten správný čas \"proklikat si celý systém\":https://github.com/mrtnzlml/CMS-lite. Je zřejmé, že už je to trošku komplikovanější a samo od sebe to fungovat nemůže (ani to není žádoucí). Zkušenější už tuší, že celé kouzlo je ve složce `DI`. Zde je tedy mé další doporučení. Až rozsekáte aplikaci do komponent, udělejte to samé s funkcionalitou. A víte co, udělejte to se vším co spolu nějak logicky souvisí. Proto jsem do složky `custom/Pages` umístil vše co patří ke stránkám. Komponenty, doctrine entity, servisní třídy, fasády, ale také presentery. Prostě všechno. Dělejte to tak dlouho, dokud v `app` nezůstane nic.\n\nTento způsob však s sebou nese celou řadu úskalí. Prvně je to komplikované. A pak je třeba vše napojit. Existují dva způsoby, které mi přijou v pořádku. První je poněkud agresivní, ale jednoduchý. Vychází vlastně z myšlenky \"Flame\\Modules\":http://flame-org.github.io/Modules/. Napíšete si nějaké rozšíření, které bude implementovat nějaký interface. Třeba `IFaviconProvider`. Pak je třeba mít (právě v supercore) rozšíření, které takový interface najde a při vytváření DIC zpracuje. Hodně toho využívají šablony (`custom/Versatile/DI/VersatileExtension.php`). Nebezpečí je však v tom, že se to prostě stane jakmile přidáte toto rozšíření do aplikace. Není zde moc rozumná možnost jak třeba rozšíření deaktivovat. A ještě komplikovanější je pak při vytváření DIC přeba automaticky spustit nějaký SQL dotaz.\n\nProto je zde druhý způsob (který jsem pořádně nestihl dodělat). Využívá jej například `\\Eshop\\DI\\EshopExtension`. To implementuje `ICustomExtension`. Jiné (supercore) rozšíření se toho chytí a udělá pouze to, že jej zobrazí v administraci včetně potřebných odadtečných informací. Stejně tak jako to dělá WordPress. Uživatel zde může kliknutím modul nainstalovat, což se přesně u eshopu děje a spustí se tak celá řada komplikovaných operací, které tento modul nainstalují. Jedná se zejména o předání URL adres, nastavení ACL, zaregistrování položek do menu atd. Elegantně se tak celý systém připraví a díky tomu, že dojde k registraci do DIC, není důvod k tomu, aby se s narůstajícím počtem modulů systém nějak dusil. Prostě se chová jako jakákoliv jiná velká aplikace. Nic není hledáno a řešeno dynamicky za běhu aplikace. Druhý krok je už pak dodělat instalace modulů ze vzdáleného repozitáře, ale to už je jednoduchý úkol.\n\nA je to. Elegantní instalační systém pluginů pro vaší Nette aplikaci.\n\nDalší zajímavé vlastnosti systému\n=================================\nTakže to máme peckovou strukturu aplikace, kterou je velmi jednoduché udržovat a rozšířovat + automatickou registraci modulů (pluginů chcete-li). A to jsem teprve na začátku. Proto už jen bodově vypíchnu a připomenu některé zajímavé věci, které všem dávám k dispozici.\n\n1) Každé rozšíření je v Nette nutné registrovat do konfiguračního souboru. To by s tím ale nešlo nělat takové švíky. Proto jsem napsal `\\App\\Extensions\\CoreExtension`, které to dělá automaticky. Není to zrovna ukázka čistého kódu, ale svůj účel to plní dobře. Už touto vlastností jste několik mil před konkurencí... (-:\n2) Vzpomínáte si na \"Hierarchický router\":http://zlml.cz/hierarchicky-router? Tak i ten je zde v celé své kráse. Jen pro připomenutí. Je možné měnit si URL adresy jak chcete, nikdy nepřijdete o ty staré a výkonově to nestojí nic navíc.\n3) \"Dynamické routování URL adres\":http://zlml.cz/dynamicke-routovani-url-adres. To je další fičura, kterou jen tak někdo nemá. Nebo snad ano? Použijte ji. Vybudujte něco úžasného.\n4) A co takhle Fixtures. \"Vzpomínáte si\":http://zlml.cz/fixnete-si-databazi?\n5) Všimněte si, že hodně rozšíření obsahuje jakési providery. Je tak možné jednoduše třeba zaměnit šablonu kontaktního formuláře, nebo navigace. Obdobně mohou rozšíření registrovat vlastní styly i javascriptové skripty.\n6) K dispozici jsou Doctrine migrace. K dispozici jsou v nabídce přes `php index.php`. Samotné migrační skripty jsou pak v `migrations` složce.\n\nJe toho fakt ranec, co pouštím na obdiv i kritiku. Proto ještě stručněji přehled technologií, které v projektu naleznete:\n\n- grunt + grunt-contrib packages (concat, copy, cssmin, less, uglify)\n- bootstrap, nette.ajax.js, nette-forms, jquery, selectize\n- nette (application, caching, DI, finder, forms, robot-loader, security, utils, ...)\n- latte, tracy, texy, webloader, minify, faker, secured-links\n- kdyby (doctrine, annotations, console, events, translation, autowired, monolog, ...)\n- doctrine (data-fixtures, migrations, ORM, ...)\n- testbench, nette\\tester\n\nA to jsem zde ještě nenapsal vše. Mrkněte se na náhled, nejedná se jen o nějaký marný pokus:\n\n[* 9b3c176d-4884-45c5-95c3-53cac2999d0f/admin.png *]\n\nInstalace systému\n=================\nBohužel jsem nevychytal všechny mouchy, půlka věcí zůstala nerozdělána a celý materiál je spíše pro inspiraci. Pokud by si to však někdo chtěl rozjet, dávám k dispozici také poněkud složitější návod na instalaci (viz readme):\n\n- Nainstalujte si \"GIT\":http://git-scm.com/\n- `git clone https://github.com/mrtnzlml/CMS-lite.git`\n- Nainstalujte si \"Composer\":http://getcomposer.org/\n- `composer install` (natáhne PHP závislosti)\n- Vytvořte si prázdnou MySQL databázi\n- Přejmenujte `config.local.neon.dist` (v app/config) na `config.local.neon` a nastavte přístupové údaje k databázi\n- `php index.php orm:schema-tool:create` (vygeneruje strukturu databáze)\n- `php index.php cms:fixtures:load` (našte základní data, teď už by měla aplikace fungovat)\n- Nainstalujte si \"Bower\":http://bower.io/, popř. \"npm\":https://www.npmjs.com/ je-li třeba\n- `bower install` (fetches JS dependencies)\n- Nainstalujte si \"Grunt\":http://gruntjs.com/\n- `grunt` (připraví JS, CSS, fonts, ...)\n\nKaždý příkaz by měl být spouštěn z rootu webu. Výjimku tvoří příkazy obsahující `index.php`. Ty je třeba spouštět ze složky `www`. To dá asi rozum.\n\nA na závěr. Jsem realista. Nepředpokládám, že by se projektu někdo doprovolně chytil a nakopl mě, aby v něm pokračoval aktivněji. Zatím jej spíš nikdo nepochopil a musel jsem si protrpět i pár klacků pod nohama. Proto jej dávám k dispozici jako inspiraci pro ostatní. Nemám strach, že by si to někdo přivlastnil, nebo na tom zbohatl. To si spousta firem (lidí) neuvědomuje a tak nikdo raději nezveřejňuje nic. Zveřejňujte, předávejte znalosti - nepřijdete o ně. Nicméně v rámci gentlemanské dohody bych rád vyměnil své předané znalosti za hvězdičku u tohoto nového repozitáře. Nic víc nežádám.\n\n<iframe src=\"https://ghbtns.com/github-btn.html?user=mrtnzlml&repo=CMS-lite&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"160px\" height=\"30px\"></iframe>\n\nPokorně děkuji.',	'2015-10-11 16:28:04'),
(103,	'Od indexu až po presenter',	'Když jsem se učil pracovat s Nette Frameworkem, musel jsem v začátcích hodně přivírat oči a říkat si \"prostě to tak je\". Hodně věcí bylo zahaleno do tmy. Teď už to tak naštěstí není, ale stále se stává, že mi někdo napíše a děkuje za poodhalení a vysvětlení toho, jak to funguje na pozadí (za což zase děkuji já). Pokusím se tedy pokračovat a vrátím se na úplný začátek - do `index.php` a poodhalím, jak probíhá start takové běžné aplikace. A jako vždy - co nejjednodušeji.\n\nZodpovím (nebo alespoň nastíním odpovědi na) následující otázky:\n- proč redirect vyvolává AbortException\n- jak napsat vlastní NanoPresenter\n- proč má Nette dva request objekty\n- kde se bere životní cyklus presenteru\n\nStart aplikace\n==============\nNedávno jsem dostal v práci na starost implementovat Nette do jednoho legacy projektu. Už jsem tu o tom \"psal\":http://zlml.cz/navrhovy-vzor-legacy-code. Byl to nesmírně vyčerpávající úkol, ale už mám hotovo a jsem ve fázi nekonečného refaktoringu. Jednou z prvních věcí, které bylo nutné vyřešit byl start aplikace z jednoho místa. Toto naštěstí řeší \"web-project\":https://github.com/nette/web-project (nebo \"sandbox\":https://github.com/nette/sandbox chcete-li) už v základu takto (`.htaccess`):\n\n/--code\n<IfModule mod_rewrite.c>\n	RewriteEngine On\n\n	RewriteCond %{REQUEST_FILENAME} !-f\n	RewriteCond %{REQUEST_FILENAME} !-d\n	RewriteRule !\\.(pdf|js|ico|gif|jpg|png|css|rar|zip|tar\\.gz|map)$ index.php [L]\n</IfModule>\n\\--\n\nČímž se velmi rychle dostáváme k prvnímu bodu, kterým je `index.php`:\n\n/--code php\n/** @var \\Nette\\DI\\Container $container */\n$container = require __DIR__ . \'/../app/bootstrap.php\';\n/** @var \\Nette\\Application\\Application $application */\n$application = $container->getByType(\\Nette\\Application\\Application::class);\n$application->run();\n\\--\n\nV tomto souboru vše začíná a také končí. Totiž zavolá se ještě minimálně `\\Tracy\\Debugger::shutdownHandler`, `\\Nette\\Http\\Session::clean` a `\\Nette\\Http\\Response::__destruct`, ale zůstaňme u toho, že zde vše začíná a také končí. O co v indexu vlastně jde? Hned přeskočím první řádku, ačkoliv se jedná o nezanedbatelnou část. Z bootrapu získáme hotovou instanci \"DIC\":https://doc.nette.org/cs/2.3/dependency-injection, resp. přímého potomka. Následuje vytažení \"Application\":https://api.nette.org/2.3.7/Nette.Application.Application.html a naškytnutí aplikace pomocí metody `run`. To je předpokládám všem jasné, proto jsem to vzal letem světem. Cílem tohoto článku je však popsání právě `run` metod.\n\nRun, run!\n=========\nMetoda `\\Nette\\Application\\Application::run` vypadá přesně takto:\n\n/--code php\npublic function run()\n{\n    try {\n        $this->onStartup($this);\n        $this->processRequest($this->createInitialRequest());\n        $this->onShutdown($this);\n    } catch (\\Exception $e) {\n        $this->onError($this, $e);\n        if ($this->catchExceptions && $this->errorPresenter) {\n            try {\n                $this->processException($e);\n                $this->onShutdown($this, $e);\n                return;\n            } catch (\\Exception $e) {\n                $this->onError($this, $e);\n            }\n        }\n        $this->onShutdown($this, $e);\n        throw $e;\n    }\n}\n\\--\n\nPro přehlednost to ještě zjednoduším a vyhodím vše, co pro samotné spuštění aplikace není nezbytně nutné:\n\n/--code php\npublic function run()\n{\n    try {\n        $this->processRequest($this->createInitialRequest());\n    } catch (\\Exception $e) {\n        if ($this->catchExceptions && $this->errorPresenter) {\n            $this->processException($e);\n            return;\n        }\n        throw $e;\n    }\n}\n\\--\n\nMoc toho opět nezbylo. Vlastně se zde dějí jen tři věci. Prvně \"createInitialRequest\":https://api.nette.org/2.3.7/source-Application.Application.php.html#102-124. Tato metoda vrátí (jak už název napovídá) tzv. aplikační request. To je objekt, který pak putuje celou aplikací a nese si informaci o tom co vlastně uživatel chce. Vzpomínáte si na článek o \"dynamickém routování URL adres\":http://zlml.cz/dynamicke-routovani-url-adres? Tam jsem ukazoval, jak se HTTP request změní právě na aplikační a zpět. Celá sranda se tedy odehrává někde v RouterFactory (zatím to platí, do budoucna ale \"nebude\":https://github.com/nette/routing/commit/e802a85e96f5814ddf1a16ea1517398eb560bab6). Samotný HTTP request se pak dostane do `Application` díky DI. Už v `createInitialRequest` je tedy jasné, jestli je možné požadavek přeložit, nebo 404. Pokud 404, tak konec, resp. `processException` pokud je to v configu zapnuté (což jinými slovy znamená forward na error presenter):\n\n/--code neon\napplication:\n    catchExceptions: yes\n\\--\n\nPokud se však povede získat aplikační request, nastupuje funkce `processRequest`. Mrkněte na \"implementaci\":https://api.nette.org/2.3.7/source-Application.Application.php.html#127-150. Opět se nejedná o nic složitého. Jde zde vlastně jen o jedinou věc. Získat presenter a zavolat nad ním `run`. Proč `run`? Presenter totiž není potomek `\\Nette\\Application\\UI\\Presenter` jak si pamatují skoro všichni, ale spíše objekt, který implementuje interface `\\Nette\\Application\\IPresenter` jehož jedinou metodou je právě `run` do které se jako jediný parametr předává již zmíněný aplikační request. Zároveň musí tato metoda vracet `\\Nette\\Application\\IResponse`.\n\nZ toho plyne, že pokud potřebujeme velmi jednoduchý presenter (který skoro nic neumí, ale je rychlý), stačí si implementovat `IPresenter` rozhraní a hotovo:\n\n/--code php\nclass NanoPresenter extends Nette\\Object implements Nette\\Application\\IPresenter\n{\n\n	public function run(Nette\\Application\\Request $appRequest)\n	{\n		return new Nette\\Application\\Responses\\TextResponse(\'It works!\');\n	}\n\n}\n\\--\n\nV běžném presenteru se toho však děje samozřejmě mnohem více. Právě v metodě `run` se schovává celý dobře známý životní cyklus presenteru. Než se však dostanu k reálnému příkladu, začnu na tomto jednoduchém. `NanoPresenter` vrací pouze `TextResponse` s obyčejným textem. Tato odpověď je předána zpět do `processRequest` a následně je hned zavoláno `\\Nette\\Application\\IResponse::send` což v tomto konkrétním případě vyústí v obyčejné echo. Co se však děje v běžném presenteru?\n\nVykreslení šablony\n==================\nPresenter, který dědí od `\\Nette\\Application\\UI\\Presenter` dělá téměř to samé. Jediný rozdíl je v tom, že presenter vlastně vykreslitelná komponenta, takže si vezme šablonu a předá ji stejně jako v předchozím případě do `TextResponse`. Zde je oproti mému `NanoPresenter` příkladu malý implementační rozdíl, ale ve výsledku presenter tak jako tak `TextResponse` vrátí zpět `Application` objektu do `processRequest` metody. Dále se opět zavolá `\\Nette\\Application\\Responses\\TextResponse::send`, tentokrát však nedojde k obyčejnému echu, ale spustí se renderování předané šablony (`\\Nette\\Application\\UI\\ITemplate`). Většinou to tedy propadne na Latte, ale to samozřejmě není podmínkou.\n\n/--code php\npublic function send(Nette\\Http\\IRequest $httpRequest, Nette\\Http\\IResponse $httpResponse)\n{\n    if ($this->source instanceof Nette\\Application\\UI\\ITemplate) {\n        $this->source->render();\n    } else {\n        echo $this->source;\n    }\n}\n\\--\n\nZ předchozího textu by mělo být zřejmé, kudy požadavek putuje. Když si prohlédnete detailněji to co jsem zde popsal, mělo by být jasné, že se interně používá `\\Nette\\Application\\AbortException` a proto je nebezpečné v presenterech chytat bezmyšlenkovitě všechny výjimky. Nikdo pak nechce řešit \"proč to Nette zase nepřesměrovává\".\n\nTento text by měl překlenout tu temnou propast mezi `index.php` a akcí v presenteru. Příště už se snad vrhnu na něco zajímavějšího... :)',	'2015-11-15 19:24:04'),
(104,	'Znovupoužitelné části formuláře',	'Před nějakým časem jsem psal o tom, jak vytvořit \"znovupoužitený formulář\":http://zlml.cz/znovupouzitelny-formular. Nejedná se o nic jiného, než o správné navržení a následné použití komponent, tedy potomků `UI\\Control`. Pokud bych měl být upřímný, nemyslím si, že se formuláře nějak často na webu opakují a osobně tento princip používám spíše pro oddělení části aplikace do samostatného balíčku. Tím spíš najde následující ukázka méně použití. Právě mám totiž za úkol navrhnout předělání jedné administrace. Úkolem není hledět na to, jak moc je tento přístup špatný, ale navrhnout řešení, které nahradí stávající 1:1. Tato administrace obsahuje často se opakující (a velmi rozsáhlý) formulář, který se skládá z několika karet. Navíc některé části formuláře spolu vůbec nesouvisí a na každé stránce je formulář trošku jiný (i když je podobnost zřejmá). Vzhledem k tomu, že se jedná o tak rozsáhlý kód, upustil jsem od znovupoužitelného formuláře a navrhnul jsem znovupoužitelné pouze jeho části. A na následujících řádcích nastíním jak.\n\nNa začátku stála komponenta\n===========================\nPořád platí, že je samotný formulář komponenta. Na tom se nic nemění. V mém případě se však hodilo udělat si ještě nějaké bázové třídy. Pokusím se ukázky ořezat co nejvíce od zbytečností tak, aby to pokud možno ještě dávalo smysl:\n\n/--code php\nclass NewsForm extends BaseControl {\n\n	/** @var News|NULL */\n	private $news;\n\n	public function __construct($news) {\n		parent::__construct();\n		$this->news = $news;\n	}\n\n	public function render() {\n		$this->template->render(__DIR__ . \'/NewsForm.latte\');\n	}\n\n	protected function createComponentNewsForm() {\n	    $form = $this->form;\n	    // nastavení společných prvků formuláře\n	    return $form\n	}\n\n}\n\\--\n\nK tomu (třeba) nějaká ta generovaná továrnička a komponenta tak jak ji známe všichni je hotova. Bude však nutné rozklíčovat, co se děje třeba pod třídou `BaseControl`. Jedná se o jednoduchého předka, který krom dalších věcí obsahuje hlavně toto:\n\n/--code php\nabstract class BaseControl extends UI\\Control {\n\n	/** @var BaseForm */\n	protected $form;\n\n	public function __construct() {\n		parent::__construct();\n		$this->form = new BaseForm;\n	}\n\n	protected function attached($obj) {\n		parent::attached($obj);\n		if ($obj instanceof UI\\Presenter) {\n			$this->form->addComponent(new SubmitButtonsContainer, \'submitButtons\');\n			$this->form->addComponent(new AnotherContainer, \'another\');\n		}\n	}\n\n}\n\\--\n\nZde se vytvoří nějaký formulář (s kterým pak pracuji v komponentě) a po připojení formuláře k presenteru se připojí i nějaké formulářové kontejnery. Než se však k těmto kontejnerům dostanu, tak by bylo dobré prozradit i co se děje v třídě `BaseForm`. Popravdě nic moc:\n\n/--code php\n/**\n * @method addTinyMCE($name, $label = NULL, $cols = NULL, $rows = NULL)\n */\nclass BaseForm extends UI\\Form {\n\n	/** @var callable[] */\n	public $onSaveAndStay;\n\n	/** @var callable[] */\n	public $onSaveAndExit;\n\n	/** @var callable[] called BEFORE onClick event */\n	public $onSuccess;\n\n	public function __construct() {\n		parent::__construct();\n		$this->addProtection();\n	}\n\n}\n\\--\n\nNastavím si zde nějaké věci, které jsou pro každý formulář v administraci obecně společné. Konkrétně tedy CSRF ochranu a pár polí pro události. Události jsem si zde musel nadefinovat sám, běžně se na formuláři volá `onSuccess` událost až po `onClick` (\"link\":https://api.nette.org/2.3.7/source-Forms.Form.php.html#380-420), ale zrovna zde jsem to potřeboval obráceně. Hodí se to v okamžiku, kdy chci využívat `onSuccess`, ale v `onClick` už z formuláře třeba přesměrovávám pryč. Vzhledem k tomu, že oba eventy se volají jen při validním odeslání, tak to ničemu nevadí. V této třídě je také vhodné místo pro umístění nějakých dynamických metod do anotací, aby je IDE dobře napovídalo (viz `addTinyMCE`). Byl to dlouhý úvod, ale vše je připraveno a můžeme se vrhnout na kontejnery.\n\nFormulářové kontejnery\n======================\nOsobně \"formulářové kontejnery\":https://pla.nette.org/cs/dedicnost-vs-kompozice nemám moc rád. Jsou sice super, ale pohybují se na další úrovni formuláře. Pokud se však s tímto faktem smíříme (a nejlépe z něj uděláme výhodu), pak jsou docela super a zde se skvěle hodí. Můžu si pěkně oddělit například odesílací tlačítka a ty pak vesele používat ve všech formulářích:\n\n/--code php\nclass SubmitButtonsContainer extends BaseFormContainer {\n\n	private $form;\n\n	public function attached($obj) {\n		parent::attached($obj);\n		if ($obj instanceof BaseForm) {\n			$this->form = $obj;\n			$obj->onSuccess[] = function (BaseForm $form) {\n				$path = $this->lookupPath(BaseForm::class);\n				dump($form->getValues()->$path); // další zpracování hodnot\n			};\n		}\n	}\n\n	public function render() {\n		$this->template->_form = $this; // kvůli formulářovým makrům v šabloně\n		$this->template->render(__DIR__ . \'/SubmitButtonsContainer.latte\');\n	}\n\n	protected function configure() {\n		$this->addSubmit(\'saveAndStay\', \'Uložit a zůstat\')->onClick[] = function (SubmitButton $button) {\n            $form = $button->getForm();\n            $this->form->onSuccess($form, $form->getValues());\n            $this->form->onSaveAndStay($form, $form->getValues());\n		};\n	}\n\n}\n\\--\n\nPokud sledujete fórum, tak vám je tento návrh jistě povědomý. Jedná se o \"slavné řešení pod čarou\":https://forum.nette.org/cs/11747-skladani-komponent-a-formulare#p84652. Přesně toto se odehrává v rodičovské třídě `BaseFormContainer`. Doplnil jsem si do této třídy však jednu malou vychytávku. Chtěl jsem totiž, aby každý kontejner mohl mít vlastní šablonu. To běžně není možné. Kontejner tedy mohu vykreslovat pomocí dobře známého makra `{control ...}` (což nedělá nic jiného, než že se zavolá metoda `render`). Jenže co je `$this->template`? Bázový kontejner jsem musel rozšířit ještě o vhodnou část z `UI\\Control`, která se stará o vykreslování:\n\n/--code php\nabstract class BaseFormContainer extends Forms\\Container {\n\n	/** @var UI\\ITemplateFactory */\n	private $templateFactory;\n\n	/** @var UI\\ITemplate */\n	private $template;\n\n    public function injectTemplateFactory(UI\\ITemplateFactory $templateFactory) {\n		$this->templateFactory = $templateFactory;\n	}\n\n	abstract public function render();\n\n    public function getTemplate() {\n		// bla bla, mrkni na: https://api.nette.org/2.3.7/source-Application.UI.Control.php.html#45\n		return $this->template;\n	}\n\n	protected function createTemplate() {\n		/** @var UI\\ITemplateFactory $templateFactory */\n		$templateFactory = $this->templateFactory ?: $this->lookup(UI\\Presenter::class)->getTemplateFactory();\n		return $templateFactory->createTemplate(NULL);\n	}\n\\--\n\nJednoduché vykreslitelné formulářové kontejnery. Cool. Abych to rychle zrekapituloval. Máme jednoduchou komponentu na formulář, která dědí od `BaseControl`. Tato třída připojuje ve vhodný čas formulářové kontejnery, které se umí vykreslit (což běžně nejde).\n\nV šabloně `SubmitButtonsContainer.latte` je možné používat normálně `{input ...}` makra a další, jako kdybych pokračoval dál v šabloně jednoho velkého formuláře. Samotné připojené formulářové kontejnery je možné vykreslovat pomocí klasického makra `{control newsForm-submitButtons}` v hlavním formuláři. To je možná trošku nevýhoda, protože kontejnery se připojují do formuláře a stávají se tak podkomponentou. Musím tedy control makro volat stylem *rodič-podkomponenta*.\n\nZnovupoužitelnost vykreslitelných kontejnerů\n============================================\nKde je ta znovupoužitelnost? Jak bych udělal to, že použiju třeba odesílací tlačítka (nebo jakoukoliv jinou část formuláře) někde jinde? Jednoduše. Prostě vytvoříme formulář (to je podmínka nutná) a kontejner v něm použijeme:\n\n/--code php\nprotected function createComponentTest() {\n    $form = new UI\\Form;\n    $form->addComponent(new AnotherContainer, \'another\');\n    $form->addSubmit(\'odeslat\', \'Odeslat\');\n    $form->onSuccess[] = function ($_, ArrayHash $values) {\n        dump($values);\n    };\n    return $form;\n}\n\\--\n\nK tomu třeba nějaká taková šablona:\n\n/--code\n{form test}\n    {control test-another}\n    {input odeslat}\n{/form}\n\\--\n\nFormulář se samozřejmě vykreslí i při obyčejném `{control test}`, ale bez šablony kontejneru (píšu si nápad na vylepšení). Vlastně je ta myšlenka docela jednoduchá, že? Jen je třeba dát pozor na to, že kontejner takto umisťuje formulářové prvky na jinou úroveň.\n\nMalá poznámka na závěr, která je sice mimo, ale může se hodit. Občas je potřeba zajistit si někde inject závislostí, ale z nějakého důvodu je to problematické. Může se jednat třeba o závislost v abstraktní rodičovské třídě. V takovém případě je možné v configu nastavit \"decorator\":https://github.com/dg/nette-di/blob/master/tests/DI/DecoratorExtension.basic.phpt:\n\n/--code neon\ndecorator:\n	BaseFormContainer:\n		inject: on\n\\--\n\nPříště se podíváme znovu na \"Dependent select box\":http://zlml.cz/dependent-select-box. Původní článek si totiž zaslouží důkladnou revizi a po krátké anketě jsem byl přesvědčen, že bude lepší napsat nový článek a podívat se na celý problém podrobněji.',	'2015-11-24 23:46:16');

DROP TABLE IF EXISTS `pages`;
CREATE TABLE `pages` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` longtext COLLATE utf8_unicode_ci NOT NULL,
  `slug` longtext COLLATE utf8_unicode_ci NOT NULL,
  `body` longtext COLLATE utf8_unicode_ci NOT NULL,
  `date` datetime NOT NULL,
  `draft` tinyint(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;


DROP TABLE IF EXISTS `pictures`;
CREATE TABLE `pictures` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uuid` varchar(40) NOT NULL,
  `name` varchar(255) NOT NULL,
  `created` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `pictures` (`id`, `uuid`, `name`, `created`) VALUES
(1,	'2139a61c-efc4-4e3c-b630-5c3cbf9258df',	'qrcode-ahoj.png',	'2014-07-12 16:54:26'),
(2,	'0ed74ba7-ddec-40da-ab12-4e6b8d82103c',	'qrcode-decode.png',	'2014-07-12 16:54:26'),
(3,	'63e85abb-b86a-4877-9640-fb70b4cd2542',	'qrcode-important.png',	'2014-07-12 16:54:27'),
(4,	'312d5904-ab94-4877-9743-8ec902fbc50a',	'qrcode-parts.png',	'2014-07-12 16:54:27'),
(5,	'3951a3ea-5f53-4af9-9c01-a45fd71dd5b0',	'qrcode-unmasked.png',	'2014-07-12 16:54:28'),
(6,	'1fc11f25-abc2-453e-abb4-adb31d0ccf17',	'datamatrix.png',	'2014-07-12 17:04:53'),
(7,	'0dd271b6-21ea-4c3c-a447-723b76257b50',	'datamatrix-key.png',	'2014-07-12 17:04:54'),
(8,	'76028c59-4e5f-42f4-a411-3452844a30d2',	'last.png',	'2014-07-12 17:04:54'),
(9,	'd10561e0-aeec-4dae-a21e-17eb7c4ca36d',	'gif.gif',	'2014-07-17 21:54:31'),
(10,	'393212dc-381f-4b3a-a06c-fb5d33d6dc29',	'workflow.png',	'2014-08-01 21:35:34'),
(11,	'ddfc321c-2190-4cf6-98a9-89852713e626',	'vystrizek.png',	'2014-10-15 22:08:14'),
(12,	'f34b6d82-9aaf-4089-afe6-81993d596885',	'stm32.png',	'2014-10-18 22:50:40'),
(13,	'1bb55605-d567-4fe0-b1d1-69e921940e0d',	'heatmap1.png',	'2014-10-25 14:47:45'),
(14,	'79b1a8e3-1efc-42b0-bb79-3409b9acd49d',	'3d.png',	'2014-10-25 15:11:31'),
(15,	'40a97326-5410-4385-821c-62dc8542387a',	'3d2.png',	'2014-10-25 15:16:31'),
(16,	'51d212f2-5aa9-44b9-9085-f6267e1974e9',	'vystrizek.png',	'2014-11-01 19:22:13'),
(17,	'c2a92f3c-204e-4a4c-9a0f-12e52f9ea4d3',	'speedy-obhajoba.png',	'2015-06-23 14:22:26'),
(18,	'9ab04acb-febc-4901-aaad-5b554f77e529',	'vystrizek.png',	'2015-07-05 13:26:08'),
(19,	'd6ca5ea3-5c1a-43af-8488-73d4fae836f1',	'strip-wordpress-550-finalenglish.jpg',	'2015-08-30 14:36:23'),
(20,	'e80e305e-8431-4c0e-9c79-5db761c22608',	'199aff3.jpg',	'2015-10-03 12:48:17'),
(21,	'9b3c176d-4884-45c5-95c3-53cac2999d0f',	'admin.png',	'2015-10-11 16:23:04');

DROP TABLE IF EXISTS `pictures_ext`;
CREATE TABLE `pictures_ext` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uuid` varchar(40) COLLATE utf8_unicode_ci NOT NULL,
  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `created` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;


DROP TABLE IF EXISTS `pingbacks`;
CREATE TABLE `pingbacks` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


DROP TABLE IF EXISTS `posts`;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `slug` text NOT NULL,
  `body` text NOT NULL,
  `date` datetime NOT NULL,
  `draft` tinyint(1) NOT NULL,
  `publish_date` datetime NOT NULL,
  `disable_comments` tinyint(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts` (`id`, `title`, `slug`, `body`, `date`, `draft`, `publish_date`, `disable_comments`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'asymetricka-sifra-s-verejnym-klicem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\n\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\n\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\n\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\n\n/--code\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\n\\--\n\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58',	0,	'0000-00-00 00:00:00',	0),
(3,	'Lovec matematik',	'lovec-matematik',	'Znáte následující hádanku?\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\n\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\n\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\n\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26',	0,	'0000-00-00 00:00:00',	0),
(4,	'Tabulkový masakr',	'tabulkovy-masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12',	0,	'0000-00-00 00:00:00',	0),
(6,	'Výpočet mediánu',	'vypocet-medianu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39',	0,	'0000-00-00 00:00:00',	0),
(7,	'Osm návrhových přikázání',	'osm-navrhovych-prikazani',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14',	0,	'0000-00-00 00:00:00',	0),
(9,	'Návrhový vzor Singleton',	'navrhovy-vzor-singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--',	'2012-12-26 20:38:01',	0,	'0000-00-00 00:00:00',	0),
(10,	'Návrhový vzor Factory Method',	'navrhovy-vzor-factory-method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://zlml.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39',	0,	'0000-00-00 00:00:00',	0),
(11,	'Nette 2.1-dev CliRouter',	'nette-2-1-dev-clirouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem <code>php index.php</code>. Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze <code>php index.php Front:Homepage:default</code>.',	'2013-03-17 22:02:36',	0,	'2015-07-05 14:22:39',	0),
(44,	'Portál ZČU dočasně mimo provoz',	'portal-zcu-docasne-mimo-provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n<div class=\"alert alert-danger\">Tak dlouho jsem s tímto blogem experimentoval, až jsem o obrázek \npřišel. :-( Představte si tedy prosím screen vyhledávání na kterém je portál ZČU se zaindexovaným\ntitle \"Portál ZČU dočasně mimo provoz&hellip;\"</div>\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42',	0,	'0000-00-00 00:00:00',	0),
(45,	'Testování presenterů v Nette',	'testovani-presenteru-v-nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38',	0,	'0000-00-00 00:00:00',	0),
(46,	'CRON validátor',	'cron-validator',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--',	'2013-07-28 22:53:32',	0,	'0000-00-00 00:00:00',	0),
(47,	'Třída pro připojení k FIO API',	'trida-pro-pripojeni-k-fio-api',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://zlml.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         * @return array|mixed\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last/\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44',	0,	'0000-00-00 00:00:00',	0),
(49,	'Using fulltext searching with InnoDB',	'using-fulltext-searching-with-innodb',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51',	0,	'0000-00-00 00:00:00',	0),
(50,	'Problémy fulltextu v Nette',	'problemy-fulltextu-v-nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://zlml.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.',	'2013-07-30 22:15:33',	0,	'0000-00-00 00:00:00',	0),
(51,	'Routování v Nette - prakticky',	'routovani-v-nette-prakticky',	'<div class=\"alert alert-success\">Tento článek byl naposledy revidován, aktualizován a rozšířen <strong>27. června 2014</strong>. Snažím se jej držet stále aktuální&hellip;</div>\n\nV následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\n\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\n\nPrvní kroky\n===========\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu:\n\n/--code\napp/\n├─── config/\n├─── model/\n├─── presenters/\n│     └── HomepagePresenter.php\n│\n├─── router/\n├─── templates/\n│     ├── Homepage/\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\n│     │    └── ...\n│     └── @layout.latte\n│\n└─── bootstrap.php\n\\--\n\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\n\n/--code php\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n\\--\n\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\n\n/--code\nhttp://zlml.cz/homepage/kontakt\n\\--\n\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibližně následující:\nBude-li se někdo odkazovat v obecném tvaru `Presenter:view`, pochop `Presenter` jako název presenteru (např. **Homepage**Presenter) a hledej tedy soubor `HomepagePresenter.php`\na `view` bude šablona presenteru, hledej ji tedy ve složce `Presenter/view.latte` a sestav URL která bude přesně v tomto tvaru.\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\n\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\n\n/--code php\n$router[] = new Route(\'<action>\', \'Homepage:default\');\n\\--\n\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\nse mění cílová šablona podle URL:\n\n/--code\nhttp://zlml.cz/kontakt\n\\--\n\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\n\n/--code php\npublic function createRouter() {\n	$router = new RouteList();\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n	return $router;\n}\n\\--\n\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře jako šablony, routa je opět jednoduchá:\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\n\\--\n\nHledá se šablona <code>sitemap.latte</code>. Přečtěte si jak vytvořit tuto šablonu v článku \"RSS a Sitemap jednoduše a rychle\":http://zlml.cz/rss-a-sitemap-jednoduse-a-rychle. Výsledná URL je tak jak má být:\n\n/--code\nhttp://zlml.cz/sitemap.xml\n\\--\n\nTo samé lze udělal pro RSS.\n\nJdeme do hloubky\n================\nTrošku složitější routování přichází vždy když chcete udělat něco speciálního.\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\n\n/--code\nhttp://zlml.cz/2\n\\--\n\n/--code php\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\n\n/--code\nhttp://zlml.cz/using-fulltext-searching-with-innodb\n\\--\n\n/--code php\n$router[] = new Route(\'<id>\', array(\n	\'presenter\' => \'Single\',\n	\'action\' => \'article\',\n	\'id\' => array(\n		Route::FILTER_IN => function ($url) {\n			return $this->posts->getIdByUrl($url);\n		},\n		Route::FILTER_OUT => function ($id) {\n			return $this->posts->getUrlById($id);\n		},\n	),\n));\n\\--\n\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\n\n/--code\nhttp://zlml.cz/search/fio%20api\n\\--\n\n/--code php\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\n\\--\n\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\n\n/--code\nhttp://zlml.cz/rss.xml\n\\--\n\n/--code php\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n\\--\n\nChová se to stejně jako u předchozího příkladu se `sitemap.xml`, v tomto příkladu však routa hledá `BlogPresenter.php` ve složce `FrontModule` a šablonu `rss.latte`, také v tomto modulu. U rout pro modulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa zvládne jazykové mutace pro FrontModul, jinak je to opět ta nejobecnější routa vůbec:\n\n/--code\nhttp://zlml.cz/en/site/kontakt\n\\--\n\n/--code php\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\n	\'module\' => \'Front\',\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n));\n\\--\n\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\n\n/--code\nhttp://zlml.cz/user/en/setting/password\n\\--\n\n/--code php\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\n	\'module\' => \'User\',\n	\'presenter\' => \'Board\',\n	\'action\' => \'default\',\n));\n\\--\n\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\n$router[] = new Route(\'\', \'Front:Product:default\');\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\n	\'module\' => \'Rest\',\n	\'presenter\' => \'Resource\',\n	\'action\' => \'get\',\n), \\App\\RestRouter::RESTFUL);\n\\--\n\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\n\nJak na v posledním příkladu zmíněný CLI router se dočtete v článku \"Nette 2.1-dev CliRouter\":http://zlml.cz/nette-2-1-dev-clirouter.\n\nMáte nějakou zajímavou routu? Podělte se o ni... (-:',	'2013-08-04 12:19:19',	0,	'2015-07-05 14:22:15',	0),
(52,	'Fluent interface a PCRE',	'fluent-interface-a-pcre',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://zlml.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://zlml.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://zlml.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://zlml.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.',	'2013-08-10 22:31:21',	0,	'0000-00-00 00:00:00',	0),
(53,	'RSS a Sitemap jednoduše a rychle',	'rss-a-sitemap-jednoduse-a-rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:',	'2013-08-10 23:10:22',	0,	'0000-00-00 00:00:00',	0),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu',	'<div class=\"alert alert-danger\">Následující text řeší starší verzi FineUploaderu `3.*`, nikoliv nejnovější. Hledáte-li aktuálnější návod, přečtěte si prosím http://zlml.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2...</div>\n\nA je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\n\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\n\n/--code html\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\n\n/--code html\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\n<div id=\"triggerUpload\">Nahrát obrázky</div>\n\\--\n\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\n\n/--code javascript\n$(function () {\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\n		$.nette.ext(\'uploader\', {\n			complete: function () { //zavěšení na konec ajaxového požadavku\n				var uploader = $(\'#image-uploader\').fineUploader({\n					request: {\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\n					},\n					text: {\n						uploadButton: \'Klikněte, nebo přetáhněte obrázky\',\n						cancelButton: \'zrušit\',\n						failUpload: \'Nahrání obrázku se nezdařilo\',\n						dragZone: \'Přetáhněte soubory sem\',\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\n						formatProgress: \'{percent}% z {total_size}\',\n						waitingForResponse: \'Zpracovávám...\'\n					},\n					autoUpload: false,\n					failedUploadTextDisplay: {\n						mode: \'custom\',\n						maxChars: 70,\n						responseProperty: \'error\',\n						enableTooltip: true\n					}\n				});\n				$(\'#triggerUpload\').click(function () {\n					uploader.fineUploader(\'uploadStoredFiles\');\n				});\n			}\n		});\n	}\n\n	$.nette.init(); //inicializace nette.ajax\n});\n\\--\n\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\nTen může vypadat například takto:\n\n/--code php\npublic function handleUpload($id) {\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\n	$uploader = new \\qqFileUploader($allowedExtensions);\n	//...\n	try {\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\n		$result[\'uploadName\'] = $uploader->getUploadName();\n		//...\n	} catch (\\Exception $exc) {\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\n			\'error\' => $exc->getMessage(),\n		)));\n	}\n	$this->invalidateControl();\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\njako úspěšný upload.\n\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\no webalize názvů souborů.\n\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použít.\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2013-08-21 22:14:44',	0,	'0000-00-00 00:00:00',	0),
(55,	'Důležitost titulku podruhé (a naposled)',	'dulezitost-titulku-podruhe-a-naposled',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://zlml.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://zlml.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://zlml.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.',	'2013-10-21 23:20:36',	0,	'0000-00-00 00:00:00',	0),
(56,	'LaTeX šablona',	'latex-sablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?',	'2013-10-21 23:42:14',	0,	'0000-00-00 00:00:00',	0),
(57,	'Změna URL struktury',	'zmena-url-struktury',	'Rád bych tímto upozornil na změny URL adres na tomto webu. A zároveň k technické povaze tohoto webu\nprozradím i bližší informace ze zákulisí.\n\nPřed úpravou URL struktury jsem definoval několik důležitých bodů, kterých jsem se držel:\n1) Musí zůstat maximální (úplná) zpětná kompatibilita\n2) Výsledné URL musí být maximálně jednoduché a cool\n\nPředtím a potom\n===============\nDůležité je, aby stará URL adresa nekončila chybou 404, ale aby přesměrovala na novou URL.\nRSS je nyní na adrese http://zlml.cz/rss. Původně bylo na adrese http://zlml.cz/homepage/rss.\nObě dvě adresy fungují stále, rozdíl je v tom, že homepage/rss nyní přesměrovává pomocí 301 na */rss.\nToho se dalo docílit velice jednoduše:\n\n/--code php\n$router[] = new Route(\'rss\', \'Homepage:rss\'); //nová routa\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\'); //původní\n//záleží na pořadí!\n\\--\n\nAčkoliv je teď druhá routa zbytečná, nechal jsem jí pro případ, že bych měl nějakou URL nezachycenou.\nV tom případě ji zachytí tato obecná.\n\nZpětná kompatibilita\n====================\nStejně tak jako změna adresy RSS, tak si i ostatní adresy musí zachovat stejné vlastnosti viz první bod.\nA vzhledem k tomu, že jsem se rozhodl změnit adresu vyhledávání a tagů, nezbývalo, než další\ndvě routy přidat. Opět záleží na pořadí:\n\n/--code php\n$router[] = new Route(\'s[/<search>]\', \'Search:default\'); //nová\n$router[] = new Route(\'t[/<search>]\', \'Tag:default\'); //nová\n\n//tyto routy (až uznám za vhodné) mohu smazat:\n$router[] = new Route(\'search[/<search>]\', \'Search:default\', Route::ONE_WAY); //původní\n$router[] = new Route(\'tag[/<search>]\', \'Tag:default\', Route::ONE_WAY); //původní\n\\--\n\nOpět platí, že funguje jak stará adresa http://zlml.cz/search/nette s přesměrováním 301, tak i nová \nhttp://zlml.cz/s/nette. Obdobně je tomu u tagů.\n\nČarodějnictví!\n==============\nNejvětší sranda však začíná u druhého požadavku. Už dlouho jsem si pohrával s myšlenkou,\nže chci názvy článků a adresy jednotlivých stránek v menu hned za lomítkem jako v kořenovém\nadresáři. Tedy aby článek měl adresu http://zlml.cz/lovec-matematik a stránka http://zlml.cz/about.\nZde jsem se však vždy dostával do velkého problému. Jak rozlišit a nabídnout z databáze článek a \njak poznat, kdy naopak nabídnout stránku například s referencemi?\n\nNo, tak nejdříve je zapotřebí routa pro články:\n/--code php\n$router[] = new Route(\'<slug>\', \'Single:article\');\n\\--\nKdy v presenteru tahám články z databáze podle slugu:\n/--code php\npublic function renderArticle($slug) {\n	$post = $this->posts->getBySlug($slug)->fetch(); //načetní článku podle slugu\n	if (!$post) { //článek neexistuje (db vrací FALSE)\n		$this->forward($slug); //nabídni statickou šablonu\n	} else { // zobrazení článku\n    	//...\n    }\n}\n\\--\nCož je podle mého dostatečně elegantní řešení. Jednoduše se pokusím o načtení stránky podle slugu\nz databáze a když se to nepodaří, nabídnu nějaký latte soubor, pokud existuje. Pokud neexistuje, \ntak ErrorPresenter již obstará vrácení 404, což je správně, protože není co nabídnout...\n\nJeště je zapotřebí vytvořit jednu routu:\n/--code php\n$router[] = new Route(\'<action>\', \'Single:article\');\n\\--\nBez této routy by to také fungovalo, ale latte ony latte soubory (action) bych našel na dvou URL\nadresách, což nechci. Takže se z původního http://zlml.cz/single/about dostanu na http://zlml.cz/about, \ncož je cool a splňuji tak druhý požadavek.\n\nPoslední routa, která stojí za zmíňku pak zajišťuje stránkování. Pouze rozpoznává čísla podle\nregulárního výrazu a podle toho stránkuje:\n/--code php\n$regex = \'1|2|3\'; //zjednodušeně\n$router[] = new Route(\"[<paginator-page [$regex]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nOstatně to jak mám v době psaní tohoto článku router vytvořený můžete zjistit na \"bitbucketu\":https://bitbucket.org/mrtnzlml/zlml.cz/src/0580e2e9f0e4edb162fe97ad563cfef766bea625/app/router/RouterFactory.php.\n',	'2013-10-27 21:27:00',	0,	'0000-00-00 00:00:00',	0),
(58,	'Nette 2.2-dev',	'nette-2-2-dev',	'Nedávno byla změněna vývojová verze Nette Frameworku na 2.2-dev (https://github.com/nette/nette/commit/3a426255084163ec1a2f324ea0d3e9b3139adccc).\nTato změna s sebou přinesla explozi změn. Na následujících řádcích bych rád přiblížil\nněkteré zásadní změny, které se odehrály a je zapotřebí je upravit, aby bylo možné z verze 2.1-dev\npřejít právě na verzi 2.2-dev.\n\nNutné úpravy\n============\nPrvě se změnilo umístění konfigurátoru. Tato změna se samozřejmě týká souboru `bootstrap.php`.\nNově je konfigurátor v novém umístění:\n\n/--code php\n//$configurator = new Nette\\Config\\Configurator;\n$configurator = new \\Nette\\Configurator;\n\\--\n\nDále jsem si zvykl používat automatické injektování závislostí pomocí anotace `@inject`.\nPro opětovné použití je nutné zapnout `nette.container.accessors`, což ostatně napoví chybová hláška,\njelikož je tato volba v nové developměnt verzi Nette ve výchozím stavu zakázána. Config.neon:\n\n/--code neon\nnette:\n	container:\n    	accessors: TRUE\n\\--\n\nNyní již bude možné anotace `@inject` používat. Další změna, které mě osobně moc nepotěšila\na nevím co jí předcházelo je zrušení podpory krátkého zápisu bloků:\n\n/--code html\n<!-- Předtím: -->\n{#content}\n	...\n{/#}\n<!-- Nyní: -->\n{block content}\n	...\n{/block}\n\\--\n\nTato změna se mi moc nelíbí, protože například stále funguje `{include #parent}`, což je prostě\nzvláštní... Za zmínku také stojí změna třídy pro práci s databází. Zatímco se ve verzi 2.0.13\nnormálně používá `Nette\\Database\\Connection`, ve verzi 2.1-dev se přešlo na `Nette\\Database\\SelectionFactory`, \nnicméně ve verzi 2.1.0RC2 se již pracuje s `Nette\\Database\\Context` a SelectionFactory již neexistuje. \nToto  platí i pro verzi 2.2-dev. Tato změna mi bude zřejmě dlouho trvat, než ji vstřebám.\nMyslím si, že obyčejné `Nette\\Database` by bylo v modelu daleko více vypovídající než nějaký Context, \nale budiž.\n\nTolik k podle mého zásadním změnám, které zabrání například spuštění projektu z quickstartu. Nyní\nbych rád poukázal na několik málo změn z celé té exploze, které mě zaujaly.\n\nDalší změny\n===========\nByla odstraněna celá řada zastaralých věcí. Nemá smysl je rozebírat. Je jich hodně a zastaralé jsou\nuž od 2.1. Každopádně například makro `n:input` se stalo zastaralé a k dispozici je nové makro\n`{inputError}`, které ošéfuje vykreslení chybové hlášky u příslušného políčka. Jééj! :-)\n\nLehce odlišně se také přistupuje k checkboxům a vůbec, formuláře jsou zase o něco lepší, což\npředpokládám souvisí s:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Chtěl jsem v rychlosti udělat příklad, jak v <a href=\"https://twitter.com/search?q=%23netteFw&amp;src=hash\">#netteFw</a> renderovat formuláře s Twitter Bootstrapem.&#10;&#10;Zabitej den a překopaný Nette…</p>&mdash; geekovo (@geekovo) <a href=\"https://twitter.com/geekovo/statuses/409064701369516032\">December 6, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nKonečně!\n========\nSvětlo světa spatřil nový \"quickstart\":http://doc.nette.org/cs/2.1/quickstart v češtině pro dnes již téměř nekatuální verzi 2.0.13.\nVěřím tomu, že se jedná o daleko přínosnější věc, než psaní pokročilých návodů v angličtině\n(navazujících na quickstart) a doufám, že tento počin pomůže pár lidí popostrčit dál...\n\nJaká změna vás zaujala nejvíce?',	'2013-12-15 14:10:23',	0,	'0000-00-00 00:00:00',	0),
(59,	'Přednáška z Nette na ZČU',	'prednaska-z-nette-na-zcu',	'Dnes jsem měl tu čest přednášet na ZČU studentům předmětu KIV/WEB - Webové aplikace.\nPřednášku a i celé povídání jsem se snažil chopit velmi realisticky, prakticky a pro studenty, \nkteří s tvorbou webových aplikací teprve začínají. Doufám, ze bylo mé povídání\ninspirativní, srozumitelné a pochopitelné. Ostatně sami si prezentaci můžete přečíst:\n<br><br>\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29326870\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe>\n\n<br>\nVěřím, že Nette bude používat zase o něco více začátečníků a že še jim podaří psát kvalitní\nwebové aplikace. Rád bych ještě jednou popřál všem studentům úspěšné složení zkoušky z předmětu KIV/WEB\na snad se ještě někdy potkáme... (-:',	'2013-12-18 17:54:22',	0,	'0000-00-00 00:00:00',	0),
(60,	'Veřejná distribuce klíčů',	'verejna-distribuce-klicu',	'<blockquote>\n  Inspirací a zdrojem informací pro tento článek byla kniha <strong>Simona Singha</strong> - Kniha kódu a šifer.\n  <small>Utajování od starého Egypta po kvantovou kryptografii</small>\n</blockquote>\n\nTímto článkem bych rád navázal na článek o asymetrickém šifrování http://zlml.cz/asymetricka-sifra-s-verejnym-klicem a vyřešil tak několik restů. Zejména potom onu osudnou veřejnou distribuci klíčů o které jsem sice již dříve psal, ale článek již není k dispozici. Proto tento text budu brát jako revizi původního. Také bych na začátek chtěl říct, že tento problém je již dávno vyřešen a proto bude následující text ohlédnutím za vznikem této myšlenky s tím, že je však použití stále aktuální a reálně se používá (např.: http://nodejs.org/api/crypto.html#crypto_class_diffiehellman).\n\nDistribuce klíčů? Vždyť je to tak snadné...\n===========================================\nPokud si chtějí dvě osoby vyměnit zašifrované zprávy, je jasné, že musejí znát i klíče, které jim umožní tyto zprávy dešifrovat. Jenže jak si vyměnit tyto klíče? Mohou se tyto osoby někdy potkat a klíč si povědět. To však není vždy možné. Navíc klíče je dobé frekventovaně měnit, takže je v dnešní době toto řešení naprosto nesmyslné.\n\n<blockquote>\n  Dříve, než dva lidé mohou sdílet tajemství, musí již jedno tajemství sdílet.\n  <small>Dříve než dva lidé mohou sdílet šifrovanou zprávu, musí již sdílet klíč.</small>\n</blockquote>\n\nAčkoliv je osobní výměna bezpečná, jedná se tedy o metodu nereálnou a je třeba navrhnout jiné postupy. Co třeba najmou kurýra? Je to sice méně bezpečné, ale eliminují se některé předchozí problémy. Bohužel kurýr je až příliš nebezpečný způsob, protože pak lze klíč rovnou nějakým kanálem poslat a dostáváme se opět na začátek. Je tedy vůbec možné si vyměnit klíč bez nutnosti potkat se? Je tedy vůbec nutné si klíč vyměnit?\n\nMožná to jde i jinak\n====================\nExistuje skvělá hádanka, která na první pohled daný problém řeší. Představte si poštovní službu, která však všechny zásilky otevírá a čte si je. Nicméně Alice potřebuje poslat tajný balík Bobovi. Lze využít tuto poštu tak, aniž by balík otevřela?\n\nPřistupím rovnou k řešení, které je opravdu jednoduché. Alice pošle balík (schránku), který opatří vlastním zámkem a klíč od tohoto zámku si ponechá. V tom případě není pošta schopna balík otevřít. Bohužel ani Bob balík neumí otevřít, protože nemá k dispozici správný klíč. Proto Bob vezme vlastní zámek a schránku zamkne ještě vlastním zámkem. Klíč si opět ponechá. To může vyznít zvláštně, ale hned to začne být jasné. Bob balík opět odešle, Alice sundá vlastní zámek (protože od něj má klíč) a balík pošle opět Bobovi. Nyní je na balíku pouze Bobovo zámek a ten ho může jednoduše odemknout. Zdá se tedy, že lze cokoliv poslat zabezpečeně a výměna klíčů není potřeba! Toto je nesmírně důležitá myšlenka.\n\nMá to však háček. Ačkoliv se zdá být předchozí problém naprosto zřejmý a funkční, po převedení do světa kódů a šifer, celá myšlenka padá. Důvod je jednoduchý. Bylo velmi snadné na schránku umístit zámek **A**, poté zámek **B**, poté odstranit zámek **A** a nakonec odstranit zámek **B**. Takže posloupnost  šifrování byla +A => +B => -A => -B. Použijete-li však tento postup pomocí doposud známých šifer, zjistíte, že záleží na pořadí šifrování, resp. dešifrování. Zkrátka nelze toto pořadí zaměnit, jinak je výsledek zamíchaný a nepoužitelný.\n\nTak to je problém...\n====================\nAčkoliv byla myšlenka posílání balíku téměř ideální, ve světě šifer již nefunguje. Co teď? Na scénu přichází matematika. Konkrétně jednosměrné funkce a s nimi modulární aritmetika. Nemyslím si, že má smysl řešit co je to jednosměrná funkce, ale zkráceně jednosměrná funkce je taková funkce, která se nedá (nebo velmi těžce) zvrátit. Jeko velmi dobrý příklad takové funkce je například smíchání dvou barev (nelze získat zpět původní barvy). Obdobně pro matematické funkce. Zkrátky vždy je o to nalézt takovou funkci, kterou je velmi jednoduché použít a spočítat, ale již velmi složité invertovat výsledek. Právě pro tyto úlohy se perfektně hodí modulární aritmetika. Tam kde se běžná aritmetika chová předvídatelně a na základě pokusů lze konvergovat k výsledku, v modulární takováto chování neexistují.\n\nŘešení\n======\nNásledující algoritmus je zhruba použit v šifrách DES (pro velká čísla). Budu však používat malá, aby bylo vše lépe pochopitelné. Alice a Bob se <strong>veřejně</strong> dohodnou na funkci *Y<sup>x</sup>(mod P)*, kdy si číla např. Y=5 a P=8 vymění (a útočník je může odposlechnout).\n\nTeď tedy zná příjemnce, odesílatel i útočník danou funkci. Odesílatel a příjemnce si nyní zvolí jiné číslo <strong>které uchovají v tajnosti</strong>, toto číslo vloží do matematické funkce *Y<sup>x</sup>(mod P)* a výsledek odešlou. Například Bob zvolil x=4, tedy *5<sup>4</sup>(mod 8)=1*. Alice volí x=3, tedy *5<sup>3</sup>(mod 8)=5*. Tyto výsledky si vymění.\n\nZ pohledu útočníka lze říci, že zná funkci a zná také výsledky, konkrétně 1 a 5. S touto znalostí by šlo možná privátní číslo **x** dopočítat. Jenže vyzkoušejte si to. Pro malá čísla možná, ale pro velká je to téměř nemožné. A že se používají velká čísla...\n\nNyní vezme Alice výsledek od Boba a spočte *vysledek<sup>x</sup>(mod P)*, tedy *1<sup>3</sup>(mod 8)=1*. Nezapomeňte, že číslo **x** je stále privátní a zná ho jen Alice. Stejně teď postupuje i Bob, ale s vlastním privátním číslem a výsledkem od Alice: *5<sup>4</sup>(mod 8)=1*. A zde je vidět k čemu došlo. Výsledek obou výpočtů vyšel stejně a k přenosu priváního čísla **x** nikdy nedošlo. Vyzkoušejte si to na papír a nejlépe pro větší čísla. Pro útočníka nastává velký problém, protože nezná privátní číslo a je pro něj tedy nemožné provést tyto výpočty, nicméně Alice i Bob mají k dispozici jeden výsledek, tedy jeden klíč, který mohou používat.\n\nZávěr\n=====\nJeště zopakuji k čemu tedy došlo. Bylo zapotřebí dohodnout se mezi odesílatelem a příjemcem na společném klíči, podle kterého bude posílaná zpráva šifrována. To se pomocí vhodných matematických metod povedlo a navíc (což je to njdůležitější) není téměř možné tento přenos odposlechnout, jelikož se jedná o jednosměrné operace.\n\nAnalogicky lze použít opět míchání barev. Alice a Bob mají nádobu s litrem červené barvy. Stejnou nádobu má i útočník. Alice i Bob nyní nalijí vlastní privátní barvu do nádoby a tyto nádoby si vymění. Útočník je může vidět, ale nedokáže z nich odhadnout jaká je privátní barva. Nakonec Alice i Bob nalijí zbytek své tajné barvy do nádoby (již je mají vyměněné), čímž vznikne Alici i Bobovi stejná barva. Ani Alice, ani Bob, ani útočník neví co bylo přidáno za barvy od toho druhého, ale se znalostí vlastního privátního klíče se dostanou ke stejnému výsledku. útočník tyto klíče nezná a je nahraný.\n\nTak a zde by měl začínat článek http://zlml.cz/asymetricka-sifra-s-verejnym-klicem.\n\nTento a daleko více inspirativních nápadů a příběhů naleznete v knize https://www.kosmas.cz/knihy/146743/kniha-kodu-a-sifer/.',	'2013-12-22 12:08:24',	0,	'0000-00-00 00:00:00',	0),
(61,	'Stáhněte si zdarma 897457 emailových adres',	'stahnete-si-zdarma-897457-emailovych-adres',	'V následujícím článku bych rád nastínil problematiku newsletterů nejen z programátorského hlediska <s>a také bych se rád opřel do bezpečnosti společnosti Wedos, které mnoho lidí tolik věří</s>... (-:\n\n<span style=\"color:green\">Tento projekt pravděpodobně nemá se společností Wedos nic společného jak jsem si zřejmě mylně myslel.</span>\n\nNa začátku byl email\n====================\nJednoho dne mi přišel email, který byl automaticky filtrován jako spam. Vzhledem k tomu, že když mě něco štve, tak to řeším, spam jsem otevřel a hledal odkaz na odhlášení. Ten byl dobře umístěn, stačilo kliknout a hotovo. Každý přece ví, že to takto má být. Když je odhlášení delší, než kliknutí na spam v email klientovi, je to problém. Bohužel tento odkaz vedlo na doménu <code>m-letter.eu</code>. Mě samozřejmě zajímá jak jsem se dostal do takového spam listu a jelikož jsem byl odkázán na mě neznámou doménu, byl jsem velmi rozezlen.\n\n<s>Zde je nutné říct, že jsem dříve jednal, než pátral. Nakonec se ukázalo, že jsem byl možná v tomto listu oprávněně, jelikož se jedná o doménu, ze které zřejmě Wedos odesílá podobné reklamní emaily, takže je dost pravděpodobné, že jsem s tím dříve souhlasil.</s>\n\n<span style=\"color:green\">Při hlubším pátrání jsem zjistil, že jsem stále nic nezjistil. Chybně jsem tento problém svedl na někoho jiného, což mě odvedlo na špatnou kolej. Stále tedy nevím, kde jsem se na tomto spam listu vzal a opět to beru osobně. Není mi to jedno...</span>\n\nNeštvi programátora\n===================\nCelý reklamní systém je udělán dosti nešťastně, takže než abych pátral jak jsem se tam dostal, soustředil jsem se na něco jiného, co pro mě z pohledu programátora webových aplikací bylo dost zajímavé. URL adresa. Celá adresa pro odhlášení je v následujícím formátu:\n\n/--code\nhttp://www.m-letter.eu/odh.html?c=XXXXXXX&s=53&q=51\n\\--\n\nKde **XXXXXXX** je číslo zhruba od 1300486 do 2197943. To mě zaujalo a tak jsem toto číslo začal měnit. A ukázalo se, že jsem odhlašoval další lidi. V té době ještě tato stránka vypsala informaci o úspěšném odhlášení včetně emailu, který byl odhlášen. Vzhledem k tomu, že stránka je velmi jednoduchá, lze programově stejně jednoduše získat onu emailovou adresu.\n\nJen si představte program, který iteruje tuto URL adresu a jen sbírá emaily. 897457. To je počet emailů které takto získáte. **897457**. Navíc tímto celý systém znehodnotíte, protože všechny odhlásíte. A pro takový počet emailů to již není zanedbatelné.\n\nTo má být jako oprava?\n======================\nNejde mi zrovna o to znehodnotit celý čupr dupr systém na spamování, ale proč ne. Tato informace se poměrně rychle rozšířila a o pár minut později mi byl odepřen přístup na tento server. Navíc výpis byl pozměněn tak, aby již nešlo stáhnout téměř 900 000 emailových adres. Nicméně celý systém zřejmě stále funguje stejně, takže můžete jednoduše iterovat URL adresy a tím celý systém znehodnotit:\n\n/--code php\n<?php\nfor ($i=2197943; $i > 1300486; $i--) {\n    file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\");\n}\n\\--\n\nDoporučuji spustit v příkazové řádce, kde není nastaven pro PHP timeout. Iterace je schválně pozpátku, protože se dá předpokládat, že ty nejnovější záznamy mají větší číslo a ty s malým číslem už dost možná nebudou aktuální. Celý program jsem měl daleko složitější, vzhledem k tomu, že jsem byl připraven na stáhnutí všech emailů. Po změně výpisu již většina programu není potřeba a stačí tedy tři řádky pro znehodnocení celého nezanedbatelně velkého systému.\n\n<s>Dejme tedy někomu z Wedos čas na opravu a pak hurá na hromadný lynč.</s> <span style=\"color:green\">Opět stejný problém jako předtím. Doufám, že mám tentokrát pravdu...</span> Sice jde jen o emailové adresy, ale vzpomeňte si na to až zase budete nadávat na spam, nebo souhlasit s tím, že vaše emailová adresa nebude nikde uveřejněna.',	'2014-01-27 12:33:57',	0,	'0000-00-00 00:00:00',	0),
(62,	'Představení projektu Vacuum - STATIC',	'predstaveni-projektu-vacuum-static',	'Vzhledem k tomu, že vzrostl zájem o Vacuum projekty, rozhodl jsem se zde uveřejnit postup jak pracovat s projektem **Vacuum - STATIC** (https://bitbucket.org/mrtnzlml/vacuum-static). Věřím, že je daleko lepší projekt ukázat a lehce popsat, než popsat a lehce ukázat, jak si Nette komunita občas myslí...\n\nCo to vlastně je\n================\nVacuum - STATIC je projekt, který vznikl z úplně základního Nette skeletonu, který jsem používal pro jednoduché statické firemní prezentace jako je například http://www.businessservice.cz/. Postupem času jsem dodával vylepšení a když už tento projekt dosáhl svého maxima, rozhodl jsem se do něj napsat jednoduchou administraci. V současné době tedy Vacuum - STATIC vlastně vůbec není statická prezentace. Obsahuje vestavenou SQLite databázi, díky které není potřeba nějaké MySQL databáze. Web prostě funguje zdánlivě bez databáze. Toto je velmi zásadní. Vacuum - STATIC pravděpodobně nikdy nebude mít externí databázi, takže se bude stále tvářit jako jednoduchá webová prezentace, která má však navíc jednoduchou administraci.\n\nStažení, instalace, spuštění\n============================\nCelý projekt se dá stáhnout různě, asi nejjednodušší je využít funkcionalit GITu:\n\n/--code\n>> git clone https://mrtnzlml@bitbucket.org/mrtnzlml/vacuum-static.git folder\nCloning into \'folder\'...\nremote: Counting objects: 433, done.\nremote: Compressing objects: 100% (401/401), done.\nremote: Total 433 (delta 201), reused 0 (delta 0)\nReceiving objects:  92% (399/433), 636.00 KiB | 192 KiB/s\nReceiving objects: 100% (433/433), 664.47 KiB | 192 KiB/s, done.\nResolving deltas: 100% (201/201), done.\n\\--\n\nTím vytvoříte složku `folder`, která bude obsahovat aktuální verzi projektu Vacuum - STATIC. Pokud v tuto chvíli projekt sputíte, vrátí chybu, že nemůže najít soubor `autoload.php`. Je to proto, že projekt ještě neobsahuje žádné knihovny (například Nette). Ty totiž nemá smysl udržovat v repozitáři. Veškeré potřebné knihovny lze doinstalovat jednoduše pomocí Composeru:\n\n/--code\n>> composer update\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\n  - Installing nette/tester (dev-master a60c379)\n    Cloning a60c379836617422c8df9d9846fea4efa2ca9d1d\n\n  - Installing nette/nette (dev-master a748c3d)\n    Cloning a748c3d344767ed1f0cc9ee40019f6a6f81afa97\n\n  - Installing janmarek/webloader (dev-master 3d44d30)\n    Cloning 3d44d306d59591dc94f6fdcb98f55c0990d98326\n\n  - Installing texy/texy (dev-release-2.x 79d0e15)\n    Cloning 79d0e1517363ab32edf2db8ec515e3dc84f50f0a\n\nnette/nette suggests installing ext-fileinfo (*)\njanmarek/webloader suggests installing leafo/lessphp (Lessphp is a composer for LESS written in PHP.)\nWriting lock file\nGenerating autoload files\n\\--\n\nV tuto chvíli je projekt připraven k použití. V některých systémech však bude potřeba ještě nastavit práva k zápisu složkám `temp` a `log`. Dokonce není potřeba ani nějakého XAMPP serveru. Stačí v té samé složce využít integrovaného PHP serveru v příkazové řádce:\n\n/--code\nphp -S localhost:8888 -t www\n\\--\n\nFunkční Vacuum - STATIC pak naleznete na adrese http://localhost:8888/. Trapně jednoduché a překvapivě funkční. (-: Vzhledem k tomu, že již vidíte funkční stránku, můžete se přihlásit do administrace (link v patičce). Přihlašovací údaje jsou *demo*/*demo*.\n\nUpdate projektu\n===============\nNa tomto projektu stále pracuji a čas od času v něm něco doplním nebo upravím. Vzhledem k tomu, že doporučuji použít ke stažení GIT, je update projektu velmi jednoduchý. Stejně jako jsem nedávno zapomněl přidat nahrát dva soubory:\n\n/--code\n>> git pull\nUpdating ead4a56..2439d5f\nFast-forward\n www/js/codemirror.js | 5516 ++++++++++++++++++++++++++++++++++++++++++++++++++\n www/js/xml.js        |  338 ++++\n 2 files changed, 5854 insertions(+)\n create mode 100644 www/js/codemirror.js\n create mode 100644 www/js/xml.js\n\\--\n\nTo je asi tak vše co se k tomu dá teď napsat. Nic na tom není, jen je třeba vědět jak na to. Přeji hodně úspěchů při používání tohoto projektu ať už je to ke studijním účelům, nebo k reálné webové prezentaci. Zpětnou vazbu samozřejmě rád uvítám.',	'2014-01-28 18:10:34',	0,	'0000-00-00 00:00:00',	0),
(63,	'Vlna na webu',	'vlna-na-webu',	'Vlna je program \"Petra Olšáka .{target:_blank}\":http://ftp.linux.cz/pub/tex/local/cstug/olsak/vlna/, který slouží k umístění nezalomitelné místo na místo v textu, kde by nemělo dojít k samovolnému zalomení řádku. Tento program slouží k dodatečné úpravě textů napsaných v LaTeXu. V tomto prostředí se nezalomitelná mezera nahrazuje znakem vlnovkou - tildou (~). U webového výstupu se používá zástupná entita <code>&amp;nbsp;</code>.\n\nKde by měla být nedělitelná mezera\n==================================\nV základu program Vlna umístí tildu za znaky <code>KkSsVvZzOoUuAI</code>. Více toho pokud vím nedělá. Podle Ústavu pro jazyk český AV ČR by však toto pravidlo mělo platit mimo jiné pro znaky <code>KkSsVvZzAaIiOoUu</code>. Neuvažuji další pravidla, která určují další nevhodné výrazy na konci řádku. Mezi tyto pravidla patří například mezery uvnitř číslic, mezery mezi číslicí a značkou, atd. Některá pravidla jsou totiž natolik specifická, že by je bylo náročné (nebo nepraktické) podchytit programově.\n\nImplementace\n============\nO samotné nahrazování se stará následující regulární výraz:\n/--code php\npreg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n\\--\nTento výraz říká, že nestojí-li bezprostředně před sadou znaků <code>KkSsVvZzAaIiOoUu</code> jiný alfanumerický znak a stojí-li za touto sadou jakýkoliv alfanumerický znak oddělený bílým znakem bude tento znak nahrazen entitou <code>&amp;nbsp;</code>. V konkrétní implementaci lze zaregistrovat Vlnu jako helper pro Latte šablony například takto (obsahuje i registraci Texy helperu):\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	$template->registerHelper(\'vlna\', function ($string) {\n		$string = preg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n		return $string;\n	});\n	return $template;\n}\n\\--\n\nVlna se pak v Latte šablonách používá jako jakýkoliv jiný helper:\n\n/--code\n{$post->title|vlna}\n\\--\n\nJeště by možná stálo za to vrátit se k tomu, jaké problémy by způsobovala implementace i dalších pravidel a jak by to bylo náročné. Ještě nad tím budu přemýšlet, každopádně již teď mě napadají určité problémy. Například u čísel. Jak přesně identifikovat, kdy se má použít nedělitelná mezera a kdy ne? Možná je toto právě ten důvod, proč takové rozšířené chování program Vlna nepodporuje...',	'2014-02-01 22:09:38',	0,	'0000-00-00 00:00:00',	0),
(64,	'Použití Texy s FSHL',	'pouziti-texy-s-fshl',	'Někdy (hodně dávno) jsem kdesi našel poměrně hezký a jednoduchý postup jak implementovat \"Texy .{target:_blank}\":http://texy.info/ s použitím \"FSHL .{target:_blank}\":http://fshl.kukulich.cz/ na webu. Rád bych se zde podělil o postup, který používám již na řadě projektů, které potřebují zvýrazňování syntaxe.\n\nPoužití samotného Texy\n======================\nBěžně by se Texy zaregistrovalo do šablony jako helper:\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	return $template;\n}\n\\--\n\nTento helper lze i nadále používat. Hodě se například pokud je potřeba Texy prvky naopak escapovat:\n\n/--code\n{$post->body|texy|striptags}\n\\--\n\nPoužití Texy s FSHL\n===================\nSamotné texy je sice geniální nástroj. Pro samotné zpracování se zvýrazněním se však hodí funkcionalitu Texy rozšířit, jelikož je potřeba zpracovat vstupující text a ty správná místa prohnat také tím správným lexxerem ve FSHL. K tomu dobře poslouží následující třída, která dědí právě od Texy:\n\n/--code php\n<?php\n\nclass fshlTexy extends Texy {\n\n	public function blockHandler($invocation, $blocktype, $content, $lang, $modifier) {\n		if ($blocktype !== \'block/code\') {\n			return $invocation->proceed(); //vstup se nebude zpracovavat\n		}\n\n		$highlighter = new \\FSHL\\Highlighter(\n			new \\FSHL\\Output\\Html(),\n			\\FSHL\\Highlighter::OPTION_TAB_INDENT | \\FSHL\\Highlighter::OPTION_LINE_COUNTER\n		);\n\n		$texy = $invocation->getTexy();\n		$content = Texy::outdent($content);\n\n		//Set correct lexer:\n		switch(strtoupper($lang)) {\n			case \'CPP\': $lexer = new \\FSHL\\Lexer\\Cpp(); break;\n			case \'CSS\': $lexer = new \\FSHL\\Lexer\\Css(); break;\n			case \'HTML\': $lexer = new \\FSHL\\Lexer\\Html(); break;\n			case \'JAVA\': $lexer = new \\FSHL\\Lexer\\Java(); break;\n			case \'JAVASCRIPT\': $lexer = new \\FSHL\\Lexer\\Javascript(); break;\n			case \'NEON\': $lexer = new \\FSHL\\Lexer\\Neon(); break;\n			case \'PHP\': $lexer = new \\FSHL\\Lexer\\Php(); break;\n			case \'PYTHON\': $lexer = new \\FSHL\\Lexer\\Python(); break;\n			case \'SQL\': $lexer = new \\FSHL\\Lexer\\Sql(); break;\n			case \'TEX\': $lexer = new \\FSHL\\Lexer\\Tex(); break; //WARNING: vlastní výroba!\n			case \'TEXY\': $lexer = new \\FSHL\\Lexer\\Texy(); break;\n			default: $lexer = new \\FSHL\\Lexer\\Minimal();\n		}\n\n		$content = $highlighter->highlight($content, $lexer);\n		$content = $texy->protect($content, Texy::CONTENT_BLOCK);\n\n		$elPre = TexyHtml::el(\'pre\');\n		if ($modifier) {\n			$modifier->decorate($texy, $elPre);\n		}\n		$elPre->attrs[\'class\'] = strtolower($lang);\n\n		$elCode = $elPre->create(\'code\', $content);\n\n		return $elPre;\n	}\n\n}\n\\--\n\nTato třída při správném použití zajistí, že se použije ten správný lexer a ještě na úrovni PHP zajistí změnu výstupu. Konkrétně obalí určitá klíčová slova (v závislosti na kontextu) tagem <code>&lt;span&gt;</code> se zvláštní třídou. Toho se následně lze chytit v CSS a HTML výstup obarvit. Použití této třídy například v metodě <code>render*()</code>:\n\n/--code php\n$texy = new \\fshlTexy();\n//registrace handleru z nové třídy:\n$texy->addHandler(\'block\', array($texy, \'blockHandler\'));\n//dále stejně jako klasické použití Texy:\n$texy->tabWidth = 4;\n$texy->headingModule->top = 3; //start at H3\n$this->template->body = $texy->process($post->body);\n\\--\n\nVýstup lze pak v Latte lehce podchytit a zobrazit:\n\n/--code\n{$body|noescape}\n\\--\n\nBarvy, barvy, barvičky\n======================\nProgramově je sice tělo dokumentu vypsáno s tagy <code>&lt;span&gt;</code> s příslušnou třídou. To se však nijak viditelně neprojeví. Celou krásu udělá teprve CSS. Lze použít výchozí hodoty FSHL a vložit je do vlastního souboru stylů:\n\n/--code css\n/* Common */\n.xlang { color: #ff0000; font-weight: bold; }\n.line { color: #888888; background-color: #ffffff; }\n\n/* CSS */\n.css-at-rule { color: #004a80; font-weight: bold; }\n.css-tag { color: #004a80; }\n.css-id { color: #7da7d9; font-weight: bold; }\n.css-class { color: #004a80; }\n.css-pseudo { color: #004a80; }\n.css-property { color: #003663; font-weight: bold; }\n.css-value { color: #448ccb; }\n.css-func { color: #448ccb; font-weight: bold; }\n.css-color { color: #0076a3; }\n.css-comment { background-color: #e5f8ff; color: #999999; }\n\n/* CPP */\n.cpp-keywords1 {color: #0000ff; font-weight: bold;}\n.cpp-num {color: #ff0000;}\n.cpp-quote {color: #a52a2a; font-weight: bold;}\n.cpp-comment {color: #00ff00;}\n.cpp-preproc {color: #c0c0c0;}\n\n/* HTML */\n.html-tag {color: #598527; font-weight: bold;}\n.html-tagin {color: #89a315}\n.html-quote {color: #598527; font-weight: bold;}\n.html-comment {color: #999999; background-color: #f1fae4;}\n.html-entity {color: #89a315;}\n\n/* Java */\n.java-keywords1 {color: #0000ff; font-weight: bold;}\n.java-num {color: #ff0000;}\n.java-quote {color: #a52a2a; font-weight: bold;}\n.java-comment {color: #009900;}\n.java-preproc {color: #c0c0c0;}\n\n/* Javascript */\n.js-out {color: #898993;}\n.js-keywords1 {color: #575757; font-weight: bold;}\n.js-num {color: #575757;}\n.js-quote {color: #575757; font-weight: bold;}\n.js-comment {color: #898993; background-color: #f4f4f4;}\n\n/* Neon */\n.neon-section {color: #598527;}\n.neon-sep {color: #ff0000;}\n.neon-key {color: #0000ff;}\n.neon-comment {color: #999999;}\n.neon-value {color: #000000;}\n.neon-quote {color: #884433;}\n.neon-num {color: #448ccb;}\n.neon-var {color: #ffaa00;}\n.neon-ref {color: #884433;}\n\n/* PHP */\n.php-keyword1 {color: #dd2244; font-weight: bold;}\n.php-keyword2 {color: #dd2244;}\n.php-var {color: #ffaa00; font-weight: bold;}\n.php-num {color: #ff0000;}\n.php-quote {color: #884433; font-weight: bold;}\n.php-comment {color: #999999; background-color: #ffffee;}\n\n/* Python */\n.py-keyword1 {color: #0033cc; font-weight: bold;}\n.py-keyword2 {color: #ce3333; font-weight: bold;}\n.py-keyword3 {color: #660066; font-weight: bold;}\n.py-num {color: #993300;}\n.py-docstring {color: #e86a18;}\n.py-quote {color: #878787; font-weight: bold;}\n.py-comment {color: #009900; font-style: italic;}\n\n/* SQL */\n.sql-keyword1 {color: #dd0000; font-weight: bold;}\n.sql-keyword2 {color: #dd2222;}\n.sql-keyword3 {color: #0000ff; font-weight: bold;}\n.sql-value {color: #5674b9;}\n.sql-comment {color: #ffaa00;}\n.sql-num {color: #ff0000;}\n.sql-option {color: #004a80; font-weight: bold;}\n\n/* Tex */\n.tex-func {color: #ffaa00; font-weight: bold;}\n.tex-comment {color: #999999; background-color: #ffffee;}\n.tex-attr1 {color: #dd2222;}\n.tex-attr2 {color: #0000ff; font-weight: bold;}\n.tex-math {color: #00AA00; font-weight: bold;}\n\n/* Texy */\n.texy-hlead {color: #4444bb; font-weight: bold;}\n.texy-hbody {background-color: #eeeeff; color: #4444bb;}\n.texy-hr {color: #bb4444;}\n.texy-code {color: #666666;}\n.texy-html {color: #66aa66;}\n.texy-text {color: #6666aa;}\n.texy-err {background-color: #ff0000; color: #ffffff;}\n\\--\n\nCelá krása tohoto řešení spočívá v tom, že nepoužívám žádné javascriptové knihovny, ale vše se provede pěkně na úrovni PHP a bude to tedy fungovat vždy, stejně tak jako Texy... (-:',	'2014-02-02 10:47:06',	0,	'0000-00-00 00:00:00',	0),
(65,	'Udržujete dokumentaci stále aktuální?',	'udrzujete-dokumentaci-stale-aktualni',	'Již dlouho si v hlavě pohrávám s jednou myšlenkou, kterou stále nemohu dovést do zdárného konce. Již na samém začátku jsem již však věděl, že se zajisté nezalíbí velké skupině programátorů. Přesto si myslím, že má něco do sebe. Jen jsem ji ještě nedomyslel tak, aby jsem s ním byl spokojen. Třeba bude mít někdo nějaký geniální nápad.\n\nNa začátku byl problém\n======================\nA každý problém by se měl řešit. Mluvím teď o jednom konkrétním. *Jak udržet dokumentaci projektu aktuální?* To je problém, který některé projekty dokáží bez větších problémů. Obdivuji člověka, který napíše kus kódu a k němu napíše přehlednou a užitečnou dokumentaci. Ještě více však obdivuji toho, kdo aktualizuje kus kódu a opět se pustí na přepisování dokumentace. V praxi je toto však bolístka, která trápí většinu projektů, které používá menší než obrovské množství...\n\nMyslím si, že tento postup je částečně zcestný. Není problém napsat dokumentaci, ale problém je se pak vracet k napsaným textům a číst je znova a znova a stále je upravovat. Má tento problém vůbec nějaké řešení? Možná ano. Pokud zůstanu u myšlenky, že jednou napsat dokumentace a dost, může se leckomu zdát, že při tomto postupu není možné dokumentaci aktualizovat. Definjme tedy alespoň rámcově tyto pojmy. Pod dokumentací si představuji webovou stránku s případnou obsahovou strukturou, která obsahuje jak veškeré naučné texty, tak ukázky kódů. Praktické ukázky. Tak jak to ve skutečnosti funguje.\n\nBěžné zadání dokumentace, že? Nikde jsem však nenapsal, že tato dokumentace musí obsahovat přímo napsané povídání. Musí tento text ve výsledku obsahovat, ale nemusí být součástí!\n\nCo prosím?\n==========\nMyslím to přesně tak jak jsem napsal. Dokumentace musí na výstupu obsahovat veškeré texty a prostě všechno, ale nemusí je při tvorbě obsahovat. To zní možná trošku divně. Není ta věta v rozporu sama se sebou? Ne nutně. Dokumentaci bych si opravdu představoval jako soubor pravidel obsahující nadpis, několik programových direktiv a to by bylo v podstatě všechno. Mohlo by to vypadat například takto pro nějaký tutoriál:\n\n/--code\nToto je nadpis stránky v dokumentaci\n\nindex.php\nbootstrap.php\nHomepagePresenter.php:renderDefault\n\\--\n\nSchválně jsem zvolil všem tolik známý sandbox z Nette Frameworku. V souboru bych tedy jen definoval jen (omáčku okolo), nadpis, soubory odkud se má dokumentace generovat, popř. nějaký výběr. Zde je nutné říct, že by byl projekt po programové stránce poněkud zvláštní a nejsem si jist, jestli je to úplně OK. usel by totiž obsahovat onu dokumentaci viz např. *index.php*:\n\n/--code php\n<?php\n\n/**\n ** Zde je umístněna dokumentace.\n ** Obsahuje kompletní poučný text, který se pak vyfiltruje do dokumentace včetně\n ** řádků, popř. metod ke kterám se vztahuje. Pro lepší použití by bylo potřeba\n ** definovat několik zřejmě anotací jako např:\n **\n ** @doc-lines 12-14\n ** @doc-highlight 14\n **/\n$container = require __DIR__ . \'/../app/bootstrap.php\'; ///>label\n\n$container->application->run();\n\\--\n\nTakovýto soubor je pak jednoduché vzít, rozebrat, naservírovat text, aplikovat funkci entit a vykreslit i kód ke kterému se tento komentář vztahuje. Možná by šlo vytvořit i nějaká návěští pro odkazování se do kódu, protože číslo řádky není úplně nejvhodnější (<code>///>label</code>).\n\nPro et Contra\n=============\nJednoznačně by tento postup vedl k tomu, aby programátor kromě psaní kódu udržoval i komentář, který by byl běžně velmi blízko. Jednalo by se tak vlastně o jednu práci. Netřeba otevírat celou dokumentaci, stačí změnit pouze malou část, která se s pushnutím zobrazí i v dokumentaci. Na druhou stranu, nedovedu si tento postup představit v kombinaci s klasickým PHPDOC. Nenapadá mě jiné řešení, než udržovat klasický projekt a vedle projekt, který by sloužil pouze pro dokumentaci. Například onen sandbox z NetteFW. Při takovém postupu mi to však dává docela dobrý smysl. Dokumentace by byla doslova stejně aktuální jako zdrojové kódy a to včetně ukázek! Co je u takových projektů důležitější?\n\nMimochodem. PHP k tomuto má velmi blízko. Minimálně podle jejich dokumentačních \"slohokomentářů\". S tímto problémem také lehce souvisí verzování projektů o kterém bych se chtěl rozepsat jindy.\n\nTeď však zpět k myšlence. Jak moc je to hloupý nápad? Co je jeho překážkou? Proč by ho nešlo prakticky použít?',	'2014-02-03 21:50:55',	0,	'0000-00-00 00:00:00',	0),
(66,	'Kde se berou spamy?',	'kde-se-berou-spamy',	'<div class=\"alert alert-info\">Tento článek navazuje na článek \"Stáhněte si zdarma 897457 emailových adres\":http://zlml.cz/stahnete-si-zdarma-897457-emailovych-adres z ledna tohoto roku. Přečtěte si jej prosím, ať víte o co jde.</div>\n\nRád bych tímto všechny čtenáře poprosil o pomoc. Ačkoliv na internetu vystupuji veřejně a nemám s tím problém, jsem velmi háklivý na to, když někdo neoprávněně zneužívá mé osobní informace. Někteří přijmou moji žádost a problém odstraní - viz nedávno zrušená kopie tohoto blogu. Někteří však dělají všechno proto, abych pokračoval v rituálním podpalování válečné sekery a proto jsem neskončil tam kde jsem v minulém článku přestal psát.\n\nTrnitá cesta plná překážek\n==========================\nJe již známá věc, že jistý web má nemalou zásluhu na šíření reklamních emailů křížem krážem. Vzhledem k tomu, že takové email dorazil i ke mě a vzhledem k tomu, že upoutal moji pozornost, začal jsem zbrojit. Při prvních pokusech jsem oťukával jejich systém abych zjistil o co jde. Zde jsem mimo jiné udělal mylný myšlenkový pochod a vše jsem svedl na někoho kdo s tím nemá nic společného. Každopádně po několika minutách jsem měl celkem jasno a udělal jsem velkou chybu. Popsal jsem bezpečnostní chybu reklamního systému na G+, na což někdo velmi rychle zareagoval a já jsem dostal na tento reklamní server ban. Doufám, že to byla jen náhoda...\n\nToto řešení mi přišlo poněkud směšné, a tak jsem do tohoto systému přes IP anonymizér šťoural stále více. V tuto chvíli jsem to prakticky zabalil, protože chyba byla tak nějak opravena. Systém již při odhlašování nezobrazoval emailovou adresu, takže již nešlo použít něco jako:\n\n/--code php\npreg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n\\--\n\nNa necelý měsíc jsem to pustil z hlavy až včera jsem si na tento web opět vzpomněl. Také jsem byl již na jiné IP adrese což se mi stává celkem často, takže jsem opět vyzkoušel to co před měsícem a světe div se, bezpečností chyba opět funguje. To mě rozproudilo ještě víc, takže jsem opět usedl k editoru a začal jsem psát program, abych si ověřil, že jsem nekecal:\n\n/--code php\n<?php\ntry {\n    $db = new PDO(\'mysql:dbname=emails;host=127.0.0.1\', \'root\', \'\');\n    $stmt = $db->prepare(\"INSERT INTO emails (url_id, email) VALUES (:url_id, :email)\n							ON DUPLICATE KEY UPDATE url_id= :url_id, email= :email\");\n	$stmt->bindParam(\':url_id\', $url_id);\n	$stmt->bindParam(\':email\', $email);\n\n	//1300486 - 2197943\n	for ($i=2197943; $i > 1300486; $i--) {\n		preg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n		if (preg_match(\"#@#\", $match[1])) {\n			$url_id = $i;\n		    $email = $match[1];\n		    echo $i . \': \' . $email . \"\\n\";\n			$stmt->execute();\n		}\n	}\n\n} catch (PDOException $e) {\n    echo \'Connection failed: \' . $e->getMessage();\n}\n\\--\n\nNejsem žádný extra programátor, ale na takovou věc ani být nemusím. Je asi zřejmé, že by tento program trval poměrně dlouhou dobu. Nemá však smysl řešit nějaké paralelní zpracování, když se o to server při vhodně zvoleném programu postará sám. Napsal jsem tedy celkem tři velmi podobné programy. Jeden bral URL adresy od nízkého čísla, druhý od vysokého a třetí na obě strany od středu číselného intervalu. Právě je 17:00, dávám si něco k jídlu a vyrážím do města na hokej...\n\nJak to bylo dál?\n================\nPo tom co hokej nedopadl moc dobře, strávil jsem nějaký čas u piva a vrátil jsem se domů. Bylo pozdě a program pořád běžel. Šel jsem spát a ráno do školy. Program stále běžel. V tuto chvíli již 16 hodin. Odhadem až někdy po 20ti hodinách dolování emailových adres z tohoto serveru jsem opět dostal IP ban. V tu chvíli jsem měl však získáno více než čtvrt milionu unikátních emailových adres. Ono to funguje! **Zde bych měl říct, že jsem tyto emailové adresy nedoloval kvůli nějakému zneužití, maximálně z nich udělám nějakou statistiku**... (-: Chtěl jsem také napsat na email který mají vystavený na webu, to bohužel nefungovalo, protože tento email byl pravděpodobně zrušen.\n\nV tuto chvíli adresy stále zpracovávám, protože celý systém psal někdo moc \"šikovný\" a tak občas systém vrátil místo emailu *Invalid key!* a jindy zase mix náhodných speciálních znaků s čímž jsem nepočítal. Také já jsem byl šikovný, takže jsem sice v programu počítal s unique klíčem, ale v DB jsem ho neudělal a v reklamním systému je jich cca 10% duplicitních.\n\nŽádám tedy o pomoc. Víte komu patří emailová adresa `b2bdm@email.cz`? Komu patří `m-letter.eu`? Kdo zneužívá tak obrovské množství emailových adres? A kde je vůbec bere? Skutečně mě to zajímá, protože takto je to těžko představitelné, ale několik set tisíc adres je skutečně obrovské množství a já stále nevím, kde jsem se tam vzal...',	'2014-02-20 23:48:22',	0,	'0000-00-00 00:00:00',	0),
(67,	'Jaký email je nejvíce využívaný?',	'jaky-email-je-nejvice-vyuzivany',	'Včera jsem psal o bezpečnostní chybě, která umožňuje získat podle mého názoru nezanedbatelně velký vzorek emailových adres. Krom toho, že bych byl rád, aby byla tato chyba opravena, nemám co jiného s touto kolekcí adres dělat. Tak jsem se rozhodl vytvořit nějakou statistiku. Svým způsobem se totiž jedná o dosti specifické uživatele, protože se pravděpodobně jedná z naprosté většiny pouze o ČR a SK uživatele, takže kdo čeká, že bude např. gmail umístěn nějak dobře, možná bude překvapen.\r\n\r\nA protože po diskusích krouží mnoho rádoby matematiků, rád bych teď přesně definoval všechny vstupní a výstupní hodnoty včetně jejich chyb, čímž doufám minimalizuji to, že výsledky někdo špatně pochopí. Všechny data jsou brány z kolekce čítající **384 392 unikátních** emailových adres s tím, že uvažuji zejména u rozložení poskytovatelů emailových schránek chybu 1%. Je to dáno tím, že vstupní data nejsou úplně korektní a ukazuje se, že se dost často vyskytují emaily jako `@seznam.czsms`, `@seznam.cztel`, `@seznam.czwww`, `@seznam.czweb`, `@senam.cz` atd. Většinu takových prohřešků jsem se snažil eliminovat, každopádně není to dokonalé. Osobně bych chybu odhadoval na desetiny, možná ani ne setiny procenta, ale raději ji nechávám větší. Tato chyba je v prvním grafu také graficky znázorněna. Zajímavé je také to, že někteří lidé evidentně chápu input pro zadání emailu jako deník, takže jsou schopni napsat do tohoto řádku všechny své emailové adresy. Stojí za zamyšlení jak správně navrhovat formuláře... Dále jsou pak z výpočtů zastoupení četnosti znaků prvních písmen emailových adres vypuštěny čísla, takže tato dílčí statistika počítá s o něco menší vstupní kolekcí 382 338 emailových adres.\r\n\r\nRozložení poskytovatelů emailových schránek\r\n===========================================\r\nNásledující graf ukazuje počet emailových adres příslušejících ke konkrétní doméně. Konkrétně je zobrazeno prvních 20 největších poskytovatelů a i tak již mají poslední méně než jedno procento velikosti prvního, tedy Seznamu. Ten je v českém zastoupení naprosto bezkonkurenční. Všímejte si prosím takových věcí. Většina programátorů se totiž potkává pouze s lidma \"od gmailu\", ale to je na českém trhu pouze minoritní složka. A je to tak u všeho. Je až překvapivě obrovský nepoměr mezi tím co si většina lidí myslí a skutečností. A tento vzorek již považuji za dostatečnou skutečnost.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=744207493\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nKolikrát jsem slyšel, že jsou Centrum a Atlas mrtvé projekty. To už ani nemá smysl počítat, ale reálně se ukazuje, že tomu tak vůbec není a těmto číslům momentálně věřím, protože už je zde přehazuji několik desítek hodin... (-: Bohužel nemám představu o tom, kolik existuje emailových adres v ČR, ale veřím, že se tvarově graf moc nepohne. Pouze se bude měnit počet na svislé ose.\r\n\r\nDalší zajímavá data\r\n===================\r\nDalší graf ukazuje skutečně velkou hloupost. Ani nevím proč jsem jí vlastně dělal. Jde o početné zastoupení prvních znaků emailových adres. To jsou ty modré pruhy. Červené pruhy jsou pak předpokládaná četnost znaků pro českou abecedu podle \"Jana Králíka .{target:_blank}\":http://www.czech-language.cz/alphabet/alph-prehled.html. Není to poprvé co tuto tabulku četností používám a dá se říci, že s ní souhlasím. Každopádně mám v plánu tyto četnosti ověřit a zaktualizovat, takže se možná tento graf časem malinko pozmění.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=1555577201\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nDalší informací, která již však nemá pevně uchopitelný základ je počet TLD. Lze tedy pouze říci, že ze vzorku zkoumaných dat, tedy ze vzorku emailových adres českých uživatelů mají největší zastoupení koncovky `.cz` (290311), poté `.sk` (88764) a další v pořadí je `.com` (5183), která se však svojí četností již poněkud mimo hru. Zajímavé teké je, že většinu překlepů dělají češi. To může být tím, že jsme prostě nepozorní, nebo jsou programátoři lajdáci. Tato informace je založena na počtu korekcí doménových názvů.\r\n\r\nPoslední již nikterak využitelnou informací je délka adres. Nejdelší adresy jsou `butovice.zlicine.tel.728222069.pouzite.kalhotky@...`, `www.malirstvi.tym.czemail.malirstvi.hruby@...` a `martin.59kenvelo400500600300700800900201@...` Zakrývám alespoň domény, aby někdo neprskal, když už proti tomu tak zbrojím. Naopak nejkratší je adresa, která má se vším všudy 8 znaků: `in@.....`.\r\n\r\nZajímá vás ještě nějaká informace, která se dá z této kolekce emailových adres získat?',	'2014-02-21 17:12:09',	0,	'0000-00-00 00:00:00',	0),
(68,	'Omyly hashování hesel',	'omyly-hashovani-hesel',	'Někdy minulý rok jsem si četl prezentaci \"Michala Špačka .{target:_blank}\":http://www.michalspacek.cz/ o \"hashování hesel .{target:_blank}\":http://www.slideshare.net/spaze/hashe-hesla-develcz-2013 a byl jsem z toho poněkud zklamán. Naprosto souhlasím se vším co tam je, přesto však nemám rád, když se dojde k závěrům, které sice na první pohled dávají smysl a fakt dobře se tak dá argumentovat, ale ve výsledku jsou podle mého názoru některé opravdu chybné. Nedávno kolem mě tato prezentace proplula znova a protože již mám celkem setříděné myšlenky, rozhodl jsem se je sepsat.\n\nTímto článkem nehodlám hatit již zmíněnou prezentaci. Naopak se chci opřít do všech prezentací a výstupů, které něco tvrdí a není to tak docela pravda. Zároveň je také nutno říct, že nebudu řešit funkce typu MD5, protože doufám, že všichni v dnešní době vědí, že funkce MD5 prostě není určena na hashování hesel. Přesto si neodpustím několik vět i o konkrétních implementačních problémech.\n\nOmyl první\n==========\nKdyž jsem se opět dožadoval matematického důkazu o problému cyklického hashování, byl jsem dokázán na \"stackoverflow .{target:_blank}\":http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367, což mě mělo uspokojit. Četl jsem to pozdě v noci, takže jsem to nechal na ráno a ani tak jsem s tím nesouhlasil.\n\nV podstatě se jedná o popsání preimage útoku, který se snaží najít stejný hash jako je hash známý a tím získat původní (nebo jinou fungující) hodnotu hesla, tedy v tuto chvíli jediný zajímavý způsob. Celý důkaz toho, že cyklické hashování není dobrý nápad je prováděn na vlastní funkci a směšně malé množině vstupů. To je první divná věc. Mnohem divnější však je závěr pokusu, který tvrdí, že nekonečný vstup lze namapovat na konečnou množinu. Jedná se tedy o surjektivní zobrazení první množiny na druhou, kdy se každý prvek z první množiny namapuje na všechny prvky menší výstupní podmnožiny. A právě v tomto kroku vidím celou teoretickou úvahu jako chybnou. Žádná hashovací funkce totiž nepočítá s libovolným, nebo dokonce s nekonečným vstupem. Když to rozvedu i na konkrétní funkci MD5, pak nekonečný počet vstupů mapuji na 2^128 výstupů. Reálně (což je to co nás primárně zajímá) však mapuji 2^64 vstupů na 2^128 výstupů (čti bitů). V tu chvíli se však bavíme o injektivním zobrazení, což bylo v původním textu odsouzeno. Jak jsem k tomumo názoru došel? Vycházím z \"RFC 1321 - The MD5 Message-Digest Algorithm .{target:_blank}\":http://www.faqs.org/rfcs/rfc1321.html\n\n> A 64-bit representation of b (the length of the message before the\n> padding bits were added) is appended to the result of the previous\n> step. In the unlikely event that b is greater than 2^64, then only\n> the low-order 64 bits of b are used. (These bits are appended as two\n> 32-bit words and appended low-order word first in accordance with the\n> previous conventions.)\n\nPak už je jen malý krůček k tomu uvědomit si, že 2^64 bitové heslo je jinak řečeno něco kolem 2 exabajtů, což je tak trošku hodně i na uložení, natož na zapamatování. A i kdybych to spočetl blbě - jakože doufám, že ne - několik řádů sem tam je úplně jedno, protože množina na kterou se to mapuje je daleko větší. Stejně tak mi přijde naprosto komická tato ukázka:\n\n/--code\n$output = md5($input); // 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n\\--\n\nPřepíšu to jinak:\n\n/--code\n$output = md5($input); // 340282366920938463463374607431768211456 possibilities\n$output = md5($output); // 340282366920938463463374607431768211455 possibilities\n$output = md5($output); // 340282366920938463463374607431768211454 possibilities\n$output = md5($output); // 340282366920938463463374607431768211453 possibilities\n$output = md5($output); // 340282366920938463463374607431768211452 possibilities\n\\--\n\nVycházíme tedy z 340 undecilionů 282 decilionů 366 nonilionů 920 octilionů 938 septilionů 463 sextilionů 463 quintilionů 374 quadrilionů 607 trilionů 431 bilionů 768 milionů 211 tisíc 456 možností. Jasné? Tuto teorii tedy považuji za čistě teoretickou. Klidně si to heslo zašifrujte undecilionkrát... Ostatně stejný problém byl při šifrování vždy. Klidně se mohlo stát, že klíč od zprávy zašifrované v Enigmě (nebo kdekoliv jinde) uhodnou. Ale nedělalo se to, protože je to prostě jen papírový nesmysl. Ostatně i když se to stane, tak je to prostě debilní smůla, jenže věří snad ještě někdo tomu, že se to stane u celé databáze?\n\nOmyl druhý\n==========\nNyní budu předpokládat, že bude nyní mým cílem zjistit skutečně takové heslo, jaké bylo před zahashováním. Úplně tím tedy odbourám fakt, že dva různé texty budou mít stejný hash. To se může stát, druhá možnost však bude svým charakterem tak úplně jinde, že ji stejně nepůjde např. při přihlašování použít. Pokud tedy chci zjistit heslo z hashe u kterého vím, že bylo několikrát hashováno, nezbývá mi, než jít postupně z hashe až k heslu:\n\n/--code\n7eaefb28c9c3fe4be6997cc5b7fb599f // původní hash\n92b7db0f6d7348d91e90651d31ff9e71\n651a9c9c86f3116a53e2bb6e80bfdf69\n1b929b62a2c822c4a59e688fde2a3a0b\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nJenže jaké teď skutečné heslo? Je to \"heslo\"? Pokud bych byl chytrý a uměl si zapamatovat 32 znaků, moje heslo by určitě bylo \"1b929b62a2c822c4a59e688fde2a3a0b\" a jen bych zmátl všechny okolo. A potom je celkem sranda to, když se vrátíme k čistě teoretickému uvažování a řekněme, že se může stát, že dva hashe budou totožné:\n\n/--code\n1b929b62a2c822c4a59e688fde2a3a0b // původní hash   <-\n... // dlouhá série hashů vedoucích k opakování     |\n651a9c9c86f3116a53e2bb6e80bfdf69                    |-- stejné hashe\n1b929b62a2c822c4a59e688fde2a3a0b   <-----------------\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nVěřte, že mé heslo je teď \"651a9c9c86f3116a53e2bb6e80bfdf69\". Při pokusu o zjištění původu hashe mám dvě možnosti. Mohu najít takový hash, který je před tím prvním, ale jiný než \"955db0b81ef1989b4a4dfeae8061a9a6\", nebo právě \"955db0b81ef1989b4a4dfeae8061a9a6\". V prvním případě je to stejné jako předchozí případ. V druhém však naleznu nejdříve jinou shodu a nejen že dojdu k jinému heslu, ale také úplně přeskočím to správné heslo. Takže v určitém případě může být opakované hashování dokonce ještě bezpečnější! Opět je to pouze teorie, ale chci tím ukázat, že některé argumenty mohou být sice silné, mají však vždy i obrácenou stranu, která není o nic slabší...\n\nChtěl jsem tedy vyvrátit několik zažitých předpokladů, což se mi doufám podařilo. Musím však dodat nesmírně důležitou věc. Neobhajuji zde použití MD5 ani jiné podobné funkce (která tak jako MD5 není k hashování hesel určena). Používejte spíše funkce, které mají složitou výpočetní náročnost a jejich výstup je pro dva stejné vstupy různý. Takovou dobrou funkcí je pro PHP funcke `password_hash`, která byla vytvořena právě kvůli tomu, že v tom programátoři dělají neskutečný bordel. Použití je úplně jednoduché:\n\n/--code php\n<?php\necho password_hash(\'heslo\', PASSWORD_DEFAULT);\n\\--\n\nTato funkce momentálně používá bcrypt, do budoucna je možné použít konstantu PASSWORD_BCRYPT, protože defaultní konstanta může způsob šifrování změnit na nějaký lepší. Stejně jednoduché je i ověření hesla:\n\n/--code php\nif (password_verify(\'heslo\', \'$2y$10$2YOiYB9vFd11vTRBtqqKE.TnrT1ydXuCGsSHXbAKRvUgnpE9VaoES\')) {\n    echo \'Password is valid!\';\n} else {\n    echo \'Invalid password.\';\n}\n\\--\n\nTyto funkce, stejně tak jako dobře použitý kompatibilní `crypt` považuji za naprosto dostatečná řešení a víc se o tom není třeba již <s>nikdy</s> bavit. Tečka.\n\n<span style=\"color:green\">A pod tečkou ještě něco. Čím musím napravit nešťastně volená slova v předchozí větě. Tím že se o tom není již třeba nikdy bavit je myšleno to o čem se ve větě píše, tedy že bcrypt funkce považuji za naprosto dostatečné (v současné době i blízké budoucnosti) a za tím si stojím. Neznamená to však, že teď házím za hlavu celou tuto problematiku. Pokud bych měl tedy předchozí větu opravit, napsal bych asi, že tyto funkce považuji za naprosto dostatečné, nicméně stále má smysl tuto problematiku řešit, protože věřím, že v zřejmě ne malém horizontu let bude i tato funkce nedostatečná. Teď ale není.</span>',	'2014-02-22 14:02:31',	0,	'0000-00-00 00:00:00',	0),
(69,	'Čteme QR kódy bez čtečky',	'cteme-qr-kody-bez-ctecky',	'[* 2139a61c-efc4-4e3c-b630-5c3cbf9258df/qrcode-ahoj.png 200x200 <]\n\nPatříte mezi lidi, kteří se nespokojí pouze se čtečkou QR kódů, ale chcete vědět jak fungují? Nebo co víc jak je přečíst bez použité takové čtečky? Tak to jste na správné adrese. Dnes budu řešit zejména právě čtení QR kódu bez použití čtečky. Celou dobu budu řešit tento QR kód na levé straně, takže doporučuji nepoužívat telefon a počkat až na konec, kde se jeho obsah dozvíte. Zároveň se nebudu nijak opírat o korekci chyb a další jinak důležité věci, ale budu se co nejvíce soustředit právě na přečtení kódu bez použití jakéhokoliv přístroje. Pojďme na to...\n\nTrocha nezbytné teorie\n======================\n[* 312d5904-ab94-4877-9743-8ec902fbc50a/qrcode-parts.png <]\n\nQR kód asi viděl každý. Stejně tak předpokládám, že spoustu lidí tuší, že QR kód dodržuji určitá pravidla, aby jej šlo přečíst strojově. Jedná se zejména o \"finder pattern\", tedy ty velké čtverce, které slouží k zaměření čtečky a určení orientace kódu. Díky tomu, že jsou tři, tak lze QR kód přečíst i pokud je vzhůru nohama. Dalším významným prvkem jsou separátory, které obklopují právě tyto čtverce a slouží k oddělení zaměřovačů od zbytku kódu. Žlutě jsem zvýraznil tzv. \"timing patterns\". Ty se táhnout z rohu do rohu zaměřovacích čtverců, kdy se celou dobu střídá černá a bílá barva a slouží opět pro čtečky například k určení velikosti celého kódu. Na takto malém kódu nejsou žádní informace i verzi, ani korekční body.\n\nNejdůležitější jsou však červené a zelené části. Zde jsou uloženy informace i formátu, které následně také využijeme. Je zajímavé, že se jak červená část, tak zelená část na kódu vždy dvakrát opakuje. Informace je očíslována čísly 1-15 s tím, že kolem levého horního zaměřovače je informace celá a ta samá informace je ještě rozdělena a umístěna kolem zbylých dvou zaměřovačů. Je zde ještě jedna zajímavost. V levém dolním rohu nad číslem 9 je černé místo, tzv. \"dark module\". Toto místo by mělo být na všech kódech černé. Jedná se přebytečné místo, které vzniká při zdvojování informace o formátu. Podle specifikace by to tak mělo být, ale ne vždy to platí. Pro nás je však zajímavá jediná část z celé 15 bitů dlouhé informace a to konkrétně bity umístněné na pozici 11, 12 a 13, tedy v zelené části. Právě ty si nesou tu nejdůležitější informaci o masce. Všechny ostatní části informace slouží ke korekci chyb. Celkově se ve výsledku ukáže, že kromě samotné informace je v QR kódu sloustu \"zbytečných\" věcí, které informaci nenesou. V mašem případě je tedy maska `111` (černé místo je 1 a bílé 0). Tuto informaci je však ještě potřeba dekódovat pomocí XOR součtu přičtením hodnoty `101`, tedy:\n\n/--code\n111\n101 /XOR\n---\n010\n\\--\n\nCelá dekódovací maska je `101010000010010`, ale pro naší potřebu je potřeba pouze část `101`. Ještě než vysvětlím co to maska je, uvedu zde všechny hodnoty jaké může maska mít:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr><td>Hodnota masky</td><td>Podmínka masky</td></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>000</td>\n      <td>(i + j) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>001</td>\n      <td>i mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>**010**</td>\n      <td>**j mod 3 = 0**</td>\n    </tr>\n    <tr>\n      <td>011</td>\n      <td>(i + j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>100</td>\n      <td>((i div 2) + (j div 3)) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>101</td>\n      <td>(i j) mod 2 + (i j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>110</td>\n      <td>((i j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>111</td>\n      <td>((i+j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n  </tbody>\n</table>\n\nTo může vypadat děsivě, ale hned vysvětlím. Podle toho jakou má kód masku vezmeme vzorec a dosadíme za **j** číslo sloupce. V našem případě se tedy bavíme o prvním a pak každém třetím sloupci. Pro tyto sloupce platí, že na nich musíme provést negaci, tedy otočit barvy. Tím QR kód odmaskujeme. Toto však platí pouze pro částí kde je opravdu nějaká informace, nikoliv pro zaměřovače, nebo například části nesoucí formátovací informaci. Toto maskování slouží k zamíchání barevných polí. Nestane se tak, že by byl kód nejednoznačný. Při kódování se totiž porovnávají jednotlivé masky, každá maska má nějaké skóré jednoznačnosti a ve výsledku se vybere ta nejjednoznačnější. Celé odmaskování je znázorněno na obrázku níže. Pravý černý QR kód je již odmaskovaný a nic nebrání jej přečíst. V tuto chvíli však již pouze bez použití čtečky.\n\n[* 63e85abb-b86a-4877-9640-fb70b4cd2542/qrcode-important.png 300x300 <]\n[* 3951a3ea-5f53-4af9-9c01-a45fd71dd5b0/qrcode-unmasked.png 300x300 *]\n\nHrajeme si na čtečku\n====================\n[* 0ed74ba7-ddec-40da-ab12-4e6b8d82103c/qrcode-decode.png <]\n\nPředchozí část byla možná trošku složitější, ale když se na to podíváte zpětně je to vlastně velice jednoduché. Stačí přečíst 3 bity z celého kódu, provést jednoduchý XOR a jak se ukáže dále, tak stačí invertovat pouze jeden sloupec, protože více jich není potřeba.\n\nPodívejte se nyní na levý obrázek. Ten ukazuje, jak budeme číst uloženou informaci. Barevně znázorněná část je kompletní informace. Zbytek kódu je pro nás v tuto chvíli jen odpad. Barevně zvýrazněná část se ještě dělí na tři podčásti. Červená oblast obsahuje informaci o módu. Bity čteme vždy podle čísel a šipek. Tento QR kód je tedy v módu `0100` což je mód \"BYTE\". Data tedy budeme rozdělovat tak, aby měla každý část 1 byte, tedy 8 bitů. Tyto módy a další informace jsou velmi podrobně popsány v oficiální dokumentaci. Modrá část nám ještě prozrazuje informaci o délce, binárně tedy `00000100` což je v desítkové soustavě číslo 4. Takže informace v tomto QR kódu má délku 4 znaky. Opíšeme si tedy řadu bitů:\n\n/--code\n01100001 01101000 01101111 01101010\n\\--\n\nZde by mohl být trošku zádrhel pro lidi, co neumí ASCII tabulku. Prozradím tedy malý fígl. Pokud binární čásla prevedeme do decimální soustavy, což je velmi jednoduché, získáme následující zápis:\n\n/--code\n97 104 111 106\n\\--\n\nA teď už je to jen posunutá abeceda, protože číslo 97 je malé **a**. Výsledkem je tedy po chvilce abecedování:\n\n/--code\na h o j\n\\--\n\nTo nebylo tak těžké, že? Je to sice absurdní a pravděpodobně nikdy nikoho neuvidím s tužkou a papírem před QR kódem, ale i tak si myslím, že je dobré tyto věci vědět, když už se QR kód používá tak často. Doporučuji všem přečíst si dokument *ISO/IEC 18004:2006*, který řeší právě QR kódy. Je to nesmírně zajímavý dokument plný obrázků a úplných popisků, ačkoliv je i v tomto dokumentu pár drobných chyb.',	'2014-02-28 12:49:05',	0,	'0000-00-00 00:00:00',	0),
(70,	'AJAX upload souborů v Nette pomocí Fine Uploaderu #2',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2',	'\"Dříve\":http://zlml.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu jsem psal o tom, jak použít Fine Uploader jakožto nástroj pro AJAXové nahrávání souborů na server. Původní článek však platí pouze pro verzi `3.*`, která je dnes již zastaralá. Pojďme si dnes ukázat v podstatě to samé, ale pro novější verzi `4.3+`, která se v učitých směrech poměrně zásadně liší od svého předchůdce. Tentokrát se to však pokusím vyřešit co nejjednodušeji.\n\nZačátek je vlastně úplně stejný. Musíme nalinkovat javascriptové soubory:\n\n/--code html\n<!-- jQuery -->\n<script src=\"{$basePath}/js/jquery.fineuploader-4.3.1.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití je úplně jednoduché, ve zjednodušené formě:\n\n/--code html\n<div id=\"image-uploader\"></div>\n\\--\n\nSnažím se ukázat opravdu jen kritické minimum, protože ty základní věci jsou stejné, případně dohledatelné v dokumentaci, takže se dají oba dva návody z velké části doplnit. Minule jsem však zatáhl do ukázek i poměrně hodně balastu, takže ten u staré verze nechám, ale bude následovat opravdu jen to nejnutnější.\n\nStejně tedy jako v předchozí verzi následuje javascriptový spouštěcí kód. Zde již vznikají určité odlišnosti:\n\n/--code javascript\n$(function () {\n	$(\'#image-uploader\').fineUploader({\n		debug: true, //hodí se pro lazení\n		request: {\n			endpoint: \'pictures?do=uploadPicture\'\n		},\n		retry: {\n			enableAuto: true\n		}\n	});\n});\n\\--\n\nPoužití je tedy téměř stejné, až na to, že jsem úplně vypustil překlad textů. V této nové verzi jsou totiž novinkou šablony (ostatně proto také nové číslo verze). Uživatel-programátor má tak více pod kontrolou výsledný vzhled uploaderu:\n\n/--code html\n<script type=\"text/template\" id=\"qq-template\">\n	<div class=\"qq-uploader-selector qq-uploader\">\n		<div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n			<span>Přetáhněte soubory sem</span>\n		</div>\n		<div class=\"qq-upload-button-selector qq-upload-button\">\n			<div>Klikněte, nebo přetáhněte obrázky</div>\n		</div>\n        <span class=\"qq-drop-processing-selector qq-drop-processing\">\n           <span>Zpracovávám přetažené soubory...</span>\n           <span class=\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\"></span>\n        </span>\n		<ul class=\"qq-upload-list-selector qq-upload-list\">\n			<li>\n				<div class=\"qq-progress-bar-container-selector\">\n					<div class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n				</div>\n				<span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n				<img class=\"qq-thumbnail-selector\" qq-max-size=\"100\" qq-server-scale>\n				<span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"></span>\n				<span class=\"qq-upload-file-selector qq-upload-file\"></span>\n				<input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n				<span class=\"qq-upload-size-selector qq-upload-size\"></span>\n				<a class=\"qq-upload-cancel-selector qq-upload-cancel\" href=\"#\">Zrušit</a>\n				<a class=\"qq-upload-retry-selector qq-upload-retry\" href=\"#\">Opakovat</a>\n				<a class=\"qq-upload-delete-selector qq-upload-delete\" href=\"#\">Smazat</a>\n				<span class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n			</li>\n		</ul>\n	</div>\n</script>\n\\--\n\nA opět následuje zpracování v handleru:\n\n/--code php\npublic function handleUploadPicture() {\n	$uploader = new \\UploadHandler();\n	$uploader->allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\");\n	$result = $uploader->handleUpload(__DIR__ . \'/../../www/uploads\');\n	$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nZde celkem není co pokazit, ale pokud by bylo potřeba vrátit chybu, provede se to opět pomocí `JsonResponse`:\n\n/--code php\n$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse(array(\n		\'error\' => $exc->getMessage(),\n)));\n\\--\n\nSamotná třída `UploadHandler` je pak opět k nalezení na \"GitHubu\":https://github.com/Widen/fine-uploader-server/blob/master/php/traditional/handler.php. Tento návod tedy mohu zakončit vlastní citací:\n\n> A to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například podle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit. To konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2014-03-03 21:15:13',	0,	'0000-00-00 00:00:00',	0),
(71,	'Sbohem NDBT, vítej Doctrine',	'sbohem-ndbt-vitej-doctrine',	'Byl jsem požádán, abych napsal nejenom důvod přechodu z Nette Database na Doctrine, ale obecně co mě k tomu vedlo a jak takový přechod vlastně učinit. Na úvod bych však chtěl zdůraznit, že nejsem žádný extra programátor, vlastně to ani nestuduji, takže vše co budu ukazovat a vysvětlovat je tedy z mého pohledu a lecjakého OOP znalce by tento text mohl pobouřit... (-:\n\nNásledující text používá \"Kdyby\\Doctrine\":https://github.com/Kdyby/Doctrine, nevidím důvod proč ve spojení s Nette používat něco jiného. Je to dobrá knihovna.\n\nSbohem NDBT\n===========\nNette Database Table a obecně celé Nette Database je úžasná část frameworku a spokojeně jsem ji používal po velmi dlouhou dobu. Nikdy jsem neholdoval pokřikům, že je NDBT zabugované (jako někteří) a i když jsem vyzkoušel i jiné alternativy, vždy jsem se spokojeně vracel právě k NDBT. Použití je velice intuitivní a dobře se s tím zachází:\n\nModel:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Nette\\Database\\Context */\n	private $database;\n\n	public function __construct(Nette\\Database\\Context $context) {\n		$this->database = $context;\n	}\n\n	public function getAllPosts() {\n		return $this->database->table(\'posts\')->where(\'release_date < NOW()\');\n	}\n\n}\n\\--\n\nPresenter:\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$this->template->posts = $this->posts->getAllPosts();\n	}\n\n}\n\\--\n\nJe to jednoduché a jasné. Takové věci mám prostě rád. V modelové třídě mám jak select metody, tak insert metody, takže bych tomu správně neměl říkat repository, ale abych byl upřímný, tak je mi toto názvosloví celkem volné. Do takové objektu si prostě dám to co chci (tak jak mi to dává smysl). Nepřijde mi to vůbec podstatné. Tahání dat z databáze má však ještě jednu vrstvu a tou je vykreslování.\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->related(\'posts_tags\')->order(\'tag_id ASC\') as $post_tag}\n			<a n:href=\"Tag:default, $post_tag->tag->name\">\n				<span style=\"background: #{$post_tag->tag->color}\">{$post_tag->tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nA to je věc, která mě dlouhou dobu trápila. Dá se čekat, že když v databázi existuje jakási vazba mezi příspěvkem a tagem, tak že tuto vazbu budu chtít nějak využít. A to pokud možno co nejvíce pohodlně. A co nejvíce pohodlně znamená, že v okamžik, kdy budu pracovat s příspěvkem a vzpomenu si, že potřebuji také tagy, tak tyto tagy také dostanu. Bohužel musím znát také spojovací tabulku, která nemá (minimálně v tomto případě) žádný faktický smysl a celkově práce s takto \"dopřivázanou\" tabulkou není vůbec pohodlná a už vůbec ne intuitivní. Dává to smysl a asi to tak být musí, takže proti NDBT žádná, ale tak nějak vnitřně jsem hledal něco lepšího (čti více vyhovujícího mým požadavkům).\n\nVítej Doctrine\n==============\nSchválně se snažím vše popisovat podle mých myšlenkových pochodů, proto i nadále budu řešit úplně ten samý problém, jen s použitím Doctrine. Nutno ještě dodat, že Doctrine rozhodně nebyla jasná volba. Opět mi dlouho trvalo, než jsem obecně ORM přišel na chuť. Ještě před Doctrine jsem nějakou dobu experimentoval s \"Lean Mapperem\":http://www.leanmapper.com/ od Vojtěcha Kohouta (Tharos). Malou nevýhodou je, že téměř veškerá dokumentace je v brutálně dlouhém vláknu na Nette fóru, které má v tuto chvíli **1023 příspěvků**, takže je to občas dřina, ale myslím si, že je to skutečně povedená knihovna. Vojtěch Kohout má skutečně dobré myšlenky. Nicméně jsem prostě chtěl přijít Doctrine na chuť, takže jsem i Lean Mapper opustil. Občas dělám radikální změny, pokud by však někdo vyloženě potřeboval důvod k tomu začít s Doctrine (alespoň dočasně), pak tedy jeden mohu nabídnout. A bude velmi krátký. Vidíte někdy jako požadavek na zaměstnance znalost Lean Mapperu, nebo ActiveRow? Pokud ne, tak začněte s tím co se tam ukazuje často. Doctrine.\n\nAle zpět k tématu. Pojďme si ukázat modelovou část podle mě:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Kdyby\\Doctrine\\EntityDao */\n	private $dao;\n\n	public function __construct(Kdyby\\Doctrine\\EntityDao $dao) {\n		$this->dao = $dao;\n	}\n\n	public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {\n		return $this->dao->findBy($criteria, $orderBy, $limit, $offset);\n	}\n\n}\n\\--\n\nVelmi podobné jako u předchozího modelu. Asi by šlo si napsat nějakou `__call` metodu, protože se dost často volá to co už je v DAO objektu (viz níže), ale kdo si to jak poslepuje, tak to bude mít... A co prezentační vrstva?\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$posts = $this->posts->findBy(array());\n	}\n\n}\n\\--\n\nTo je také dost podobné. Pole kritérií potom slouží k dodatečnému filtrování ve tvaru např. `[\'id\' => 21]`, tedy předává se to, co se má použít i v SQL WHERE klauzuli. Tento zápis je mi poměrně blízký, protože jsem ho používal při komunikaci s jedním SOAP serverem. Ok, co na to šablona?\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->tags as $tag}\n			<a n:href=\"Search:default, $tag->name\">\n				<span style=\"background: #{$tag->color}\">{$tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nTak to je podle mě úplně super výsledek. Maximálně intuitivní a nic víc splňuje to má očekávání. Je však asi zřejmé, že jsem úplně vypustil jakoukoliv informaci o spojovací tabulce. A také jsem ještě neřekl, co je to `EntityDao`, se kterým se pracuje v modelu. Vlastně je to úplně jednoduché. V konfiguračním souboru definuji, že chci pracovat s jakýmsi DAO objektem, tedy objektem, který oproti repository umožňuje data nejen číst, ale také ukládat (opět pouze OOP slovíčkaření).\n\n/--code neon\nservices:\n	- App\\Pictures(@doctrine.dao(Entity\\Picture))\n	- App\\Posts(@doctrine.dao(Entity\\Post))\n	- App\\Tags(@doctrine.dao(Entity\\Tag))\n	- App\\Users(@doctrine.dao(Entity\\User))\n\\--\n\nFajn, teď mám tedy v každé modelové třídě DAO objekt. Ten obsahuje několik metod, které výrazně usnadňují práci s Doctrine (\"source\":https://github.com/Kdyby/Doctrine/blob/master/src/Kdyby/Doctrine/EntityDao.php). Do tohoto objektu předávám jakousi entitu. To je objekt, který reprezentuje strukturu databázové tabulky. To možná není napsáno úplně šťastně, ale prakticky to tak skutečně většinou je. Taková entita může vypadat například takto:\n\n/--code php\nnamespace Entity;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name=\"posts\")\n */\nclass Post extends Doctrine\\Entities\\BaseEntity {\n\n	/**\n	 * @ORM\\ManyToMany(targetEntity=\"Tag\", inversedBy=\"posts\", cascade={\"persist\"})\n	 * @ORM\\JoinTable(name=\"posts_tags\")\n	 * @ORM\\OrderBy({\"name\" = \"ASC\"})\n	 */\n	protected $tags;\n\n	/**\n	 * @ORM\\Id\n	 * @ORM\\Column(type=\"integer\")\n	 * @ORM\\GeneratedValue\n	 */\n	protected $id;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $title;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $slug;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $body;\n\n	/** @ORM\\Column(type=\"datetime\") */\n	protected $date;\n\n}\n\\--\n\nZde je právě důležité to, že rovnou ukazuji, kde je entita reprezentující tagy (která vypadá podobně jako tato), jak se k ní dostanu a dokonce jak se má řadit. Tedy všechny tyto informace jsem ze šablony odstranil. Pro mě je to tedy úžasný pokrok, protože jsem dosáhl toho co jsem chtěl. Aby se mi s databází pracovalo dobře.\n\nNo dobře, ale...\n================\nA teď je právě čas na některé dotazy, které vznikly při přípravě tohoto článku. Tak například co když chceš položit vlastní dotaz, v Nette Database je to přeci snadné. V Doctrine \"také\":https://bitbucket.org/mrtnzlml/zlml.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/Posts.php?at=master#cl-128. V tom by ORM nemělo nijak zásadně bránit...\n\nDalší věc je, že v presenteru stále zůstává jistá závislost na struktuře tabulek. Konkrétně opět mluvím o poli kritérií. Jak se úplně zbavit této závislosti a mít pokud možno vše tak, aby když změním strukturu, tak to změním jen někde a ne všude? K tomu se dají použít třeba query objekty, které v sobě drží podobu potřebného SQL dotazu, takže místo toho, abych stále ťukal ten samý dotaz, jen jinde, tak jej schovám do třídy a právě tu pak používám. Budoucí změna se pak pravděpodobně bude týkat právě pouze toho objektu a případně entit. Ono toto asi nejde úplně odstínit (nebo spíš nevím jak), protože vždy je potřeba data i nahrávat a tedy stanovit určitou hranici mezi tím co je závislé na databázi a co už není. Nicméně uvážím-li, že budu měnit strukturu tabulky třeba kvůli tomu, že chci přidat nová data, stejně budu do kódu muset jít a někde ty data vzít a někam je dát. Proto je toto možná úplně zbytečné řešit, protože tato závislost nikdy nepůjde úplně odstranit.\n\nDalší věc je trošku záludná. Týká se tříd pro vazební tabulky. Pokud tedy ukládám M:N vazbu jako v předchozím textu, tím myslím, že mi jde pouze o to, že chci uložit do této tabulky cizí klíče, tak se o nic nemusím starat a stačí mi pouze onen dokumentační komentář v entitě `Post` nad proměnnou `protected $tags`, kde je definováno vše potřebné. Problémové je, když chci uložit data i do vazební tabulky. Zde bych rád citoval jeden příspěvek ze StackOverflow, protože si myslím, že tam je vše řečeno naprosto přesně.\n\n> A Many-To-Many association with additional values is not a Many-To-Many, but is indeed a new entity, since it now has an identifier (the two relations to the connected entities) and values.\n\nA přesně takto je s tím tedy potřeba zacházet. Už se nebavíme o vazební tabulce. Už se bavíme o normální tabulce, která vyžaduje svoji entitu a pouze obsahuje dva cizí klíče místo běžného jednoho.\n\nDoufám, že se mi v tomto článku svojí délkou limitně blížící se k nekonečnu podařilo zodpovědět všechny dotazy a objasnit všechny pochybnosti. Pokud ne, můžete se na celou problematiku podívat pod drobnohledem ještě \"zde\":https://bitbucket.org/mrtnzlml/zlml.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/?at=master. Máte na celou problematiku jiný názor, nebo to jak to dělám já je kompletně špatně? Sem s tím... (-:',	'2014-03-11 19:34:00',	0,	'0000-00-00 00:00:00',	0),
(72,	'Orion login stojí za prd',	'orion-login-stoji-za-prd',	'Když jsem dříve připravoval \"prezentaci o Nette Frameworku\":http://zlml.cz/prednaska-z-nette-na-zcu, hledal jsem nějaký vhodný příklad, na kterém bych demonstroval zranitelnost webových aplikací. Úspešně jsem vyzkoušel pár eshopů a jednu stránku, která slouží ke školním účelům, ale není nijak oficiálně vedená pod univerzitou. Právě zde mě napadlo vyzkoušet také univerzitní systémy. A nestačil jsem se divit.\n\nPozadí univerzitního přihlašování\n=================================\nVeškeré ověřování práv a identit putuje přes WebKDC server. Tento server komunikuje s Kerberosem a dohromady tvoří systém, který umožní přihlášení pomocí univerzitních loginů. Celkově proti tomuto systému nemám vůbec nic. Mám však hodně výhrad k jeho konkrétní implementaci. Konkrétní web servery (tam kde jsou umístěny aplikace vyžadující přihlášení) komunikují se vzdáleným WebKDC serverem. Tento server zajistí korektní ověření uživatele (spolupráce s Kerberos) a vráti informaci o úspěšném ověření. Paráda. Vnitřně velmi sofistikovaný systém funguje a umožňuje SSO (Single Sign-On) napříč celou infrastrukturou. Platí to tedy i pro aplikace mimo univerzitní doménu. Zjednodušeně popsáno, ale tématem tohoto článku není ta část, která \"spolehlivě funguje\":http://webauth.stanford.edu/, ale ta část, která nefunguje.\n\n/--code\n WEBKDC <----------> KERBEROS\n   |||\n   |||\n WEBAUTH (server s aplikací vyžadující přihlášení)\n    |\n    |\n STUDENT\n\\--\n\nJako poměrně zásadní fakt vidím to, že dokud student neklikne na \"LOGIN\", tak ho tento systém nepřihlásí (většinou). Nachází se tedy na úrovni \"WEBAUTH\", ale vidí jen omezenou stránku. Jakmile se chce přihlásit, aplikace jej přesměruje na WebKDC login-server, kde může vyplnit své přihlašovací informace, nebo je již přihlášen někdy z dřívější doby a v obou případech je přesměrován zpět na server s webovou aplikací. Už vidíte ten problém? :-)\n\nXSS\" onclick=\"alert(document.cookie); //:-)\n===========================================\nPrávě komunikace mezi WEBAUTH a WEBKDC je pro ověření naprosto zásadní, ale díky tomu, že zřejmě není nastavena žádná implementační laťka, tzn. že kdokoliv chce přihlašovat pomocí tohoto systému tak si to prostě nějak naprogramuje, vznikají bezpečnostní bublinky. Pravděpodobně neexistuje žádná konvence jak tento systém implementovat, takže neexistují ani takové funkce, jako je třeba ověřování již aktivního přihlášení atd. Může se tedy stát, že budu přihlášen (ověřen) ve webové aplikaci, ale na WEBKDC jsem odhlášen, protože WEBAUTH už se o to v tuto chvíli nestará (ten je přihlášen).\n\nDíky tomuto poznatku mohu velmi jednoduše vše co jsem teď napsal zapomenout, protože se dá celé složité schéma zjednodušit na toto:\n\n/--code\n WEBAUTH                   WEB-APP\n    |          resp.          |\n    |                         |\n STUDENT                   STUDENT\n\\--\n\nTak moment. Není to úplně normální přihlášení tak jako je na jakékoliv jiné úplně obyčejné stránce? Uživatel (student, profesor, administrátor) je přihlášen a teď už je to pouze nudná otrocká práce. Myslím, že mohu prozradit, že je stránka (čti univerzitní projekty) náchylná na session hijacking, na to přijde každý blbec, který o tom četl na wiki. A asi nemá smysl tajit, že XSS je naprosto reálná (a vyzkoušená) hrozba. Nebudu však říkat kde. A vzhledem k tomu, že tento systém webových portálů (IBM Web-Sphere Portal) není žádná domácí výroba, tak předpokládám, že stejný problém budou mít i další univerzity.\n\n/--code\n WEB-APP1     WEB-APP2\n    |            |\n    |----------EVA\n STUDENT\n\\--\n\nOd první chvíle, kdy jsem na tento problém upozorňoval poprvé jsou některé věci v současné době na serverech pozměněny, ale to zásadní zůstává pořád stejné. Nezáleží na tom co je v pozadí, když je řetěz tak silný, jak je silný jeho nejslabší článek a zvlášť, když ten silný zbytek řetězu skoro ani není potřeba...',	'2014-03-16 17:00:29',	0,	'0000-00-00 00:00:00',	0),
(73,	'Plzeňský Barcamp - láska na první pohled',	'plzensky-barcamp-laska-na-prvni-pohled',	'Ačkoliv jsem z dřívějších barcampů sledoval záznamy, tak jsem byl fakticky na barcampu úplně poprvé a rovnou jsem měl tu čest přednášet. Než se však dostanu k samotné přednášce, rád bych zde napsal nějaký feedback. Celkově jsem z Plzeňského Barcampu skutečně nadšen. Skvělá atmosféra, fajn lidi, spoustu jídla, alkoholu možná až moc... :-))\n\nNa druhou stranu došlo i k pár přešlapům. Některé mě mrzí více, jiné ani tak ne, každopádně... Skutečně mě mrzí to, že nebyla nahrávána na video každá přednáška.\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/eshopkonzultant\">@eshopkonzultant</a> Honzo, máme to v plánu. Pokud nám ho nic nenaruší, chtěli bychom určitě záznamy dodat nejdéle do měsíce po skončení akce.</p>&mdash; Plzeňský Barcamp (@PlzenskyBarcamp) <a href=\"https://twitter.com/PlzenskyBarcamp/statuses/454275681665687552\">April 10, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nTo se moc nepovedlo. Mrzí mě to ze dvou důvodů. Jednak jsem tak nějak slíbil, že má přednáška bude potom na netu, to však není ten závažnější problém. Daleko více mě mrzí fakt, že se teď nemohu podívat na přednášky ostatních protože jsem byl jinde. Na barcampu bylo totiž spoustu zajímavých témat.\n\nDalší už jen krátce abych nezněl moc negativně, protože se mi na barcampu opravdu líbilo a zase tak moc mě tyto věci neštvou. Přístup k netu jen pro přednášející. Měl jsem možnost toho využít, nevyužil jsem, takže o nic nejde, jen bych veřejnou wifi na takových akcích čekal. Další jsou samolepky se jménem při registraci. No já nevím jak ostatním, mě prostě vůbec nedržela a než jsem došel do prvního patra, tak jsem měl na zádech jmenovku se jménem Martina. Bohužel bez čísla. Zdravím Martinu! :-) Poslední věc, která mě mohla dost uzemnit byla ztracená prezentace. Svojí prezentaci jsem na barcamp odeslal předem jak stálo v emailu, ale když jsem se po ní ptal, tak nebyla k nalezení. Naštěstí jsem měl plán B. Uff...\n\nPřednášky\n=========\nPostupně jsem se snažil projít ty nejzajímavější přednášky. Zde je jejich přehled:\n\n*Machine learning, aneb od našeptávače k porozumění řeči (\"Jan Švec .{target:_blank}\":https://twitter.com/honza_svec)* - přednáška o strojovém učení, porozumění řeči a chápání významu psaného i mluveného textu. Některým lidem tato přednáška přišla obsahově zajímavá a skutečně byla, každopádně tyto informace jsem z velké většiny již znal, protože jsem je slyšel již dříve a zase tolik se toho v tomto oboru nemění.\n\n*Procesory letajici, tikajici, hrajici a komunikujici (\"Radek Voltr .{target:_blank}\":https://twitter.com/crawlerdev)* - to je zase opak toho prvního. Některým lidem to nepřišlo moc zajímavé, protože tyto věci znají. Já je tolik neznám a i z důvodu svých budoucích prací do školy pro mě byla tato přednáška přínosným přehledem toho jak lze nacpat slušný výpočetní výkon na malou mršku.\n\n*Virtualizace a cloudy v dnešním IT (\"Milan Brych .{target:_blank}\":http://www.orgis.cz/cs/)* - nejvíce debatované a kontroverzní téma. Každopádně Milan se toho ujal dobře a ačkoliv tam bylo spoustu lidí z oboru, tak i v publiku došlo k debatám lidí s naprosto odlišným názorem. A zpětně musím dodat, že jednoznačně souhlasím s tím, že cloud jako takový je cloudem teprve tehdy, pokud je geograficky rozložen a má dostatečnou redundanci strojů. Někdo na přednášce zmiňoval cloud funkci u NAS serverů. V tu chvíli jsem se musel pousmát...\n\n*Věrnostní program a jeho odvrácená tvář (\"Marek Mencl .{target:_blank}\":https://twitter.com/mmencl)* - asi nejlepší přenáška. Zpětný pohled za projektem, který sice nějak dopadl, ale jeho průběh nebyl úplně hladký. Přednáška byla plná reálných problémů z praxe. Super. Prostě super. Jestli bude záznam, tak doporučuji!\n\n*Pracujte v trenýrkách z kavárny. Nebo ne? (\"David Šmehlík .{target:_blank}\":https://twitter.com/davidsmehlik)* - abych byl upřímný, tak na tuto přednášku jsem šel jen proto, že jsem neměl kam jinam a vybral jsem tak nejmenší zlo. Každopádně rychle jsem zjistil, že jsem udělal dobře, protože celé povídání bylo velmi zajímavé a motivující. I přes původní nedůvěru považuji tuto přednášku za druhou nejlepší. Sorry, Marek byl lepší... :-))\n\n*O e-shopech, o automatickém výpočtu nabídek za prokliky na Heurece a o tom, kde je problém doopravdy (\"Michal Janík .{target:_blank}\":https://twitter.com/michaljanik)* - zde to bylo celkem jednoduché. Jít na populární blbost (dle zpětných názorů ostatních), nebo na SEO (jak slyším SEO, tak utíkám), nebo na prezentaci neúspěšného portálu? Vybral jsem si tedy přednášku o e-shopech. Nejsem eshopista, takže to pro mě nemělo takovou přidanou hodnotu a myslím si, že kdokoliv nad problémy obchodu přemýšlí, tak dokonverguje ke stejným závěrům jako jsou v prezentaci. Každopádně říct, že to bylo nezajímavé by bylo nejen nefér, ale ani by to nebyla pravda.\n\nOpět musím zopakovat, že mě mrzí absence kamer u ostatních přednášek.\n\nOd Caesara ke QR kódům\n======================\nA konečně k mé přednášce. :-))\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Přednáška o kódování a Thomasu Youngovi na <a href=\"https://twitter.com/search?q=%23barcampcz&amp;src=hash\">#barcampcz</a> je kulervoucí.</p>&mdash; Pavel Pajkrt (@PavelAbbePajkrt) <a href=\"https://twitter.com/PavelAbbePajkrt/statuses/455008230444638208\">April 12, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nA zde je:\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/33460846\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nDěkuji všem posluchačům. Byl jsem skutečně nadšen, když za mnou pak někdo v průběhu dne přišel a děkoval. To bylo kouzelné. Nesmírně si toho vážím. Každopádně abych se jen nevychvaloval, tak cítím určitý dluh vůči posluchačům, protože ačkoliv se mi s tím Luboš Majner i Milan Brych snažili pomoct (díky!), tak jsem nedokázal závěrečnou problematiku úplně objasnit. A vzhledem k tomu, že jsem se pak ještě o těchto věcech několikrát bavil, tak přibližně tuším v čem byly problémy.\n\nTak prvně padl dotaz z kterého bylo jasné, že jsem něco řekl fakt špatně. Proč to šifrovat tak složitě? Proč neposlat rovnou surovou zprávu, když to nejde odposlechnout? To je velice jednoduché. Je sice pravda, že (alespoň v současné době) kvantový signál nelze odposlechnout, nic však nebrání Evě zastřelit Boba a zprávu si jednoduše přečíst. To se u šifrovaného signálu nemůže stát.\n\nA jak je tedy možné že ten signál nelze odposlechnout? Jde o to, že přenášená zpráva není ve formě informace, ale přenáší se pomocí nějakého fyzikálního principu. Takže se nelze připojit na optický kabel aniž by to nebylo zjistitelné. Každopádně jsem rád za závěrečnou diskusi, jelikož byla velmi přínosná a uvědomil jsem si věci, které jsem předtím neřešil. Například komunikaci po veřejném kanálu a ověření, že Alice skutečně mluví s Bobem a ne s Evou. Přečtěte si článek tento \"http://aldebaran.cz/bulletin/2005_14_kry.php .{target:_blank}\":http://aldebaran.cz/bulletin/2005_14_kry.php. Konkrétně poslední část o spolehlivosti metody. Již rozumím padlým dotazům a dávám posluchačům za pravdu. Beru to jako poučení a příští rok už budu tento problém schopen podat ještě líp. Doufám... :-)\n\nJo a přišel si to poslechnout i David Grudl. Yaaay! :-D',	'2014-04-13 13:31:22',	0,	'0000-00-00 00:00:00',	0),
(74,	'Znovupoužitelný formulář',	'znovupouzitelny-formular',	'Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\nMotivace\n========\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\nPresenter\n=========\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n/--code php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n	/** @var \\ActualityFactory @inject */\n	public $actualityFactory;\n\n	private $id;\n\n	public function actionAktualita($id = NULL) {\n		$this->id = $id;\n	}\n\n	protected function createComponentForm() {\n		$control = $this->actualityFactory->create($this->id);\n		$control[\'form\']->onSuccess[] = function () {\n			$this->redirect(\'default\');\n		};\n		return $control;\n	}\n\n}\n\\--\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control[\'form\']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\nFactory\n=======\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n/--code php\n<?php\n\ninterface IActualityFactory {\n\n	/** @return \\Cntrl\\Actuality */\n	public function create();\n\n}\n\\--\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n/--code php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new Cntrl\\Actuality;\n		return $service;\n	}\n\n}\n\\--\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n/--code php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n	private $actualities;\n\n	public function __construct(App\\Actualities $actualities) {\n		$this->actualities = $actualities;\n	}\n\n	public function create($id) {\n		return new \\Cntrl\\Actuality($this->actualities, $id);\n	}\n\n}\n\\--\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	- ActualityFactory\n\\--\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\nSamotná komponenta\n==================\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n/--code php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n	private $actualities;\n	private $actuality;\n\n	public function __construct(App\\Actualities $actualities, $id) {\n		parent::__construct();\n		$this->actualities = $actualities;\n		$this->actuality = $this->actualities->findOneBy([\'id\' => $id]);\n	}\n\n	public function render() {\n		$this->template->setFile(__DIR__ . \'/Actuality.latte\');\n		$this->template->render();\n	}\n\n	protected function createComponentForm() {\n		$form = new UI\\Form;\n		$form->addText(\'headline\', \'Titulek:\');\n		$form->addTextArea(\'text\', \'Text:\');\n		$form->addSubmit(\'send\', \'Uložit\');\n		if($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n			$form->setDefaults(array(\n				\'headline\' => $this->actuality->headline,\n				\'text\' => $this->actuality->text,\n			));\n		}\n		$form->onSuccess[] = $this->actualityFormSucceeded;\n		return $form;\n	}\n\n	public function actualityFormSucceeded(UI\\Form $form) {\n		$values = $form->getValues();\n		try {\n			if(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n				$this->actuality = new Entity\\Actuality();\n			}\n			$this->actuality->headline = $values->headline;\n			$this->actuality->text = $values->text;\n			$this->actuality->date = new \\DateTime();\n			$this->actualities->save($this->actuality);\n			$this->presenter->flashMessage(\'Aktualita byla úspěšně uložena.\', \'success\');\n		} catch (\\Exception $exc) {\n			$this->presenter->flashMessage($exc->getMessage(), \'danger\');\n		}\n		//žádný redirect, až v presenteru!\n	}\n\n}\n\\--\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n/--code\n{control form}\n\\--\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)',	'2014-05-13 11:54:22',	0,	'0000-00-00 00:00:00',	0),
(75,	'Stáhněte si lepší blog',	'stahnete-si-lepsi-blog',	'Čas od času se na Nette fóru najde někdo, kdo hledá vzorový projekt do kterého by se mohl podívat. Vlastně se většinou hledá cokoliv, jakákoliv inspirace. Bohužel se zřejmě všichni bojí toho, že o svůj projekt přijdou, protože v něm někdo najde bezpečnostní chybu. Já se toho také bojím, ale lepší než před tím utíkat je se tomu postavit čelem. A tak je to tady.\n\nKdokoliv cokoliv\n================\nK dispozici je pro nahlédnutí tento blog. A nejen k nahlédnutí, ale také k \"volnému používání\":http://zlml.cz/develop.\nNa pozadí běží hned několik technologií, které si můžete prakticky osahat:\n\n+ Nette Framework (\"nette.org .{target:_blank}\":http://nette.org/)\n+ Nette Tester (\"tester.nette.org .{target:_blank}\":http://tester.nette.org/)\n+ Texy *(je sexy)* (\"texy.info .{target:_blank}\":http://texy.info/)\n+ FSHL (\"fshl.kukulich.cz .{target:_blank}\":http://fshl.kukulich.cz/)\n+ Webloader (\"addons.nette.org .{target:_blank}\":http://addons.nette.org/janmarek/webloader)\n+ Kdyby\\Doctrine 2 (\"GitHub\":https://github.com/Kdyby/Doctrine)\n\nK dispozici je i databáze, protože si myslím, že bych se i s únikem databáze neměl nijak ohrozit... :-) Účelem tohoto nápadu a následně rozhodnutí je poskytnout pokud možno funkční a aktivní projekt, který staví právě na těchto technologiích. Důvodem je pak moje zkušenost s tvrdým začátkem. Mám příležitost občas pracovat s někým kdo se přesně toto chce naučit, bohužel pár lidí už to prostě vzdalo, protože je toho *moc* a není mnoho lidí kteří skutečně pomohou (rozhodně ne na fóru). Snažím se tedy zaplnit toto prázdné místo a nabídnout tento blog jako jeden z možných začátků. Mimochodem neříkám, že moje řešení je nejlepší, nebo správné. Je jedno z možných a funkčních. Stáhnout si jej můžete ze své oblíbené verzovací služby:\n\n/---html\n<div class=\"row\" style=\"margin-top:50px;margin-bottom:50px\">\n	<div class=\"col-lg-6 col-md-6 col-sm-6 text-right\">\n		<a class=\"btn btn-default\" href=\"https://bitbucket.org/mrtnzlml/zlml.cz\" target=\"_blank\">\n			<img src=\"/img/loga/bitbucket.png\">\n		</a>\n	</div>\n	<div class=\"col-lg-6 col-md-6 col-sm-6\">\n		<a class=\"btn btn-default\" href=\"https://github.com/mrtnzlml/zlml.cz\" target=\"_blank\">\n			<img src=\"/img/loga/github.png\">\n		</a>\n	</div>\n</div>\n\\---\n\nPodrobnější popis najdete na \"samostatné stránce\":http://zlml.cz/develop věnované tomuto projektu. Byl bych moc rád, kdybych touto cestou pouze nenabídl něco chybějícího, ale také získal zpětnou vazbu. Nestojím o pochvaly. Ty samozřejmě potěší, ale mnohem přínosnější jsou praktické poznámky k implementaci, nebo funkcím. Nad takovou věcí se vždy rád zamyslím...',	'2014-05-19 11:00:51',	0,	'0000-00-00 00:00:00',	0),
(76,	'Disqus lazy loading',	'disqus-lazy-loading',	'Tento článek ve skutečnosti odstartovalo zdánlivě nesouvisející vlákno na \"Nette fóru .{target:_blank}\":http://forum.nette.org/cs/19397-ako-sa-zbavit-fid-v-url-ak-sa-nemylim. V tomto vláknu se řeší parametr *_fid* v URL adrese, který tam Nette framework přikládá kvůli flash messages. Tato vlastnost někoho skutečně hodně štve, mě zase až tak moc ne. Jenže když jsem nad tím vláknem chvíli seděl, tak jsem si uvědomil, že mám komentářový systém Disqus implementovaný špatně. Čtěte dál a vyhněte se stejné chybě... (-:\n\nUniverzální kód\n===============\nDisqus poskytuje \"by default\" univerzální kód, který prakticky pouze zkopírujete na svůj web na požadované místo a je hotovo. Tento kód vypadá zhruba takto:\n\n/--code html\n<div id=\"disqus_thread\"></div>\n<script type=\"text/javascript\">\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = \'\'; // required: replace it with your forum shortname\n\n    /* * * DON\'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement(\'script\'); dsq.type = \'text/javascript\'; dsq.async = true;\n        dsq.src = \'//\' + disqus_shortname + \'.disqus.com/embed.js\';\n        (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n    })();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n\\--\n\nJe to pohodlné, ale je to úplně blbě. Nejenom pro Nette aplikace, ale myslím si, že tak nějak celkově pro všechny aplikace. Fungovat to sice bude, to ano. Ale jen tak zdánlivě. Problém je totiž v tom, že toto nastavení bere jako identifikátor diskuse URL adresu a pokud se jen drobně změní, tak se založí nová diskuse. Přehled těchto diskusí je pak vidět v Disqus administraci. To s sebou nese celou řadu problémů. Diskuse nejde pořádně zamknout a už to, že k jedné stránce může být více diskusí je problém. Každá diskuse totiž musí mít unikátní identifikátor \"disqus_identifier .{target:_blank}\":https://help.disqus.com/customer/portal/articles/472098-javascript-configuration-variables nezávisle na parametrech (pokud ovšem tyto parametry nejsou žádoucí).\n\nLazy loading\n============\nJá jsem sice nepoužil defaultní konfiguraci, ale udělal jsem prakticky tu samou chybu. Teď ale konečně k lazy loadingu. Na svém blogu to již používám dlouhou dobu a myslím si, že se to již osvědčilo. Inspirací k mé implementaci je \"tento gist .{target:_blank}\":https://gist.github.com/omgmog/2310982.\n\nStačí umístit následující kód do nějakého souboru *main.js*, který se spouští po načtení stránky:\n\n/--code javascript\nvar disqus_div = $(\"#disqus_thread\");\nif (disqus_div.size() > 0) {\n    var ds_loaded = false,\n    top = $(\'.load_disqus\').offset().top, //upravit podle potřeby\n    disqus_data = disqus_div.data(),\n    check = function () {\n        if (!ds_loaded && $(window).scrollTop() + $(window).height() > top) {\n            ds_loaded = true;\n            for (var key in disqus_data) {\n                if (key.substr(0, 6) == \'disqus\') {\n                    window[\'disqus_\' + key.replace(\'disqus\', \'\').toLowerCase()] = disqus_data[key];\n                }\n            }\n            var dsq = document.createElement(\'script\');\n            dsq.type = \'text/javascript\';\n            dsq.async = true;\n            dsq.src = \'http://\' + window.disqus_shortname + \'.disqus.com/embed.js\';\n            (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n        }\n    };\n    $(window).scroll(check);\n    check();\n}\n\\--\n\nTím to však nekončí. Je samozřejmě nutné určit kde se Disqus bude zobrazovat:\n\n/--code html\n<div class=\"hidden-print\">\n	<div id=\"disqus_thread\" data-disqus-shortname=\"mrtnzlml\" data-disqus-url=\"{link //this}\"></div>\n	<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n	<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n</div>\n\\--\n\nKlíčový je zde právě data atribut *disqus-url*. No a aby byl kod kompletní, tak je zapotřebí někam umístit CSS trídu *.load_disqus*. Tu doporučuji umístit někam nad diskusi a tím myslím třeba o celou viditelnou stránku. Disqus se tak začne načítat o něco dříve, než k němu čtenář doscrolluje, takže se stihne načíst a nebude to rušit. Ve výsledku se tedy Disqus nenačítá po otevření stránky, takže je načtení svižné, ale po např. přečtení článku je již načtený...\n\nA co vy? Máte Disqus na svém webu implementovaný správně? (-:',	'2014-06-12 21:36:26',	0,	'0000-00-00 00:00:00',	0),
(77,	'Čteme Data Matrix bez čtečky',	'cteme-data-matrix-bez-ctecky',	'[* 1fc11f25-abc2-453e-abb4-adb31d0ccf17/datamatrix.png <]\n\nDnešním článkem navazuji na dřívější článek \"Čteme QR kódy bez čtečky\":http://zlml.cz/cteme-qr-kody-bez-ctecky, ve kterém jsem řešil čtení QR kódu bez použití jakéhokoliv čtecího zařízení. A dnes budu řešit téměř to samé, ale s jiným kódem. Data Matrix není tolik známý, ale myslím si, že patří, hned po QR kódech, mezi nejpoužívanější kódy vůbec. Po tomto článku si jich zajisté začnete všímat více. Naposledy jsem jej viděl na balíčku od jahod... (-: Opět platí, že hlavním cílem je kód přečíst, nikoliv mu úplně porozumět, takže nebudu rozebírat velké detaily.\n\nLevý obrázek je kód o kterém bude celou dobu řeč.\n\nTrocha nezbytné teorie\n======================\n[* 0dd271b6-21ea-4c3c-a447-723b76257b50/datamatrix-key.png <]\n\nTento kód je oproti QR kódu velmi jednoduchý, takže i teorie bude stručná. Veškerá data a korekce chyb je ukryta uvnitř rámu, který je z části plný. To umožňuje čtečkám poznat kde všude je ještě kód a jak je natočen. Z pohledu \"ručního\" čtení je tato část nezajímavá. Modře jsou zvýrazněny 4 bity, které k ničemu neslouží a zaplňují jen prázdné místo. Ne vždy je tento úkaz vidět. Bohužel tentokrát nemám k dispozici originální specifikaci, takže nevím jakým přesným pravidlům to podléhá.\n\nNejpodstatnější jsou však červeně zarámované oblasti. Všechny mají takovýto tvar a vždy mají přesně dané umístění. Toto umístění je vlastně dáno první oblastí s číslem 2. Nicméně z hlediska umístění dat je nejdůležitější pátý bit v prvním sloupci od kterého vše startuje. Pokud obrazec přesahuje to timing zón, tedy do nažloutlého rámu, tak pokračuje na druhé straně, tedy dole, nebo na pravé straně.\n\nData se v kódu čtou podle čísel, tedy podél takové diagonální vlnovky a to až do obrazce s číslem 5. Tento obrazec určuje konec zprávy. V našem případě se tedy jedná o zprávu, která má 4 znaky. A jak už to tak bývá, tak jsou všechny znaky přenášeny v binárním formátu. Zbytek kódu, který není nijak zvýrazněn je klasicky Reed–Solomon korekce chyb. Možná bych o tomto mechanismu také mohl někdy napsat článek. Nicméně napovažuji to za úplně jednoduchá záležitost, takže si to zatím nechám v zásobě.\n\nHrajeme si na čtečku\n====================\n\nPřečíst zprávu v takto teoreticky rozebraném kódu už je otázka chvilky. Najdříve si vytáhneme všechny potřebné části. V tomto případě je zbytečné řešit pátý člen, jelikož se jedná o poslední ukončovací. Jeho hodnota je 129 v desítkové soustavě. Získané útvary jsou vidět na obrázku níže.\n\n[* 76028c59-4e5f-42f4-a411-3452844a30d2/last.png *]\n\nČísla určují pozici bitů v binárním čísle. Po přepsání do binární podoby mají znaky následující hodnoty:\n\n/--code\n01100010 01101001 01110000 01101011\n\\--\n\nV desítkové podobě jsou to tedy čísla:\n\n/--code\n98 105 112 107\n\\--\n\nNásledně je zapotřebí od těchto čísel odečíst jednotku. Abych řekl pravdu, tak jsem po dlouhém uvažování nedokázal přijít s rozumným vysvětlením proč se to tak dělá. Původně mě napadadlo, že je to kvůli lepšímu rozložení bitů ve výsledném obrazci. Stejně tak jako se u QR kódů bity ještě maskují. To ale nedává smysl. Je to jen posunutí o jedna. Nic víc... Nicméně je zřejmé, že spousta věcí je v takovýchto kódech minimálně na zamyšlení. Ale zpět k poslednímu kroku. Z předchozího článku již všichni vědí, že číslo 97 je v ASCII tabulce hodnota znaku **a**, takže po odečtení jednotky a přepsání do čitelné podoby získáváme řešení:\n\n/--code\n97 104 111 106\na  h   o   j\n\\--\n\nTento kód je pro čtení bez čtečky daleko snadnější, komplikuje to jen nezvyklé uspořádání bitů. Jaký další kód bych měl dostat pod drobnohled? Snad to půjde. Mám zde totiž rozpracovaný ještě jiný a nemohu k němu sehnat normu pro nahlédnutí, takže jsem se zatím zasekl... (-:',	'2014-06-15 16:34:13',	0,	'0000-00-00 00:00:00',	0),
(78,	'Novinky na blogu a extension RFC',	'novinky-na-blogu-a-extension-rfc',	'Kdo pravidelně sleduje \"můj twitter\":https://twitter.com/mrtnzlml, tak už to ví. A je to skvělé! Včera jsem totiž \"mergnul\":https://github.com/mrtnzlml/zlml.cz/commit/b21775df522271e81302d2987ff44d5285b245eb důležitou část tohoto blogu a tím vydal verzi 1.1 snad stable... (-: Jedná se o celkem významný krok, ale stále je to nic oproti tomu co mám v plánu. V dnešním článku bych se rád podělil o většinu zajímavých novinek a v druhé části bych rád požádat o pomoc s rozvinutím jednoho zajímavého nápadu.\n\nNovinky v release 1.1\n=====================\nA hned první novinka je ta nejzajímavější. Zastávám názor, že by si měl programátor za svým kódem stát a to v každé situaci. Proto jsem se rozhodl, že pustím kohokoliv do své administrace. Ostatně proč ne. Je to výzva. Rád bych však napřed požádal kohokoliv kdo najde nějakou chybu, aby mi to dal vědět na základě nepsané programátorské etikety a nesnažil se celý blog hned zničit. Zálohu mám... :-) Administraci najdete na adrese zlml.cz/admin a přístupové údaje jsou `demo / demo`. Enjoy.\n\nAčkoliv je první představená novinka asi nejzajímavější pro kohokoliv jiného, pro mě osobně je nejzajímavější nový systém vkládání obrázků. To je něco co mi na blogu dlouho chybělo. Představoval jsem si to tak, že bych obrázky jednoduše a rychle nahrál a stejně jednoduše bych je vložil do aktuálně psaného článku. A přesně to teď můžu udělat. Použil jsem \"fineuploader\":http://fineuploader.com/, protože je to skvělý program. Můžu AJAXově nahrávat souběžně několik obrázků s velikostí klidně až za PHP limitem `upload_max_filesize` a nebo navázat na přerušené nahrávání. To vše vlastně díky chunk uploadu. Umí toto váš blog? Zkuste si na sdíleném hostingu nahrát soubor o velikosti třeba 50MB...\n\nToto jsou dvě nejdůležitější změny, na kterých jsem v desetinkové verzi pracoval. Správa uživatelů a cool image uploader. Dále jsem udělal opět několik designových změn a fixů, ale už se nejedná o nic tak důležitého aby to stálo za řeč.\n\nDalší kroky a žádost o pomoc\n============================\nSvůj blog mám rád. A mám ho rád až tak, že bych byl rád, aby ho časem používal i někdo jiný. To ještě nějakou chvíli potrvá, ale už nějaký čas mi leží v hlavě nápad, jak se k tomuto požadavku přiblížit. Rád bych totiž blog přepsal do Nette extensions. Včera jsem popré \"nakousl\":https://github.com/mrtnzlml/zlml.cz/commit/1ffc33bc5dddbadfc1b6ce7d30dccb09938800cb svojí myšlenku. Princip je jednoduchý. Přepíšu například funkcionalitu obrázků (nebo čehokoliv jiného) do extension a když bude někdo budovat nový blog, tak si jen v konfigu zvolí jaké moduly chce (to se dá snadno generovat):\n\n/--code neon\nextensions:\n	- ImageExtension\n    - SearchExtension\n    - ...\n\\--\n\nSamotné extension má potom za úkol se samo spustit (`afterCompile`) a přidat nějaké funkcionality do stacku (v metodě `initialize`). V prvním nakousnutí například přidávám položku do menu a skutečně to funguje tak jak píšu. Jakmile nějakou funkci nechci, prostě ji z konfigu zruším. Výhodné na tom je to, že můžu prošpikovat blog místy, kam lze nové feature zaregistrovat a dají se velmi jednoduše provázat přes composer. **Ale.** Má to háček.\n\nKdyž jsem si s touto myšlenkou hrál jen v hlavě, tak to bylo super, protože vše fungovalo perfektně. Bohužel jsem narazil na to, že nevím jak pěkně vyřešit šablony a routování na ně. Šablony jsou totiž jedna z dalších věcí které bych zde chtěl vyřešit. Bylo by fajn, kdyby mohl mít každý možnost si třeba šablony podědit a změnit si kompletně celý design. To zase takový problém není. Ale jak vyřešit to, když chci v extension např. přidat novou stránku? Kam umístit šablonu a jak ji naroutovat? Nějak jsem to dneska v noci už nedokázal vymyslet. Máte někdo prosím nějaký zajímavý nápad? Díky...\n\nNo a naposledy už snad jenom: \"Give me a star, please\":https://github.com/mrtnzlml/zlml.cz...',	'2014-07-13 14:00:51',	0,	'0000-00-00 00:00:00',	0),
(79,	'SračkoAPI',	'srackoapi',	'Následující řádky budou čistý hate na několik tvůrců API, který má posloužit budoucím tvůrcům API. Sám totiž musím obsluhovat několik služeb a získávat z nich data. A ačkoliv se nebráním složitostem, některé věci jsou tak absurdní, že až rozum zůstává stát...\n\nNo to si ze mě děláte...\n------------------------\nPrvní místo na žebříčku debility získává API pro obsluhu a registraci domén od Web4U. Jedná se o klasické SOAP API, které mě však místy přivádí k šílenství. Začnu pěkně od začátku. Aby bylo vůbec možné API volat, musíte nejdříve získat identifikátor služby. Kde jej sehnat? Napadá vás někde v aministraci? Kde jinde také, že? Omyl! Identifikátor služby se získává tak, že zavoláte jakoukoliv funkci z jejich API špatně a identifikátor najdete ve vrácené exception. A to si nedělám prdel. To fakt mají napsané v dokumentaci. A aby toho nebylo málo, tak vrácené ID je ve formátu `IDxxxxxxx, ...`. Koho by však napadlo, že ID je tich prvních 9 znaků, tak je na omylu. ID je totiž to ID bez úvodního ID, tedy `xxxxxxx`. Takto je to možná jasné, ale když k tomu poprvé sednete, tak nad tím sedíte půl dne. Následně lze funkci opět volat s vráceným ID. A právě volání je další sranda.\n\nV dokumentaci je totiž jasně napsáno co jsou povinné vstupní hodnoty, volitelné hodnoty a občas i co to vrací. Takže je to jasné, prostě tam pošlu pole hodnot key-value a je to. Hahaha. Ne. Do tohoto API se totiž posílá pole polí s tím, že je zapotřebí dodržovat přesně stanovený formát a to takovýto:\n\n/--code php\narray(\n	array(\'name\' => \'key\', \'data\' => \'value\'),\n	//...\n)\n\\--\n\nJe to jedna z věcí, která je prostě hloupá. Pokaždé se musím sám sebe ptát, proč to tak je? Nerozumím tomu, nemá to žádnou přidanou hodnotu. Jdeme dál. Řekněme, že potřebujete pomocí API zjistit nějakou informaci o doméně, například kdy skutečně expiruje. Na to se stačí jednou týdně zeptat a aktualizovat si informace v databázi. To pro případ, že byla doména prodloužena u třetí strany. No, nebudeme to rozebírat dále. Přes API nelze tuto funkci zavolat. Proč? Vyžaduje totiž captchu. Jo, ta funkce v API se fakt volá přes obrázkovou captchu. Jako jediná. Chápu jak to použít, ale prakticky všechny své projekty dělám plně automatizované, takže jediné řešení je zde najmout \"armádu Indů\":http://www.root.cz/clanky/potrebujete-obejit-captcha-zaplatte-si-armadu-indu/ a captchy louskat ručně.\n\nA takových perel je tam nespočet. Potřebujete vědět, jestli proběhla funkce v pořádku? Nope. Výstupem z funkce je totiž číslo požadavku. Chybu si totiž musíte poměrně nepěkně vydlabat z exception. Další věc je čistě logická. České domény lze registrovat pouze s NSSETem. Jinak to nejde. U jiných domén se zadávají jednotlivé NS servery. U CZ domény se musí nejdříve vytvořit identifikátor držitele kontaktu. U jiných domén se vytváří při registraci domény. To se všechno může zdát jako maličkosti, ale takové věci vše zbytečně komplikují a použití takového API je spíš otrava. Přitom si myslím, že největší příliv např. domén musí být právě strojově přes API.\n\n...ale už fakt prdel!\n---------------------\nRychlá otázka k zamyšlení. Jak uděláte API, aby bylo možné jej snadno testovat? Změníte například přístupové údaje na testovací, nebo budete posílat nějaký testovací token? OK. Myšlenka je jasná. Kdykoliv se to dá snadno přehodit např. změnou jednoho hesla do ostrého režimu. Jenom v debilním API se metody pro testování jmenují jinak, než metody pro ostré použití. Kurva! To je další věc, která to celé nepříjemně zkomplikuje.\n\n[* d10561e0-aeec-4dae-a21e-17eb7c4ca36d/gif.gif <]\nDobře, poslední příklad. Nedávno jsem zase něco nevyčetl z dokumentace. Napsal jsem tedy na technickou podporu ať mi poradí, že to tam nemají napsané. Konkrétně se jednalo o povolené vstupní hodnoty do jedné funkce. Na odpověď jsem čekal dva dny, což by ani tak nevadilo, ale hodně jsem se nasmál u odpovědi, která přišla v tomto formátu (původně zapsáno pod sebou):\n\n/--code\n\'cs\', \'sk\', \'bg\', \'hr\', \'da\', \'nl\', \'en\', \'et\', \'fi\', \'fr\', \'de\', \'el\', \'hu\', \'ga\', \'it\', \'lv\', \'lt\', \'mt\', \'pl\', \'pt\', \'ro\', \'sl\', \'es\', \'sv\'\n\\--\n\nWhat? Takže podpora také nevěděla a tak mi poslala kus vykopírovaného zdrojového PHP kódu z aplikace? V tuto chvíli už mi začíná být všechno jedno... \n\nJde to i jinak?\n---------------\nVím, že ano, ale stále častěji mě někdo přesvědčuje o opaku. Druhé ukázkové API jsem zvolil pro porovnání také typu SOAP. V tomto API je již většina věcí na které jsem do této chvíle nadával vyřešena. Dokonce jsem potěšen z toho, že se jedná o API poměrně inteligentní a tak se mohu dotazovat hodně podobně jako v Doctrine 2. Paráda.\n\nJenže pak přijde, jak říká kolega, další jobovka. API je totiž totálně bez dokumentace, takže téměř jediné místo, kde lze získat informace o vstupních a výstupních hodnotách je prohlédnout si celý dump dané funkce. Dobře, to není problém. Vidím datum ve známém formátu jako string. Posílám tedy také datum ve stejném formátu jako string. Nic. Dobře, poslím ho jako DateTime. Nic. Až po hodně dlouhé době a nahlášeném bugu jsem dostat fuck off odpověď, že to datum zadávám špatně a musí to být v následujícím formátu:\n\n/--code php\n//...\narray(\n	\'year\' => ...->format(\'Y\'),\n	\'month\' => ...->format(\'m\'),\n	\'day\' => ...->format(\'d\'),\n	\'hour\' => ...->format(\'H\'),\n	\'minute\' => ...->format(\'i\'),\n)\n//...\n\\--\n\nA dost vole, seru na to. Na to nemám nervy. Zase ta samá otázka. Proč? Vždyť... Ale nic. Už raději nic.\n\nProsím všechny programátory, **snažte se víc**. Cílem by mělo být **usnadnit používání**, nikoliv však sobě, ale **uživatelům**. Prosím...\n\nHowgh.',	'2014-07-17 21:58:50',	0,	'0000-00-00 00:00:00',	0),
(80,	'Za hranicí ORM',	'za-hranici-orm',	'Již mnohokrát jsem slyšel, že je ORM \"antipattern\":http://www.zdrojak.cz/clanky/orm-je-antipattern/. Já si to nemyslím. Je to hloupý a uspěchaný názor. V dnešním článku však nechci rozebírat co je a co není antipattern. To je jen zbytečnou ztrátou času. Rád bych ukázal použití jednoho ORM systému, který mě naprosto uchvátil.\n\nKdyž jsou potřeba firemní procesy\n=================================\nZejména začínající firmy mají na svém startu náročný úkol. Je zapotřebí vytvořit vnitrofiremní procesy, které striktně řídí běh různých akcí jako je například výroba, reklamace, nebo třeba koloběh dokumentů. Ve firmě \"taková řešení nabízíme\":http://www.orgis.cz/sluzby/in-house a je o ně velký zájem. Má to svůj smysl. Není žádným tajemstvím, že používáme ERP systém \"Odoo\":https://www.odoo.com/, protože je to velmi silný nástroj. I přes neuvěřitelnou modifikovatelnost této aplikace je občas zapotřebí sáhnout k daleko více sofistikovanému řešení. Proč? Občas jsou totiž vnitropodnikové procesy velmi složité a navíc jich je velké množství. V takovém případě, je téměř jedinou možností napsat si pro tento ERP systém rozšíření, které tento těžký úkol zvládne.\n\n[* 393212dc-381f-4b3a-a06c-fb5d33d6dc29/workflow.png *] *** *Ukázka struktury klasického firemního workflow*\n\nNechci však psát návod na to, jak si takový modul naprogramovat. O tom třeba někdy příště. Pojďme se raději podívat na to, jak téměř celé Odoo funguje, protože je to skutečně pozoruhodné. Bez kódů to však nepůjde.\n\nZáplava tabulek\n===============\nAbych byl upřímný, tak jsem se ještě nikdy nesetkal s tím, aby byl **každý** objekt v projektu skutečně realizován tabulkou v databázi. Nebo o tom alespoň nevím. Je to v podstatě jako když máte entity a ty jsou pak skutečně v databázi. Rozdíl je však v tom, že zde je v \"entitě\" i celá potřebná logika (které většinou moc není) a hlavně žádné jiné objekty nejsou potřeba.\n\nV nejprostším tvaru může tedy třída modulu vypadat skutečně pouze jako entita:\n\n/--code python\nclass project_wkf_activity(osv.osv):\n    _name = \'project.wkf.activity\'\n    _columns = {\n        \'sequence\': fields.integer(\'Sequence\'),\n        \'name\': fields.char(\'Workflow Activity Name\', required=True, size=64, translate=True),\n        \'type\': fields.many2one(\'project.wkf.type\', \'Workflow Type\'),\n        \'fold\': fields.boolean(\'Folded in Kanban View\'),\n    }\n    # ...\n    def jumptoseq(self, cr, uid, ids, sequence, context=None):\n    	#...\n\\--\n\nPři programování modulů toto vede k extrémní explozi tabulek v databázi. 500 tabulek uděláte v databázi jako nic. Stačí nainstalovat pár modulů. A to už mi přijde dost netradiční. Kromě modulových tabulek je v základní instalaci asi 100 tabulek, které v sobě drží vše možné, mimo jiné také informace o workflow. A právě definice workflow je to nejzajímavější. Veškerá sranda se totiž odehrává v XML souborech. Ve výsledku stačí pro napsání složitého workflow včetně veškeré logiky pouze XML...\n\nXML programování (-:\n====================\nKdyž jsem toto poprvé viděl, párkrát jsem se zastavil a přemýšlel jsem, jak to vlastně může fungovat. Je to však velmi jednoduché. V inicializačním souboru modulu si stačí nadefinovat jaké XML soubory se mají načítat. Následuje definice workflow. Žádné psaní okolo. Prostě to hned funguje. Začátek takového workflow může vypadat například takto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<record id=\"wkf1\" model=\"workflow\">\n            <field name=\"name\">project.wkf1</field>\n            <field name=\"osv\">project.project</field>\n            <field name=\"on_create\">True</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nTím je workflow založeno a při spuštění převedeno do databáze. Jádro má pak za úkol se těchto tabulek chytit a pracovat s nimi. Jsou jasně daná pravidla, takže s tím není žádný problém. Následuje definice akcí (to jsou ty bubliny na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        \n        <record id=\"a_1_0\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_start\">True</field>\n            <field name=\"name\">start-wkf1</field>\n            <field name=\"kind\">dummy</field>\n        </record>\n\n        <record id=\"a_1_10\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"name\">nazev-activity</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">jumptoseq(10)</field>\n        </record>\n        \n        <record id=\"a_1_500\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_stop\">True</field>\n            <field name=\"name\">end</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">orgis_close()</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nA následuje definice transitions (spojení na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        <!-- viz definice aktivit -->\n        \n        <record id=\"t_1_9\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_40\"/>\n            <field name=\"act_to\" ref=\"a_1_50\"/>\n            <field name=\"signal\">a_1_40toa_1_50</field>\n        </record>\n        <record id=\"c_1_7\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_36\"/>\n            <field name=\"act_to\" ref=\"a_1_500\"/>\n            <field name=\"signal\">close_wkf</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nUkázky jsou nekompletní, protože by se to sem všechno ani náhodou nevešlo. Výsledný XML soubor vlastně stačí k tomu, aby celé workflow fungovalo. Stačí nadefinovat funkce v příslušných třídách viz například volání `jumptoseq`.\n\nDost často je také zapotřebí definovat tlačítka pro view, což se dělá také pomocí XML kde je opět originálně vyřešeno přepisování defaultní šablony. Tlačítka mají vždy nějakou akci, která zajistí, že se posuneme ve workflow dále. Na takové workflow lze pověsit úplně všechno. Poslání emailů, vygenerování faktur, založení akce v kalendáři atd. Pokud se jedná o vyloženě automatické kroky, akce se na tlačítku nemusí definovat a pak systém celé workflow proskáče a spustí všechny akce popořadě sám. Zajímavé je však to, že se po spuštění všechno nahrne do databáze a jádro Odoo se strará pouze o to, aby tento interně složitý systém fungoval správně. Všem lidem, kteří nadávají na ORM bych tedy položil následující otázku. Jak uděláte takto sofistikovaný systém bez ORM? Nebo že toto snad není ORM? A uvědomte si, jak jsem se strašně rychle dokázal dostat z ORM až na celý komplexní systém workflow. Je to proto, že jsem vůbec neuvažoval něco jako je ActiveRow... (-: I když z velké části je to spíše plnění tabulek.\n\nV tomto reálně fungujícím řešení je velmi hluboká myšlenka. A udivuje mě, že v jiných systémech toto funguje úplně obráceně. Všichni se snaží programovat spíše to jádro. Ukazuje se však, že využít kvalitní jádro, které se stará o všechno je daleko přínosnější. Vzpomeňte si na tento článek, až budete ťukat do klávesnice entity, mappery, repository, DAO objekty a další a to pouze kvůli tomu, aby bylo možné udělat nějaké takové workflow, jako jsem zde teď popsal. Už zase...\n\nPoužíváte také nějakou netradiční implementaci ORM?',	'2014-08-01 22:55:45',	0,	'0000-00-00 00:00:00',	0),
(81,	'Komunikace s ERP pomocí XML-RPC',	'komunikace-s-erp-pomoci-xml-rpc',	'Spousta lidí by se ráda připojovala na API ERP systému \"Odoo\":https://www.odoo.com/, ne vždy je to však procházka růžovým sadem, protože se očekává místy až přehnaná interní znalost tohoto systému. Přitom je to zbytečné. V dnešním článku se pokusím zdokumentovat právě tuto žalostně zdokumentovanou stránku věci tak, aby to zvládl každý alespoň trochu zdatný programátor.\n\nPrvně však několik málo slov o co vlastně jde. Odoo je ERP (\"Enterprise Resource Planning\":http://www.orgis.cz/sluzby/in-house) systém poměrně bohatý na funkce a má za úkol řešit zejména vnitrofiremní procesy a obecně všechny záležitosti, které se okolo jakékoliv firmy motají. Lze tedy řešit plánování projektů, jejich workflow, rozvrhování času, řízení zakázek, ale také například správu dokumentů, skladové zásoby, mass mailing, nebo tzv. \"Point of Sale\":https://www.odoo.com/page/point-of-sale což je jedna z těch nejvíce zajímavých věcí, alespoň z mého pohledu. Zjednodušeně řečeno lze udělat naprosto cokoliv. A co nejde, tak se jednoduše doprogramuje. Aby však šlo udělat cokoliv, je potřeba připojovat se na tento systém vzdáleně, protože občas se hodí propojit stávající webovou aplikaci právě s takovýmto systémem. To může mít několik důvodů. Například chcete mít ve webové aplikaci data sjednocená s ERP systémem, nebo si chcete vzdáleně stahovat faktury, popř. tlačit data do účtovacího systému. Jak již bylo řečeno - možné je naprosto cokoliv.\n\nHello API!\n==========\nOdoo poskytuje klasické XML-RPC API. Toto API je velmi jednoduché na obsluhu, nicméně ani tento druh API \"není můj favorit\":http://zlml.cz/srackoapi. S výhodou tedy můžeme použít lehce modifikovanou funkci \"Jakuba Vrány\":http://php.vrana.cz/webove-sluzby-v-php-xml-rpc-a-soap.php pro obsluhu tohoto API (PHP):\n\n/--code php\n<?php\n\nfunction xmlrpc($url, $method, $params = array(), $types = array(), $encoding = \'utf-8\') {\n    foreach ($types as $key => $val) {\n        xmlrpc_set_type($params[$key], $val);\n    }\n    $context = stream_context_create(array(\'http\' => array(\n        \'method\' => \"POST\",\n        \'header\' => \"Content-Type: text/xml\",\n        \'content\' => xmlrpc_encode_request($method, $params, array(\'encoding\' => $encoding))\n    )));\n    return xmlrpc_decode(file_get_contents($url, false, $context), $encoding);\n}\n\\--\n\nNásleduje krátká odbočka k tomu, co vše je možné přes API udělat. Opět bych mohl napsat, že cokoliv, ale zde už si nejsem jist a proto následuje výpis funkcí, které je možné přes api volat a hlavně které považuji za důležité. Existují totiž 4 služby a každá obsahuje jiné metody. Nejhlavnější služba je `common`. Zde jsou k dispozici mimo jiné funkce `login(db, login, password)`, `about(extended=False)`, `timezone_get(db, login, password)` a `version()`. Většina funkcí se dostatečně popisuje sama, pozor však na funkci \"about\", protože ta v době psaní tohoto článku \"obsahovala chybu\":https://github.com/odoo/odoo/pull/2028. Je tedy zřejmé, že tato skupina funkcí se hodí pro zalogování do systému, nebo pro zjištění časového pásma, popř. verze systému. Pojďme se tedy přihlásit:\n\n/--code php\n<?php\n//...\n$data = array(\'database\', \'username\', \'password\');\n$uid = xmlrpc(\"http://.../xmlrpc/common\", \"login\", $data);\n\\--\n\nVýsledkem volání je unikátní identifikátor uživatele, který si můžeme dočasně někam uložit, aby ho nebylo potřeba zjišťovat pořád znovu. To není potřeba. Nutné ja však upozornit na to, že přes API získáte taková přístupová práva, jaké by měl uživatel, kdyby se přihlašoval normálně pomocí loginu.\n\nJedeme dál\n==========\nNásleduje služba `object`. Ta má na starost práci s databází z hlediska ORM. Ačkoliv má tato služba pouze dvě pro mě zajímavé funkce, užije se s ní nejvíce srandy a patří asi k té nejdůležitější. Zmiňované funkce jsou `execute(db, uid, obj, method, *args, **kw)` a `exec_workflow(db, uid, obj, signal, *args)`. Právě pomocí `execute` lze například vyhledávat v databázi a to tak, že si nejdříve získáme ID hodnoty pro daný výraz a následně si vytáhneme veškeré informace, které jsou potřeba (pokud jsou potřeba). Příklad pro vyhledávání v zákaznících:\n\n/--code php\n<?php\n//...\n$data = array($database, $uid, $password, \'res.partner\', \'search\', [[\'name\', \'ilike\', \'hledanyvyraz\']]);\n$ids = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme IDčka\n\n$data = array($database, $uid, $password, \'res.partner\', \'read\', $ids, [\'image\', \'display_name\', \'function\', \'email\']);\n$users = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme zákazníky\n\n//ukázka vytváření klienta:\n$data = array($database, $uid, $password, \'res.partner\', \'create\', [\'name\' => \'John Doe\']);\nxmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data);\n\\--\n\nJe tedy zřejmé, že pomocí execute můžeme vyhledávat, číst, ale i vytvářet, nebo mazat záznamy (`create`, `search`, `read`, `write`, `unlink`). Zajímavý je způsob zápisu při hledání (<em>ilike</em>). K dispozici jsou následující operátory: `=`, `!=`, `>`, `>=`, `<`, `<=`, `like`, `ilike`, `in`, `not in`, `child_of`, `parent_left`, `parent_right`. Opět se jedná o \"samosepopisující\" názvy. Nejzajímavější je však právě <em>ilike</em>, který není case sensitive a obaluje dotaz procenty jako je tomu například klasicky v MySQL (`%hledanyvyraz%`). U použíté funkce <em>read</em> lze vyjmenovat jaké sloupce se mají vrátit, nebo se vrátí veškerá data (včetně obrázků v base64).\n\nPokročilé dotazování\n====================\nPodmínky dotazování lze ještě zpřesnit pomocí logických operátorů (`&` - and, default, `|` - or, `!` - not). Podmínky se zapisují klasicky prefixově, takže pokud chceme například vyhledat zákazníka s nenastavenou češtinou z čech a německa, položíme například následující prefixový dotaz:\n\n/--code python\n[(\'name\',\'=\',\'Adam\'),\'!\',(\'language.code\',\'=\',\'cs_CZ\'),\'|\',(\'country_id.code\',\'=\',\'CZ\'),(\'country_id.code\',\'=\',\'DE\')]\n# ekvivalentní k:\n[(\'name\',\'=\',\'Adam\'),(\'language.code\',\'!=\',\'cs_CZ\'),\'|\',(\'country_id.code\',\'=\',\'CZ\'),(\'country_id.code\',\'=\',\'DE\')]\n\\--\n\nTo v jakých modulech (<em>res.partner</em>) se bude vyhledávat právě záleží na tom, co je naintalováno za moduly a je třeba vědět jak jsou interně označeny, což je podle mého nešťastné, ale zde je přehled těch nejčastějších\n\n- Zákazníci: `res.partner`\n- Telefonáty: `crm.phonecall`, obch. příležitosti - `crm.lead`\n- Produkty: `product.template`, kategorie produktů - `product.category`\n- Projekty: `project.project`, úkoly - `project.task`, tagy - `project.category`\n- Faktury: `account.invoice`, smlouvy - `account.analytic.account`\n- Zaměstnanci: `hr.employee`, výdaje - `hr.expense.expense`\n- Znalostní báze: `document.directory`\n- Kalendář: `calendar.event`\n\nJe svělé, že stačilo pár ukázek a s celým ERP lze dělat téměř cokoliv. Tím to však nekončí, protože existují ještě dvě skupiny příkazů. Třetí skupinou je skupina pro obsluhu a generování reportů `report`. Tato skupina mi v současné chvíli nepřijde natolik zajímavá, ale jmenovitě se jedná o funkce `report`, `report_get` a `render_report`. Mnohem zajímavější, ačkoliv možná trošku vyšší dívčí, je skupina pro přímou práci s databází ERP. Jedná se o skupinu `db` a ta ovládá právě instance celého ERP. Tyto funkce nejsou přímo pro zákazníky, ani obsluhu ERP, ale spíše pro administrátory serverů, tzn. je nutné autorizovat se master helem. Databáze lze mazat, vytvářet, přesouvat, zálohovat, migrovat, duplikovat atd. viz následující výčet funkcí: `create`, `drop`, `dump`, `restore`, `rename`, `change_admin_password`, `migrate_databases`, `create_database` a `duplicate_database`. Zejména pak třeba <em>rename</em> se hodí, protože tato operace nejde jinak vykonat. U všech zmíněných funkcí je nutné se ověřit. U následujících informativních to nuté není: `db_exist`, `list`, `list_lang`, `server_version`. Velký pozor na funkci <em>db_exist</em>. Ve skutečnosti totiž kontroluje, jestli se lze k databázi připojit, nikoliv jestli existuje, což nutně nemusí být jedno a to samé...\n\nPokud si chcete o dané problematice přečíst více, doporučuji tuto zastaralou \"dokumentaci\":https://doc.odoo.com/6.1/developer/12_api/. Je dobrá, nikoliv však postačující. Obsahuje však ukázky i pro jiné programovací jazyky, než je PHP. Doufám, že tento článek vyjasnil všechny zákoutí komunikace s API ERP systému Odoo... (-:',	'2014-08-27 20:11:00',	0,	'0000-00-00 00:00:00',	0),
(82,	'Kdyby\\Console',	'kdyby-console',	'Existují knihovny, bez kterých bych si vývoj webových aplikací již téměř nedokázal představit. Jedním z nich je \"Kdyby\\Console\":https://github.com/kdyby/console. Již dříve jsem sice napsal článek o \"Nette CliRouteru\":http://zlml.cz/nette-2-1-dev-clirouter, ale postupem času a hlavně také díky Doctrine jsem velmi rychle a rád přešel na jiné a dokonalejší řešení. Vzhledem k tomu, že na jednom projektu používám tuto knihovnu velmi hodně a vlastně na ní celý projekt stojí, rád bych alespoň prostřednictvím tohoto článku autorovi poděkoval (\"Filip Procházka\":https://github.com/fprochazka). Zároveň bych tímto počínáním rád postupně smazával věčný problém těchto knihoven, protože většinou z hlediska návštěvníka ani není jasné, na co ta knihovna je...\n\nProč uvažovat o konzoli?\n========================\nPro mě je tato otázka celkem jednoduchá, protože mám projekty, které nejedou jen na sdíleném hostingu, ale jsou to samostatně stojící aplikace. Z toho plyne, že je často zapotřebí vykonávat pomocí CRONu velké množství úkolů. Toto je hlavní část, proč vůbec o konzolovém nástroji uvažuju. Použití je totiž velmi jednoduché a právě samotná Doctrine nabízí prostřednictvím Kdyby\\Console celou řadu klasických příkazů a je škoda je nevyužívat. Stačí spustit z příkazové řádky `php index.php` u aplikace a pokud jsou příkazy zaregistrovány v konfigu, vypíše se jejich seznam včetně nápověd:\n\n/--code\nC:\\xampp\\htdocs\\zeminem.cz\\www>php index.php\nNette Framework version 2.2.3-RC2\n\nUsage:\n  [options] command [arguments]\n\nOptions:\n  --help           -h Display this help message.\n  --quiet          -q Do not output any message.\n  --verbose        -v|vv|vvv Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n  --version        -V Display this application version.\n  --ansi              Force ANSI output.\n  --no-ansi           Disable ANSI output.\n  --no-interaction -n Do not ask any interactive question.\n\nAvailable commands:\n  help                       Displays help for a command\n  list                       Lists commands\nblog\n  blog:install               Install database schema (set-up DB credentials in config.local.neon).\n  blog:update                Update database schema (set-up DB credentials in config.local.neon).\ndbal\n  dbal:import                Import SQL file(s) directly to Database.\norm\n  orm:clear-cache:metadata   Clear all metadata cache of the various cache drivers.\n  orm:clear-cache:query      Clear all query cache of the various cache drivers.\n  orm:clear-cache:result     Clear all result cache of the various cache drivers.\n  orm:convert-mapping        Convert mapping information between supported formats.\n  orm:convert:mapping        Convert mapping information between supported formats.\n  orm:generate-entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate-proxies       Generates proxy classes for entity classes.\n  orm:generate:entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate:proxies       Generates proxy classes for entity classes.\n  orm:info                   Show basic information about all mapped entities\n  orm:schema-tool:create     Processes the schema and either create it directly on EntityManager Storage Connection or generate the SQL output.\n  orm:schema-tool:drop       Drop the complete database schema of EntityManager Storage Connection or generate the corresponding SQL output.\n  orm:schema-tool:update     Executes (or dumps) the SQL needed to update the database schema to match the current mapping metadata.\n  orm:validate-schema        Validate the mapping files.\n\\--\nDíky této možnosti je možné rychle validovat Doctrine entity, nebo generovat SQL schéma přímo do databáze. Použití je opět jednoduché, např.: `php index.php orm:info`.\n\nTvorba vlastního příkazu\n========================\nPrvně je třeba si uvědomit, že tato knihovna je vlastně to samé jako je v \"Symfony Console Component\":http://symfony.com/doc/current/components/console/introduction.html, tzn. že potřebné informace se dají čerpat právě z této dokumentace a navíc existuje celá sada helperů, jako je například \"Progress Bar\":http://symfony.com/doc/current/components/console/helpers/progressbar.html, nebo třeba šikovný \"Table\":http://symfony.com/doc/current/components/console/helpers/table.html. Samotné napsání třídy (Commandu) je pak triviální záležitostí:\n\n/--code php\n<?php\n\nnamespace App\\Console;\n\nuse Doctrine;\nuse Entity;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass BlogInstall extends Command {\n\n	/** @var \\Kdyby\\Doctrine\\EntityManager @inject */\n	public $em;\n\n	protected function configure() {\n		$this->setName(\'blog:install\')->setDescription(\'Install database schema (set-up DB credentials in config.local.neon).\');\n	}\n\n	protected function execute(InputInterface $input, OutputInterface $output) {\n		try {\n        	// Zde vykonáme vše co je potřeba\n			// Zde vykonáme vše co je potřeba\n            // Zde vykonáme vše co je potřeba\n            //...\n			$output->writeLn(\'<info>[OK] - BLOG:INSTALL</info>\');\n			return 0; // zero return code means everything is ok\n		} catch (\\Exception $exc) {\n			$output->writeLn(\'<error>BLOG:INSTALL - \' . $exc->getMessage() . \'</error>\');\n			return 1; // non-zero return code means error\n		}\n	}\n\n}\n\\--\n\nZa povšimnutí stojí fakt, že tyto třídy jsou vedle presenterů dalším kandidátem na použití `@inject` anotace. V tomto příbadě bude tedy k dispozici příkaz `blog:install`, který je však nutné ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	-\n		class: App\\Console\\BlogInstall\n		tags: [kdyby.console.command]\n\\--\n\nTento způsob registrace je jedna z věcí, která mě štve a rád bych, kdyby se toto Console naučila hackovat sama a já nemusel tagovat, že se jedná o command. Když je totiž těchto příkazů hodně, konfigurační soubor tímto způsobem poměrně rychle roste na své délce a stává se nepřehledným... (-:\n\nA co je na tom?\n===============\nVždyť toto umí Symfony. To Kdyby nic jiného neumí? No, tak krom toho, že vůbec řeší integraci do Nette, což je asi hlavní úkol, tak jsou logicky součásti integrace i další části jako jsou například vlastní helpery. Není totiž nic horšího, než když v takovém commandu potřebujete presenter. Ale ono je to vlastně jednoduché:\n\n/--code php\n$presenter = $this->getHelper(\'presenter\')->getPresenter();\n\\--\n\nA stejný problém je pak s odkazy. Jak totiž v CLI pracovat s URL, když žádná není? I to Console řeší. Stačí v configu uvést:\n\n/--code neon\nconsole:\n	url: http://zlml.cz/\n\\--\n\nPak je tvorba odkazů v CLI úplná pohodička:\n\n/--code php\n$link = $presenter->link(\'//:Front:Homepage:default\');\n\\--\n\nPodívejte se na \"reálné ukázky\":https://github.com/mrtnzlml/zlml.cz/tree/6d1ad3de5b1f98067a38d2085e4939cd17cf5db5/app/commands příkazů pro Kdyby\\Console. Za sebe mohu tento nástroj jedině doporučit. Pokud potřebujete se svojí aplikací pracovat z příkazové řádky. Toto je jiná správná cesta. Díky! (-:',	'2014-08-30 16:30:52',	0,	'0000-00-00 00:00:00',	0),
(83,	'Hledá se obchodník',	'hleda-se-obchodnik',	'Tentokrát nebudu psát o ničem technickém, ale vezmu to hned od druhé věty vážně. Do \"Orgis IT\":http://www.orgis.cz/ scháníme obchodníka primárně pro Prahu / Plzeň pro rozšíření obchodního teamu. Po dlouhém rozmýšlení máme jasno co požadujeme. Nejedná se o nic zvláštního. Klasicky vyžadujeme samostatnost, pružnost a spolehlivost. To jsou celkem běžné požadavky, takže nemá smysl je zde řešit. Má však smysl řešit obchodní náplň. Jelikož se jedná o IT firmu, byl by vhodný alespoň základní přehled o tom co Orgis IT nabízí. Primárně se teď zaměřujeme na serverová řešení (opravdu velká) a vnitropodnikové ERP systémy o které je největší zájem. Jelikož se jedná o místy dost kompikovanou záležitost na pochopení, obchodník projde odborným zaškolením a i po zaškolení bude obchodník úzce spolupracovat se silnou technickou podporou a s lidmi z technické specifikace.\n\nŽivotopisy zasílejte na <span style=\"font-size:25px\"><a href=\"mailto:hr@orgis.cz\">hr@orgis.cz</a></span>\n\nUvítáme dlouhodobou spolupráci, protože se jedná o velice dynamický obor, kde je potřeba nemalá časová investice jak z naší strany, tak ze strany obchodníka. V případě oboustranné spokojenosti rádi navážeme spolupráci i pro rozvoj na zahraničním trhu. Preferujeme práci především na ŽL, kdy bude výše odměn závislá na obratu. Tato výše není omezena pásmově, ani žádnou horní hranicí.\n\nBtw, stav se pro více informací a zajdeme někam na pivko... (-:\n<br>\n(Plzeň)',	'2014-09-28 18:38:52',	0,	'0000-00-00 00:00:00',	0),
(84,	'Fígloidní odstranění záhlaví modulu',	'figloidni-odstraneni-zahlavi-modulu',	'Dnešní článek bude spíše zápisek, protože jsem řešení tohoto problému hledal neskutečně dlouho a jak se později ukázalo, tak řešení je sice jednoduché, ale je zakořeněné hluboko v jádru Odoo ERP systému. O co jde. Občas je potřeba schovat záhlaví (viz obrázek) u některých modulů.\n\n[* ddfc321c-2190-4cf6-98a9-89852713e626/vystrizek.png 500x? <]\n\nTento panel má sice dobrý důvod, ale existují případy, kde je prostě nadbytečný. Typický případ takové nadbytečnosti je modul Dashboards (technický název `board`) kdy je tento prostor nijak nevyužívaný. Zřejmě by tento problém šel řešit nějaký hackem, ale to prostě není dobře. Problém je \"zde\":https://github.com/odoo/odoo/blob/8.0/addons/web/static/src/js/views.js#L905. \"Special case for Dashboards\"...\n\nJak na to\n=========\nAsi úplně nejjasnější bude, když popíšu posloupnost kroků, které vedou ke správnému řešení. Nejedná se o nic kompikovaného. Všechny níže uváděné postupy jsou klasické postupy při vývoji modulu. Jen je (do teď) pravděpodobně nikde nenajdete, nebo nad tím zbytečně vytuhnete na zoufale dlouhou dobu. Ostatně \"podívejte se\":https://searchcode.com/?q=views_switcher%20lang:Javascript, jak je výskyt tohoto kousku užitečného kódu \"používaný\":https://github.com/odoo/odoo/search?l=javascript&q=views_switcher&type=Code&utf8=%E2%9C%93 v public repozitářích... :-)\n\n<span style=\"font-size:2em\">1.</span> Registrace XML definice v `__openerp__.conf`\n\nTato záležitost je asi celkem jasná. Jednoduše musíme definovat, že se má při compile-time brát ohled na XML soubor, ve kterém zaregistrujeme JS soubor viz další bod.\n\n/--code python\n{\n    #...\n    \n    \'data\': [\n        \'views/header.xml\',\n    ],\n    \n    #...\n}\n\\--\n\n<span style=\"font-size:2em\">2.</span> Registrace JS souboru\n\nTo jsem to ale nazval blbě... (-: V předchozím bodě je tedy definovanám soubor v podadresáři `views`, jehož obsah je např. takovýto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data>\n        <template id=\"assets_backend\" name=\"queue assets\" inherit_id=\"web.assets_backend\">\n            <xpath expr=\".\" position=\"inside\">\n                <script type=\"text/javascript\" src=\"/module_name/static/src/js/header.js\"/>\n            </xpath>\n        </template>\n    </data>\n</openerp>\n\\--\n\nTato registrace je naprosto běžná. ERP se k tomu pak staví poměrně chytře, takže když je ERP v `?debug=` módu, tak souboru vrací tak jak jsou, jinak je všechny skládá do jednoho a provádí minimalizaci. V tomto případě je rozdíl signifikantní.\n\n<span style=\"font-size:2em\">3.</span> Javascript definice\n\nJe známá věc, že si toto ERP bez JS ani neuprdne. Na jednu stranu mě to trošku štve, na druhou stranu to nemá vůbec smysl řešit. Dalším krokem proto bude definice na straně JS, která zakáže tomuto konkrétnímu view vykreslení headeru:\n\n/--code javascript\nopenerp.module_name = function (instance) {\n    //var QWeb = instance.web.qweb;\n    if (!instance.module_name) {\n        instance.module_name = {};\n    }\n\n    //zde navíc např. definice pro instance.web.qweb\n\n    instance.web.ViewManagerAction.include({\n        init: function(parent, action) {\n            var flags = action.flags || {};\n            if (action.res_model == \'module_model\' && action.view_mode === \'form\') {\n                _.extend(flags, {\n                    views_switcher : false,\n                    display_title : false,\n                    search_view : false,\n                    pager : false,\n                    sidebar : false,\n                    action_buttons : false\n                });\n            }\n            action.flags = flags\n            this._super(parent, action);\n        },\n    });\n}\n\\--\n\nToto nastavení je vlastně úplně to stejné, jako je v jádru. Jedná se o naprosto korektní a čisté řešení. Bohužel je nutné jej řešit touto myškou, protože toto není funkce, která je (nebo by do budoucna měla být) přímo podporována. Dává to smysl, protože se jedná o skutečně krajní případ.\n\nA na závěr mám pro všechny čtenáře třešničku v podobě easter eggu. Vyzkoušejte si doplnit do URL parametr `?kitten=`, stejně jako se doplňuje například ten parametr pro zapnutí debug režimu... (-: *#yourewelcome*',	'2014-10-15 22:50:13',	0,	'0000-00-00 00:00:00',	0),
(85,	'Nastavení TIM3 na STM32F207xx',	'nastaveni-tim3-na-stm32f207xx',	'Tento článek už mám dlouhou dobu v hlavě, ale nikdy jsem se neodvážil jej sepsat. Má to svůj smysl. Jedná se o poměrně náročnou problematiku, kterou si myslím, že moc lidí nechápe. Rád bych tedy tímto popíchnul čtenáře o zpětnou vazbu a pokud by se ukázalo, že to smysl má, pokračoval bych někam dál do složitějších věcí, protože toto bude ve výsledku směšně jednoduché... (-:\n\n[* f34b6d82-9aaf-4089-afe6-81993d596885/stm32.png 400x? <]\n\nK dispozici mám momentálně dva procesory, ale budu řešit konkrétně `STM32F207xx`. Ten druhý je ze `4xx` řady, ale díky novým Cube knihovnám není v programech žádný rozdíl. Alespoň ne v tom, co bu ukazovat dnes. \"STM32F207\":http://www.st.com/web/catalog/mmc/FM141/SC1169/SS1575/LN9/PF245085 je procesor založený na 32-bit ARM(R) Cortex(R)-M3 od STMicroelecronics. Jedná se o procesor s 120 MHz jádrem, 1024 kB flash pamětí na program a 128 kB SRAM. Celkově se jedná o poměrně výkonnou mršku na které se toho nechá upočítat poměrně hodně a hlavně dokáže ovládat velké množství rozmanitých periferií viz obrázek. Na obrázku je přesně ta samá eval deska s tím samým procesorem, na kterou právě teď koukám. Nejzajímavější bude teď však právě onen procesor, který je uprostřed desky a SMD diody, které nejsou téměř vůbec vidět. Ty jsou umístěny nad Wakeup tlačítkem téměř pod displejem.\n\nA teď konečně o čem budu psát. TIM3 je timer ze skupiny TIM2-5. Jedná se o timer naprosto běžný a obyčejný. Celkem jich je k dispozici 14 ve 4 skupinách podle společných vlastností. Podívat se na ně můžete do \"referenční příručky\":http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf, ale pozor ať se vám z toho nezamotá hlava, je toho tam fak hodně... (-: Ukážeme jak tento timer nastavit tak aby bylo možné blikat diodou jednou za 1000 ms. Navíc k tomu nebudeme využívat výkonu procesoru, ale využijeme přerušení, takže nebudeme procesor vůbec ničím zdržovat. O zrovna čekání procesoru 1000 ms, než bude moci bliknout diodou by byl slušný zabiják výkonu.\n\nNastavení TIMx a diod\n=====================\nJe to jednudché. V souboru `main.c` existuje klasická viod metoda s while smyčkou, která bude na začátku i na konci tohoto programu prázdná:\n\n/--code cpp\n#include \"main.h\"\nint main(void) {\n	HAL_Init();\n    SystemClock_Config();\n	# ...\n	while (1) {\n	}\n}\n\\--\n\nCílem je neudělat žádnou blbost a nechat procesor nejlépe bez toho aby něco musel počítat, což je díky přerušení možné a doporučované. HAL (Hardware abstraction layer) vrstu a systémové hodiny nastavíme co nejdříve. `HAL_Init();` je systémová funkce Cube knihoven, která provede inicializaci HW abstraktní vrstvy. Ve skutečnosti HAL_Init spouští celou řadu dalších initů. `SystemClock_Config();` je již uživatelská metoda, která je umístěna v každém demu v Cube Examples, takže ji sem nebudu přepisovat. Je téměř vždy stejná. Následovat by však měla inicializace diod. Dalo by se to udělat i složitě, ale s využitím BSP (Board support package) je inicializace triviální:\n\n/--code cpp\nBSP_LED_Init(LED1);\n# LED2, LED3, LED4\n\\--\n\nTeď tedy máme nastartovanou desku, hodiny a připravené diody k použití. Nezbývá než se pustit do nastavování timeru:\n\n/--code cpp\n/*##-1- Configure the TIM peripheral #######################################*/\nTimHandle.Instance = TIMx;\nTimHandle.Init.Period = 10000;\nTimHandle.Init.Prescaler = (uint32_t)(((SystemCoreClock / 2) / 10000) - 1); //10kHz\n// T = 1/f = 1/10k = 0,0001 ; time = Period * T = 1s\nTimHandle.Init.ClockDivision = 0;\nTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;\nif(HAL_TIM_OC_Init(&TimHandle) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\n`TIMx` je v `main.h` nastaven na TIM3, period je délka intervalu a prescaler je předdělička frekvence, která je díky tomu výpočtu nastavena nezávisle na rychlosti hodin na jednotnou frekvenci 10 kHz. Teď si stačí jen oprášit středoškolskou elektroniku. Pokud víme, že `T = 1/f` a frekvence je 10 000 Hz, pak je perioda takového průběhu 0,1 ms. To je docela průser, protože je to srašně rychlé. Proto je zde právě ta perioda timeru, kde v podstatě říkáme, že toto má proběhnout 10 000x a pak až cvrnknout timerem. A voilà, máme 1 vteřinu. `TIM_COUNTERMODE_UP` přávě říká, že bude počítat dokud nenarazí na strop a pak timer přeteče. Snad jedině pozor na jednu zradu. TIM3 má prescaler 16 bitový, tzn. lze nastavit maximálně hodnotu 2^16 -1 = 65535! Vzhledem k tomu, že to z výpočtu není přímo vidět, tak se na to můžete snadno nachytat a timer pak poběží jinak než bylo požadováno. Dále si nastavíme kanál, který budeme využívat k blikání diodou, protože teď timer pouze dojede na 10 000 a vyresetuje se:\n\n/--code cpp\n/*##-2- Configure the Output Compare channels #########################################*/\nsConfig.OCMode = TIM_OCMODE_TOGGLE;\nsConfig.Pulse = uhCCR1_Val;\nsConfig.OCPolarity = TIM_OCPOLARITY_LOW;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK) {\n	Error_Handler();\n}\nsConfig.Pulse = uhCCR2_Val;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_2) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\nPřed vstupem do main metody je zapotřebí nastavit si ještě pulse hodnoty:\n\n/--code cpp\n__IO uint32_t uhCCR1_Val = 100;\n__IO uint32_t uhCCR2_Val = 200;\n\\--\n\nAbych to krátce vysvětlil. Tímto jsem si nastavil, že až timer dosáhne hodnoty 100 a 200, tak cvrnkne a to pokaždé do jiného kanálu. Při dosažení maxima (10 000) dojde k přetečení timeru a ten začne počítat znovu. Je jedno jak tyto hodnoty nastavím, ale musí být od sebe 100 ms. Chci totiž zapnout diodu a dned ji vypnout. Toto se bude opakovat každných 1000 ms viz předchozí nastavení timeru. Super, takže teď máme timer co počítá a v určitém okamžiku pošle dva signály. Tak to nahodíme a jedeme... (-:\n\n/--code cpp\n/*##-3- Start signals generation #######################################*/\n/* Start channel 1 in Output compare mode */\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_1) != HAL_OK) {\n	Error_Handler();\n}\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_2) != HAL_OK) {\n	Error_Handler();\n}\n\\--\n\nSkvělé na tom je to, že teď už to fakt cvaká a stačí se na to jen pověsit přepínání stavu diod.\n\nKonečně blikáme!\n================\nK tomu, aby bylo možné blikat, musíme se chytit callbacku, který je v HAL připraven. Zde se podíváme, jestli je daný kanál aktivní a pokud ano, znamená to, že můžeme něco udělat. V tomto případě tedy nejdříve zapnu diodu a za 100 ms přijde signál druhým kanálem a já ji mohu opět vypnout. Za 1s se celý proces opakuje. Paráda!\n\n/--code cpp\n/**\n  * @brief  Output Compare callback in non blocking mode \n  * @param  htim : TIM OC handle\n  * @retval None\n  */\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim) {\n	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {\n		BSP_LED_On(LED1);\n  	}\n	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) {\n		BSP_LED_Off(LED1);\n  	}\n}\n\\--\n\nJeště bych měl zmínit metodu `Error_Handler();`, která se zde často opakuje. Je to metoda, která se zavolá, když se něco nepovede a její obsah může být opět prázdná smyčka, aby procesor nezačal dělat nějaké nesmysly:\n\n/--code cpp\n/**\n  * @brief  This function is executed in case of error occurrence.\n  * @param  None\n  * @retval None\n  */\nstatic void Error_Handler(void) {\n	BSP_LED_On(LED4);\n	while(1) {}\n}\n\\--\n\nAsi není úplně hloupé zapnout i nějakou (červenou) diodu, která bude signalizovat error. Rád bych zmínil to, že by bylo možné v main metodě v cyklu spustit `BSP_LED_Toggle(LED4);` a počkat 1 vteřinu. To by bylo funkční, ale jak by se ukázalo časem, tak by tento program mohl sloužit pouze pro blikání diodou, což není moc užitečné. Pokud bych se k tomu dostal, tak si můžeme ukázat jak pracovat s ethernetem a zde se ukáže, že je prázdný while potřeba. Tímto způsobem mi však nic nebrání blikat si diodou a vedle toho ještě tlačit data ethernetem pryč...\n\nTak co, dalo se to vydržet? :-)',	'2014-10-19 00:02:30',	0,	'0000-00-00 00:00:00',	0),
(86,	'Heatmapy ve Wolfram Mathematica',	'heatmapy-ve-wolfram-mathematica',	'[* 1bb55605-d567-4fe0-b1d1-69e921940e0d/heatmap1.png ?x300 <]\n\nPrávě teď jsem řešil jak vizualizovat nějaká data, která jsou v maticovém formátu. Pro mé účely jsou prakticky dva grafy. Prvním grafem je heatmapa (viz obrázek) a druhým klasický 3D graf, který data reprezentuje stejně dobře (možná lépe), ale v určitých případech je špatně čitelný. Zejména pak když není možnost s grafem otáčet. V mém případě bylo zapotřebí poměrně velké množství grafů, které jsem nakonec minimalizoval na počet 40, takže bylo nemožné je vykreslovat ručně. Zvlášť pokud jsem zajistit, že budou všechny grafy stejné.\n\nK tomu jak jsem postupoval se dostanu v další části. Teď však ještě pár úvodních slov k tomu, co jsem to vlastně měřil. Cílem měření bylo změřit s využitím jasoměrů hodnoty jasů *L [cd/m^2]* určitých objektů a jejich okolí v pravidelné síti kontrolních bodů při různém osvětlení (denní, sdružené a umělé) a různé vzdálenosti a úhlu. Z těchto jasů je zapotřebí spočítat kontrast *C [-]* a tuto kontrastní mapu také vizualizovat. Je tedy zřejmé, že stačí změřit pár objektů a počet grafů rychle roste.\n\nVizualizace dat\n===============\n[* 40a97326-5410-4385-821c-62dc8542387a/3d2.png 300x? >]\nTato část se sice jmenuje vizualizace dat, ale aby bylo co vizualizovat, je zapotřebí data připravit. Já jsem zvolil JSON formát vstupu, protože se velmi jednoduše parsuje a matici v něm mohu zapsat také jednoduše. Z měření jednoho objektu mi tedy stačí data v tomto formátu:\n\n/--code javascript\n{\n	\"Tabule - umělé osvětlení\": {\n		\"up\": \"STROP\",\n		\"down\": \"PODLAHA\",\n		\"left\": \"OKNA\",\n		\"right\": \"DVEŘE\",\n		\"values\": [\n			[121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7],\n			[96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5],\n			[82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5],\n			[63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5],\n			[62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5]\n		]\n	}\n}\n\\--\n\nTakových dat je již možné se chytit a vykreslit celou řadu průběhů. Samotný parser se však postupem času poměrně zkomplikoval. Prohlédnout si ho však můžete \"na GitHub Gistu\":https://gist.github.com/mrtnzlml/9ec02541555e419a8df9#file-parser7-php a to včetně kompletního vstupu a výsledného výstupu pro Wolfram Mathematica. Tento výstup je v zásadě jednoduchý. Například graf, který je v úvodu vykreslíme pomocí následujícího výstřižku:\n\n/--code php\nShow[MatrixPlot[{\n	{-0.063, -0.753, -0.706, -0.788, -0.443, 0.311, 0.327},\n	{0.619, 0.613, 0.671, -0.013, -0.162, 0.295, 0.344},\n	{0.297, 0.441, 0.351, 0.178, 0.087, 0.166, 0.339},\n	{-0.085, 0.27, 0.225, 0.155, 0.118, 0.163, 0.317},\n	{-0.033, 0.017, -0.015, 0.03, 0.019, 0.077, 0.198}\n}, PlotTheme -> \"Detailed\", Mesh -> Automatic, MeshStyle -> Directive[GrayLevel[0], Opacity[0.5], Dashing[{0, Small}]]],\nFrameLabel -> {{HoldForm[OKNA], HoldForm[DVEŘE]}, {HoldForm[PODLAHA], HoldForm[STROP]}},\nPlotLabel -> RawBoxes[\"Tabule - umělé osvětlení, zezadu (kontrast, Lp = 59.7)\"], LabelStyle -> {GrayLevel[0]}]\n\\--\n\n[* 79b1a8e3-1efc-42b0-bb79-3409b9acd49d/3d.png <]\n\nKromě nastavování popisek a záhlaví, tak je důležitý hlavně blok kde jsou data. V tomto grafu není žádná zrada. Malá zrada číhá až v 3D grafech. Zde je háček v tom, že občas relativně malá plocha grafu ustřelí mimo průměrnou hodnotu všech bodů a na grafu dojde k oříznutí. Aby se tomuto efektu předešlo, je bezpodmínečně nutné nastavit grafu `PlotRange -> All`. Tím se vykreslí celý graf nezávisle na tom, jaké obsahuje extrémní hodnoty. Je však otázka jestli je to žádoucí. V mém případě ano, ale umím si přestavit případy, kdy by velká špička totálně zničila celý graf a bylo by výhodnější spičku oříznout.\n\n/--code php\nListPlot3D[{\n	{62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5},\n	{63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5},\n	{82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5},\n	{96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5},\n	{121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7}\n}, ColorFunction -> \"DarkRainbow\", PlotRange -> All, PlotTheme -> \"Business\"]\n\\--\n\nPro vykreslení horního pohledu stačí přidat další atribut `ViewPoint -> Above`, čímž získáme teplotní mapu v trošku jiném zobrazení a díky Business tématu budou na grafu vidět i vrstevnice, což ulehčí představu o tom jak je graf tvarově rozložen. <span style=\"color:green\">Také pozor na to, že do funkcí `MatrixPlot` a `ListPlot3D` se zadávají matice v obráceném pořadí z hlediska řádek matice! Dojde tak ke vykreslení stejných map.</span>',	'2014-10-25 15:31:33',	0,	'0000-00-00 00:00:00',	0),
(87,	'Dependent select box',	'dependent-select-box',	'Občas je v Nette zapotřebí vyřešit dependent select box. Je to relativně málo častý požadavek a o to méně se o něm dá najít, když je to zrovna potřeba. V zásadě existují dvě řešení. Nudné - poctivé a pak zábavné - špinavé. Podívejme se na to, jak se dá takový dependent select box jednoduše vyřešit.\n\nČisté řešení\n============\n[* 51d212f2-5aa9-44b9-9085-f6267e1974e9/vystrizek.png >]\nToto řešení ukazuje jak by se takový problém měl zhruba řešit. Myšlenka je velmi jednoduchá. Prvně potřebujeme data do závislého select boxu. Ty se normálně vyřeší prostřednistvím databáze, v našem případě postačí jednoduché pole.\n\n/--code php\nprivate $database = [\n    [1 => \'2\', \'4\', \'9\'],\n    [4 => \'.\', \'∴\', \'…\'],\n    [5 => \'π\', \'€\', \'©\'],\n];\n\\--\n\nNásledně je potřeba vytvořit samotný formulář:\n\n/--code php\nprotected function createComponentForm($name) {\n    $form = new UI\\Form;\n    $this[$name] = $form; // <- Zde je celý fígl\n    \n    $form->addSelect(\'one\', \'One\', [\'Čísla\', \'Tečky\', \'Symboly\'])->setDefaultValue(1);\n    //dump($form[\'one\']->value);\n    \n    $form->addSelect(\'two\', \'Two\', $this->database[$form[\'one\']->value]);\n    \n    $form->addSubmit(\'send\', \'Odeslat\');\n    $form->onSuccess[] = $this->success;\n    return $form;\n}\n\\--\n\nA k formuláři také šablonu:\n\n/--code html\n{form form}\n    {input one, size => 3}\n    {snippet two}\n    	{input two, size => 3}\n    {/snippet}\n    {input send}\n{/form}\n\\--\n\nAby šlo použít snippet uvnitř formulářového makra, budeme muset udělat malý workaround:\n\n/--code php\npublic function beforeRender() {\n	parent::beforeRender();\n	$this->template->_form = $this[\'form\']; // form {snippet} workaround\n}\n\\--\n\nSnippet je však možné zatím úplně vynechat, protože bude potřeba až při ajaxifikaci.\n\nCelý fígl je v tom, že musíme zajistit, aby se hodnota druhého select boxu nastavovala podle hodnoty prvního. V tomto stavu je již možné formulář spustit. Po vybrání v prvním select boxu a odeslání formuláře se vybraná hodnota následně projeví v druhém select boxu. Celé kouzlo je pouze v té druhé řádce formulářové továrničky, který mi umožní přistoupit k hodnotám prvků. Je samozřejmě nesmysl odesílat celý formulář pro získání obsahu druhého select boxu, proto si napíšeme krátký javascriptový kód, který to za nás vyřeší (nette.ajax.js):\n\n/--code javascript\n$(function(){\n	$.nette.init();\n    \n	$(\'select[name=one]\').change(function () {\n		$.nette.ajax({\n			url: {link invalidate!},\n			data: {\n				\'value\': $(\'select[name=one]\').val(),\n			}\n		});\n	});\n});\n\\--\n\nJakmile se změní hodnota prvního select boxu, zavoláme si handler a předáme mu novou hodnotu. Tento handler bude mít za úkol nastavit hodnoty druhého select boxu a pouze tento prvek invalidovat:\n\n/--code php\npublic function handleInvalidate($value) {\n	$this[\'form\'][\'two\']->setItems($this->database[$value]);\n	$this->redrawControl(\'two\');\n}\n\\--\n\nTím je vlastně hotovo. Čistotu řešení ověříme tím, že si vyzkoušíme dump vybraných položek po odeslání formuláře:\n\n/--code php\npublic function success(UI\\Form $form, $vals) {\n	dump($vals);\n}\n\\--\n\nČistota spočívá v tom, že požadované hodnoty skutečně získáme. To není úplně samozřejmé, protože v Nette existuje bezpečnostní obranný mechanismus, který zabraňuje odeslání hodnot v select boxu, které na začátku neobsahoval. Pokud něco takového uděláme třeba javascriptem, zíkáme `NULL`. Aby se toto nedělo, musíme takto relativně složitě vyřešit továrničku pro formulář.\n\nŠpinavé řešení\n==============\nŠpinavé řešení se od toho čisté o moc neliší. Myšlenka je pořád stejná, tentokrát však stojíme před jiným úkolem. Vezměme si příklad, kdy nám zase až tolik nezáleží na tom, jaké získáme v select boxu hodnoty a chceme ho používat spíše jako text input, kdy nabídneme uživateli nějaký vstup. Typický příklad je text input pro URL adresu API, kdy po zadání kontaktujeme nějaké API a nabídneme v selectu vrácené hodnoty tak, aby je uživatel nemusel psát. Netvrdím, že by to nešlo vyřešit čistě, ale špinavé řešení je v tomto případě pohodlnější, rychlejší a mohu na něm ukázat i něco jiného. Tentokrát si vytvoříme úplně obyčejný formulář, tak jako již mnohokrát. Není potřeba žádného fíglu. Opět si připravíme šablonu pro formulář obdobně jako v předchozím případě. A obdobně doplníme nějaký ten javascript. Zde bych klidně mohl formulář upravit javascriptově, ale mě se hodí zavolat si (po napsání URL adresy) handler, v něm vyřešit vše potřebné a invalidovat část formuláře.\n\n/--code javascript\nvar timer = null;\n$(\'input[name=url]\').live(\'keyup\', function () {\n	if (timer) {\n		clearTimeout(timer);\n	}\n	timer = setTimeout(function () {\n		timer = null;\n		$.nette.ajax({\n			url: {link checkErp!},\n			type: \'POST\',\n			data: {\n				\"erpForm-url\": $(\'input[name=url]\').val()\n			}\n		});\n	}, 250);\n});\n\\--\n\nHandler nemá smysl uvádět. Jednoduše v něm vykonám nějakou logiku, vrátím data a invaliduji šablonu. Pozor na to, že předchozí javascriptová ukázka je tentokrát ze separátní komponenty.\n\nZbývá nám vyřešit pouze odeslání a zpracování formuláře. Jelikož jsem byl teď líný programátor a select v tomto případě beru spíše jako text input, nemohu získat hodnotu select boxu ve `$form->getValues()`, resp. v druhém parametru succeeded metody. Musím proto použít metodu `getHttpData`, která mi umožní získat jakákoliv data a zároveň mám jistotu, že jsou data ošetřena:\n\n/--code php\npublic function erpFormSucceeded(UI\\Form $form, Nette\\Utils\\ArrayHash $values) {\n	try {\n		$this->erpSystems->create([\n			ErpSystems::COLUMN_URL => $values->url,\n			ErpSystems::COLUMN_DATABASE => $form->getHttpData(UI\\Form::DATA_LINE, \'database\'), // <- náš select\n			ErpSystems::COLUMN_USER => $values->username,\n			ErpSystems::COLUMN_TOKEN => $values->password,\n		]);\n		//...\n	} catch (\\PDOException $exc) {\n		//...\n	}\n	//...\n}\n\\--\n\nV tomto špinavém řešení je však zapotřebí myslet na to, že v selectu může přijít naprosto cokoliv. To by však nikoho nemělo převapit. Ostatně i při vytváření formuláře stačí vytvořit select box prázdný, protože žádná vstupní data ani neexistují.',	'2014-11-01 20:09:57',	0,	'2015-04-13 20:23:18',	0),
(88,	'Nadvláda inteligentních procesorů',	'nadvlada-inteligentnich-procesoru',	'Pár dní zpátky jsem tweetoval o tom, nad čím právě teď trávím asi nejvíce času. Cílem celého mého snažení je dostat data z procesoru, který obsluhuje různé periferie na základní desce až do webového prohlížeče a zpět - vše v reálném čase. Právě dnes jsem dosáhl prvního milníku, tedy dostal jsem nějaká skutečně smysluplná data do prohlížeče a rád bych zde nastínil jak jsem postupoval a jaké technologie jsem volil. Již dříve se totiž ukázalo, že některé reakce na mé články jsou skutečně konstruktivní a tedy i velmi přínosné... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Procesor ➡Ethernet ➡NodeJS ➡Redis ➡ExpressJS ➡Socket.IO ➡Browser ✅ <a href=\"http://t.co/MAIlmMZEL9\">pic.twitter.com/MAIlmMZEL9</a></p>&mdash; Martin Zlámal (@mrtnzlml) <a href=\"https://twitter.com/mrtnzlml/status/531104236571230208\">November 8, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNěkolik slepých uliček\n======================\nPůvodně byl celý nápad úplně jiný a rozhodně ne real-time. A stejně jako je teď velký trend stavět vše pomocí *Raspberry Pi* nebo pomocí *Arduino*, tak i já jsem tak chtěl učinit. Důvod je jednoduchý. Napsat se s pomocí těchto desek dá všelicos velmi rychle a nestojí to moc námahy. Navíc jsem chtěl více času věnovat webové aplikaci, než nějakému mikročipu. Postupem času a po několika vážných rozhovorech jsem začal přemýšlet nad real-time přenosem informace v obou směrech. Takže bylo zapotřebí najít vhodnou desku. Jenže na real-time už jsem si jen s *Raspberry* nevěřil a proto jsem hledal nějakou lepší desku na kterou bych nahodil nějaký velmi lehký Linux a NodeJS. Po dalších vážných rozhovorech jsem však i z této cesty ustoupil a zvolil jsem něco, co jsem ze začátku vůbec neuvažoval. Chtěl jsem zvolit desky od ST z řady \"Nucleo\":www.st.com/stm32nucleo, ale tyto desky nemají ethernet a tak bylo lehčí vypůjčit si \"eval-boardy\":www.st.com/stm3220g-eval. Tyto desky mají stejné procesory, ale více periferií okamžitě k dispozici. Jenže to znamená, že musím opustit všechno hraní si a hluboce se ponořit do **C**čka...\n\nSprávná ulička?\n===============\nDesky a procesory jsou tedy jasné. Co dál? Nezbývá než stanovit, jak se bude informace přenášet až do prohlížeče. Zde je zřejmě jasná věc to, že mezi procesorem a prohlížečem musí být nějaký mezičlen. Ten u mě tvoří \"NodeJS\":http://nodejs.org/ server v kombinaci s \"Redis\":http://redis.io/ databází zhruba tak, jak je znázorněno na \"ASCII artu\":http://cs.wikipedia.org/wiki/ASCII_art níže:\n\n/--code\n------------      ----------      -----------\n| Procesor | ---> | NodeJS | ---> | Browser |\n------------      ----------      -----------\n        |             ^\n        |             |\n        |         ---------\n        --------> | Redis |\n                  ---------\n\\--\n\nJak celý přenos v současné chvíli probíhá? Procesor je teď aktivním prvkem, tzn. sbírá nějaká potřebná data (např. pomocí ADC snímá polohu natočení potenciometru) a pomocí UDP datagramů je odesílá na jasně danou IP adresu NodeJS serveru, kde se informace z datagramu uloží do dané struktury v Redis databázi. Tyto datagramy se skládají z klasické UDP hlavičky a datové části. Ta je v \"RESP\":http://redis.io/topics/protocol formátu, takže teoreticky bude někdy později možné NodeJS server úplně přeskočit a data ukládat přímo z procesoru do databáze jak je na diagramu naznačeno. Server však nikdy nepůjde úplně odstranit, protože na NodeJS serveru běží v této chvíli UDP server, ale také tam běží webový server (\"ExpressJS\":http://expressjs.com/), který mi umožňuje rovnou vytvořit webovou stránku a s pomocí \"Socket.IO\":http://socket.io/ si mohu otevřít websocket a z databáze opět informace odesílat bleskovou rychlostí do prohlížeče, kde je mohu javascriptem nějak dále zpracovat.\n\nK čemu to celé je?\n==================\nNevím. (-: Tento článek jsem napsal proto, abych si utřídil myšlenky a získal zpětnou vazbu. Celý projekt měl však původně být pro tzv. inteligentní domy, kdy by stačilo dům pouze zasíťovat a vše ostatní by již bylo vlastně hotovo (přes ethernet lze i napájet). Výhodné je to v tom, že můžete kdykoliv jakýkoliv prvek domácnosti odpojit, dát ho na jiné místo (v rámci IP rozsahu) a vše by stále fungovalo. Jenže jak často přesouváte vypínače (termostaty, světla, senzory)? Proto se chci spíše zaměřit na objekty kde se tyto věci často řeší, proto vidím správný směr spíše v (relativně) často se měnících kancelářských budovách, nebo tam kde je potřeba například rychle připojit nějaké senzory a sledovat je online. Každopádně věřím, že díky svým možnostem tento systém natrhne zadek i současným systémům pro ovládání \"inteligentních\" domů využívajících PLC-like systémy.\n\nBudoucnost je zatím celkem jasná. Teď chci naučit systém komunikovat i v opačném směru a následně jej budu pilovat, čímž završím první etapu práce. Cest pro rozšiřování je však ještě spoustu. Jednak chci systém naučit komunikovat bezdrátově, pak také IPv6, šifrovanou komunikaci a v neposlední řadě chci vyrobit nějaké senzory a akční členy pro reálné použití a zprovoznit funkční ukázku pro prezentování celé této srandy.\n\nTak co, máte dostatek odvahy šoupnout si takový systém do baráku? Upozorňuji, že to není žádná Arduino-like stavebnice, takže to je spolehlivé... (-:',	'2014-11-17 23:44:14',	0,	'0000-00-00 00:00:00',	0),
(89,	'Přednáška na ZČU - Node.js',	'prednaska-na-zcu-node-js',	'Jak jsem slíbil, tak zveřejňuji přenášku na téma **Node.js**, kterou jsem měl dnes na Západočeské univerzitě pro lidi studující předmět **KIV/WEB**, tedy Webové aplikace. Tato přednáška volně navazuje na předchozí obsah tohoto předmětu. Studenti se pozvolna seznamují s webovým prostředím od úplně základní práce s HTML a CSS až k pokročilým webovým frameworkům. Podívejte se na záznam této přednášky:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/eakg5THIbcI\" frameborder=\"0\" allowfullscreen></iframe>\n\nA prohlédněte si také připravenou prezentaci:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42314371\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nRád bych také poděkoval \"Honzovi *chemix* Černému\":http://honzacerny.com/ za zapůjčení kamery.\n\nA příště? Příště se podíváme na skvělý PHP framework \"Nette\":http://nette.org/! Tak doufám, že opět dorazíte... (-:',	'2014-12-03 20:55:04',	0,	'0000-00-00 00:00:00',	0),
(90,	'Poslední přednáška na FAV - Nette',	'posledni-prednaska-na-fav-nette',	'Tak a je to... (-:\n\nZveřejňuji mojí poslední přednášku v tomto roce, kterou jsem měl na ZČU na fakultě aplikovaných věd pro studenty předmětu KIV/WEB. Tentokrát jsem si pohrál trošku se zvukem, takže by to oproti \"minulému týdnu\":http://zlml.cz/prednaska-na-zcu-node-js mělo být o mnoho lepší.\n\nTématem této přednášky byl můj oblíbený Nette Framework, konkrétně ve verzi 2.3-dev. Cílem bylo seznámit studenty se základní myšlenkou MVC/P a rychle nastínit o co vlastně v Nette jde a  jak se v něm staví jednoduché aplikace. Přednáška nakonec utekla rychleji než jsem čekal a nemohl jsem ukázat vše, proto jsem připravil repozitář na \"GitHubu\":https://github.com/mrtnzlml/kivweb-nette-fcbk ze kterého by mělo být vše jasné (pokud není, můžete se ještě dodatečně ptát).\n\nKonec písmenek, podívejte se sami:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/GdATlrmoPRM\" frameborder=\"0\" allowfullscreen></iframe>\n\nA samozřejmě nesmí chybět samotná prezentace:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42574181\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nOpět také děkuji \"Honzovi *chemix* Černému\":http://honzacerny.com/ za zapůjčení kamery.',	'2014-12-10 20:53:10',	0,	'0000-00-00 00:00:00',	0),
(91,	'RESP protokol - přímý přístup k Redis databázi',	'resp-protokol-primy-pristup-k-redis-databazi',	'\"**RESP**\":http://redis.io/topics/protocol (**RE**dis **S**erialization **P**rotocol) je něco, s čím se asi většina lidí nepotká. Důvod je prostý. Tento protokol je většinou zabalen hluboko v knihovně, která pracuje s Redis databází. Existují však situace, kdy se tento protokol hodí. Jednou ze situací je stav, kdy potřebujete předat, nebo naopak získat z Redisu nějaká data a všechno ostatní vyjma RESP komunikace je zbytečné zdržování (u mě třeba sypání dat z procesoru přímo do Redisu). Druhý případ nastane v okamžiku, kdy potřebujete zajistit komunikaci klient-server a potřebujete zvolit vhodný formát přenosu informací. Jedná se tedy o použití tohoto protokolu úplně mimo Redis. Důvodů může být celá řada, nejhlavnější by však byl asi ten, že se s RESP formátem dat dá snadno pracovat, protože používá prefixový zápis.\n\nFormát RESP protokolu\n=====================\nRESP používá celkem 5 způsobů jak zaobalit přenášenou informaci. Vždy však platí, že první byte je byte určující o jaký formát se jedná:\n\n- `+` jednoduchý string\n- `-` error\n- `:` integer\n- `$` bulk string (binary safe)\n- `*` array\n\nNásleduje samotný obsah, nebo dodatečné informace, například o délce a vše je ukončeno pomocí CRLF (`\\r\\n`). Postupně tedy přenášené informace moho vypadat například takto:\n\n- `+PONG\\r\\n`\n- `-Error 123\\r\\n`\n- `:54986\\r\\n`\n- `$4\\r\\nPING\\r\\n` (první část určuje délku bulk stringu, NULL je pak `$-1\\r\\n`)\n- `*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n` (první je délka pole, následuje kombinace předchozích)\n\nTo je celé, žádná věda v tom není. Je to skutečně jednoduchý protokol a to je super, protože se s ním dá snadno pracovat. Navíc lze poslat celý dlouhý text obsahující více příkazů v jednom spojení.\n\nImplementace v Node.js\n======================\nV Node.js by teď měla být realizace velmi jednoduchá. Napíšeme si krátký TCP client, který se nám napojí na Redis databázi (většinou port 6379) a budeme posílat/přijímat data:\n\n/--code javascript\nvar net = require(\'net\');\n\nvar client = net.connect({port: 6379}, function() {\n	console.log(\'Connected to the Redis server.\');\n\n	client.write(\'*1\\r\\n$4\\r\\nPING\\r\\n\');\n	client.write(\'*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nxxxxx\\r\\n\');\n	client.write(\'*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n\');\n	client.write(\'*5\\r\\n$5\\r\\nPFADD\\r\\n$11\\r\\nHyperLogLog\\r\\n$3\\r\\nxxx\\r\\n$3\\r\\nyyy\\r\\n$3\\r\\nzzz\\r\\n\');\n	client.write(\'*2\\r\\n$7\\r\\nPFCOUNT\\r\\n$11\\r\\nHyperLogLog\\r\\n\');\n\n	client.write(\'*1\\r\\n$7\\r\\nFLUSHDB\\r\\n\');\n});\n\nclient.on(\'data\', function(data) {\n	console.log(data.toString());\n	client.end();\n});\n\nclient.on(\'end\', function() {\n	console.log(\'Disconnected from the Redis server.\');\n});\n\\--\n\n<span style=\"color:green\">Ještě jednu poznámku, kterou jsem do původního článku nezahrnul. Proč jsou udesílaná data zabalena v RESP poli? Vychází to z toho, že podle dokumentace, by klient měl posílat na server pole bulk stringů. Nicméně dobře funkční a validní zápis je i bez pole (`client.write(\'GET key\\r\\n\');`) jen musí být opět ukončen pomocí CRLF.</span>\n\nOdesíláme do Redis databáze celkem 6 příkazů. První je obyčejný `PING`, následuje `SET` a `GET` klíče, `PFADD` a `PFCOUNT` z HyperLogLog datového dypu a nakonec jen smazání databáze. Co bude výstupem?\n\n/--code\n+PONG\n+OK\n$5\nxxxxx\n:0\n:3\n+OK\n\\--\n\nJak je možné, že server vrátil 7 odpovědí? Je to prosté, upravíme si datový callback ať je zřejmé, co skutečně dostáváme za data:\n\n/--code javascript\nclient.on(\'data\', function(data) {\n	console.log(JSON.stringify(data.toString()));\n	client.end();\n});\n\\--\n\nTeď už bude výstup o něco jiný:\n\n/--code\n\"+PONG\\r\\n+OK\\r\\n$5\\r\\nxxxxx\\r\\n:0\\r\\n:3\\r\\n+OK\\r\\n\"\n\\--\n\nA vše již dává smysl. První odpověď je `PONG` (na `PING`), následuje reakce `OK` na nastavení klíče, odpověď ve formě bulk stringu, který má dvě části - délku a samotnou textovou odpověď (proto to odřádkování navíc), následuje odpověď z `PFADD` (0 nebo 1 podle situace) a také odpověď z `PFCOUNT` (mohutnost množiny v HyperLogLog). Poslední `OK` je reakce na `FLUSHDB`. Jak je vidět, tak i v odpovědi je prvním znakem formát dat dané odpovědi.\n\nTakto jsem to celkem zbytečně (ale pro přehlednost) rozepisoval. Celá komunikace směrem k serveru by se dala napsat do jednoho požadavku:\n\n/--code\n*1\\r\\n$4\\r\\nPING\\r\\n*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nxxxxx\\r\\n*2\\r\\n$3\\r\\nGET\\r\\n$3\\r\\nkey\\r\\n*5\\r\\n$5\\r\\nPFADD\\r\\n$11\\r\\nHyperLogLog\\r\\n$3\\r\\nxxx\\r\\n$3\\r\\nyyy\\r\\n$3\\r\\nzzz\\r\\n*2\\r\\n$7\\r\\nPFCOUNT\\r\\n$11\\r\\nHyperLogLog\\r\\n*1\\r\\n$7\\r\\nFLUSHDB\\r\\n\n\\--\n\nOdpověď by zůstala stejná.',	'2014-12-23 23:53:54',	0,	'2014-12-23 23:53:54',	0),
(92,	'Dva příklady toho, proč není JS připravený',	'dva-priklady-toho-proc-neni-js-pripraveny',	'Tento článek nastartoval jeden hloupý tweet. Měl jsem jej na \"to do\" listu již nějaký čas, ale čekal jsem až to někdo tweetne... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/MartinSadovy\">@MartinSadovy</a> Možná ale to není podstatné. Podstatné je, že JS běží v prohlížeči i na serveru. Isomorphism ftw. PHP je evoluční mrtvola.</p>&mdash; Daniel Steigerwald (@steida) <a href=\"https://twitter.com/steida/status/551431843560824832\">January 3, 2015</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNebudu řešit jak je hloupý. Neznám totiž žádnou objektivní stupnici kam bych jej mohl zařadit. Pomůže mi však oprášit pár věcí, které mě štvou a třeba se ukáže, že to dělám úplně špatně. Poslední dobou totiž kopu za \"Node.js\":http://nodejs.org/ (potažmo \"Express.js\":http://expressjs.com/), C i \"Nette\":http://nette.org/ tábor. Vše v jednom projektu. Nicméně jsem odkojen na Nette a tak některé věci řeším v jiném frameworku téměř až se slzou v oku.\n\nRád bych upozornil na to, že nejsem žádný superprogramátor, takže je skutečně možné, že k problému přistupuji špatně. Proto bych byl rád za rozumné podněty a připomínky, nikoliv osobní výstřednosti v komentářích...\n\n1. Odkazy\n=========\nA hned pěkně z ostra. Jak jsem již zmínil, jsem odkojen na Nette a proto jsem náležitě rozmazlen. Ale rozmazlen v dobrém slova smyslu. Považuji totiž framework za věc, která mi má pomoci. Nikoliv házet klacky pod nohy. Jednou z takových věcí je tvorba odkazů. Jak by to mělo být správně? Přesně tak jak je to v Nette, čili je zapotřebí najký systém, který mi umožní stavět odkazy a zároveň mi umožní je kdykoliv změnit bez zásahu do šablon. Jak je tomu v takovém Exresss.js, webovém frameworku pro Node.js? V Express.js je defaultně šablonovací systém \"Jade\":http://jade-lang.com/. Nemluvě o tom, jaký je to nešťastný systém, odkazy se v něm vytvářejí zhruba takto:\n\n/--code html\na(href=\'/\') Home\na(href=\'/about\') About\n\\--\n\nUž asi tušíte kam mířím a proč je to podle mého soudu fatální. Takový hard-code odkazů je totiž perfektně pomalá cesta do blázince. Ve skutečnosti je však mnohem větší anekdota označování aktivních odkazů. Podívejte se na \"6 WTF rad\":http://stackoverflow.com/questions/10713923/node-js-jade-express-how-can-i-create-a-navigation-that-will-set-class-acti, jak tento triviální problém vyřešit. Celý princip spočívá v tom použít hard-code odkazů na více místech v šabloně:\n\n/--code html\nul.nav.navbar-nav\n	li(class=path == \'/\' ? \'active\' : undefined)\n		a(href=\'/\') Home\n	li(class=path == \'/about\' ? \'active\' : undefined)\n		a(href=\'/about\') About\n\\--\n\nKde se bere `path`? Ten si musíte předat v routeru, např.:\n\n/--code js\nrouter.get(\'/\', function (req, res) {\n	res.render(\'homepage\', {\n		path: \'/\'\n	});\n});\n\\--\n\nTak to máme celkem 4 místa kde je to pěkně natvrďáka. Proč ne? **Proč jo?** Jistě, existuje možnost jak si to naprogramovat lépe, jinak, znova. Jen si říkám, kde se stala chyba a proč to framework nezvládá nějak lépe?\n\n2. Formuláře\n============\nJedna z věcí, která se v tomto světě řeší poněkud laxně jsou formuláře. Na to nejsem zvyklý a trošku mě to děsí. Funguje to zhruba tak, že vytvoříte v šabloně formulář:\n\n/--code html\nform(id=\'save-form\', method=\'POST\', action=\'/save\')\n	.form-group\n		label(for=\'xxx\') XXX\n		input(type=\'text\', name=\'xxx\', class=\'form-control\', id=\'xxx\', placeholder=\'xxx\', required)\n	.form-group\n		button.btn.btn-default Odeslat\n\\--\n\nA následně se napíše router pro zpracování dat:\n\n/--code js\nrouter.post(\'/save\', function (req, res) {\n	console.log(req.body.xxx); // <<< !\n	res.render(\'save\', {\n		path: \'/save\'\n	});\n});\n\\--\n\nJistě, je to jednoduché. Ale to prostě \"není ok\":http://stackoverflow.com/questions/19030220/is-it-ok-to-work-directly-on-the-data-in-req-body. Kromě toho, že je v kódu opět hard-code, tak se jedná o nádherně \"ošetřený\" vstup. Takový krásně čistý `$_POST`. Takto si framework nepředstauji. Možná je to proto, že je Express.js ještě moc low-level, možná také proto, že ještě neuzrál.\n\nNení to tak zlé\n===============\nMusím však utlumit některé pobouřené čtenáře. Nebylo by totiž fér jen něco hejtovat. Bez Node.js bych danou aplikaci naprogramoval jen velmi těžko. Je totiž super, že mohu využít \"event-driven, non-blocking I/O model\". Toto je však věc, kterou podle mého názoru moc lidí nevyužije, protože jí prostě nepotřebuje. Kolikrát něco takového programujete? Proto když jsem měl na téma Node.js \"přednášku\":http://zlml.cz/prednaska-na-zcu-node-js, jen velmi těžko jsem lidem vysvětloval k čemu je to vlastně dobré. A právě proto jsem použití Node.js paradoxně neukazoval na webové aplikaci. Třeba proto, že se s ním nepracuje úplně nejlépe, zároveň je však v určitých směrech nenahraditelný.\n\nAčkoliv jsem tedy začínal jedním hloupým tweetem, není toto rekace na něj a je mi celkem hluboce ukradený. Spíše mě zajímá jestli to co jsem zde popisoval (a celá řada dalších problémů) je normální všední den server-side JS programátora, nebo se s těmito problémy vypořádáváte jinak?\n\nEvoluční mrtvola FTW!',	'2015-01-03 23:43:09',	0,	'2015-01-03 23:43:09',	0),
(93,	'Generované továrničky - definitive guide',	'generovane-tovarnicky-definitive-guide',	'No dobře, možná ne úplně definitivní, ale užitečná příručka snad. Pokusím se zde rozebrat všechny potřebné stavy generovaných továrniček, které považuji za důležité a jejich co nejjednodušší zápis v configu. Jedná se hlavně o pohled z hlediska předávání parametrů. Doufám, že to ještě někdo doplní o nějaké vylepšení, nebo další příklad, abych mohl tento seznam rozšířit. To je jeden ze dvou důvodů tohoto typu článků. Ten druhý je, abych měl kam odkazovat, až se mě někdo bude opět ptát.\n\nCelkem rozebírám tyto jednotlivé případy:\n- \"Předání parametru z presenteru\":#toc-predani-parametru-z-presenteru\n- \"Předání parametru z konfiguračního souboru\":#toc-predani-parametru-z-konfiguracniho-souboru\n  - Metodou \"create\"\n  - Metodou \"arguments\"\n- \"All in One\":#toc-all-in-one\n\nPředání parametru z presenteru\n==============================\nToto považuji za asi úplně nejčastější požadavek. Komponenta je jednoduchá:\n\n/--code php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n	public function __construct(array $xxx) {}\n}\n\ninterface IParameterComponentFactory {\n\n	/** @return ParameterComponent */\n	function create(array $xxx);\n\n}\n\\--\n\nDůležité je, že jak datový typ, tak název proměnné se musí shodovat. Config pak není o nic složitější:\n\n/--code neon\nservices:\n	- IParameterComponentFactory\n\\--\n\nKontejner se potom vygeneruje dle očekávání:\n\n/--code php\nfinal class Container_59ca411ae5_IParameterComponentFactoryImpl_28_IParameterComponentFactory implements IParameterComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create(array $xxx) {\n		$service = new ParameterComponent($xxx);\n		return $service;\n	}\n\n}\n\\--\n\nSamotné použití je velmi jednoduché. Stačí si nechat v presenteru předat interface `IParameterComponentFactory` například pomocí anotace `@inject` a nad ním volat metodu `create`. Fígl je právě v tom, že vygenerovaný kód v kontejneru tento interface implementuje a odvádí tak zbytečnou práci za vás. Bez dalších změn lze využít autowire zaregistrovaných služeb. Předání parametru z configu a zároveň získání další závislosti pak může vypadat třeba takto (pouze upravená předchozí komponenta):\n\n/--code php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n	public function __construct(array $xxx, App\\Model\\UserManager $userManager) {}\n}\n\\--\n\nPředání parametru z konfiguračního souboru\n==========================================\nToto je trošku horší, ale pořád snadno pochopitelné. Kód komponenty bude opět podobný:\n\n/--code php\n<?php\n\nclass ConfigComponent extends Nette\\Application\\UI\\Control {\n	public function __construct($configParam) {}\n}\n\ninterface IConfigComponentFactory {\n	function create();\n}\n\\--\n\nVšimněte si, že je v tomto případě úplně zbytečná `@return` anotace. Co má factory vytvářet lze totiž specifikovat v configu:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n\nservices:\n	- implement: IConfigComponentFactory\n	  create: ConfigComponent(%testkey1%)\n\\--\n\nZde by skoro šlo přestat interface úplně psát. To ale není v současné době možné a vygenerovaný kód je pak přesně takový, jaký by měl být:\n\n/--code php\nfinal class Container_59ca411ae5_IConfigComponentFactoryImpl_33 implements IConfigComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new ConfigComponent(\'testvalue1\');\n		return $service;\n	}\n\n}\n\\--\n\nAlternativně lze zvolit populárnější způsob a upravit konfigurační soubor takto:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n\nservices:\n	- implement: IConfigComponentFactory\n	  arguments: [%testkey1%]\n\\--\n\nVygenerovaný výsledek je stejný. V tomto případě je však nutné dát pozor na to, že při psaní interface je nutné psát jej i s `@return` anotací.\n\nOk, toto je snad jasné. Co to trošku zkomplikovat?\n\nAll in One\n==========\nToto snad bude dostatečně krajní případ. Pokusíme se vytvořit továrničku pro komponentu, která bude ke svému vytvoření vyžadovat parametr z configu, parametr z presenteru, službu a opět parametr z configu - vše přesně v tomto pořadí. A nebudu se v tom snažit hledat závislosti. Je vyžadováno něco takového:\n\n/--code php\n<?php\n\nclass AllInComponent extends Nette\\Application\\UI\\Control {\n\n	public function __construct($configParam1, array $userParam, App\\Model\\UserManager $userManager, $configParam2) {}\n\n}\n\ninterface IAllInComponentFactory {\n\n	/** @return AllInComponent */\n	function create(array $userParam);\n\n}\n\\--\n\nJe tedy jasné, že musím vytvořit `create` metodu s parametrem, který naplním v presenteru. Zde by opět `@return` anotace nemusela být. Je úplně zbytečná. A jak na ty parametry z configu? To už je přece vyřešené viz dřívější ukázky:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n	testkey2: testvalue2\n\nservices:\n	- implement: IAllInComponentFactory\n	  create: AllInComponent(configParam2: %testkey2%, configParam1: %testkey1%)\n\\--\n\nZde jsem si to ještě zkomplikoval tím, že jsem zadal parametry v obráceném pořadí (což by přesně takto fungovalo). Abych docílil správného pořadí, musím parametry správně pojmenovat (shodně s konstruktorem komponenty). A vygenerovaný kód? Radost pohledět:\n\n/--code php\nfinal class Container_59ca411ae5_IAllInComponentFactoryImpl_32 implements IAllInComponentFactory {\n\n	private $container;\n\n	public function __construct(Container_59ca411ae5 $container) {\n		$this->container = $container;\n	}\n\n	public function create(array $userParam) {\n		$service = new AllInComponent(\'testvalue1\', $userParam, $this->container->getService(\'27_App_Model_UserManager\'), \'testvalue2\');\n		return $service;\n	}\n\n}\n\\--\n\nI v tomto případě je možné zvolit jiný (úspornější) zápis v konfiguračním souboru. Vygenerovaný výstup je opět stejný:\n\n/--code neon\nparameters:\n	testkey1: testvalue1\n	testkey2: testvalue2\n\nservices:\n	- implement: IAllInComponentFactory\n	  arguments: [configParam2: %testkey2%, configParam1: %testkey1%]\n\\--\n\nTeď mě nenapadá, jestli je někdy (běžně) potřeba ještě něco složitějšího. Toto jsou však dva základní přístupy zkombinované do jedné ukázky. Podívejte se na všechny tyto \"příklady podrobněji na GitHubu\":https://github.com/mrtnzlml/generated-factories.',	'2015-03-24 22:15:22',	0,	'2015-03-24 22:15:22',	0),
(94,	'Barák budoucnosti',	'barak-budoucnosti',	'Aneb jak jsem poprvé a naposledy přešlápl. Je to jednoduché, nebudeme si nic nalhávat. Ještě jsem nepochopil smysl Barcampu. A tak se stalo, že jsem si připravil povídání o něčem, co nikdo moc nechápal. Jistě že mě to trošku mrzí, zároveň mi však přijde absurdní, že někdo přijde na přednášku, kde jsem upozorňoval v anotaci na použité technologie, které budou ve vyprávění zahrnuty a pak jsem slyšel, že někdo vůbec nevěděl o čem je řeč. To je ale kapitola sama pro sebe... (-:\n\nPoučím se a děkuji za feedback. Bylo to tak půl na půl. Půl lidí mi opakovala vlastně jednu a tu samou věc. Že to bylo moc složité. Že bylo potřeba znát hodně věcí okolo, aby se mohl člověk chytat. To je jeden z důvodů, proč už si nikdy nevezmu takovou přednášku na akci jako je Barcamp. Spektrum posluchačů totiž bylo extrémní. Od lidí úplně mimo mísu až po lidi, kteří této problematice perfektně rozumí (lépe než já). Proto jsem rád i za druhou polovinu feedbacku. Potkal jsem se totiž zhruba se stejným počtem lidí, ale s obráceným postojem, takže jsem měl prostor některé věci ještě dovysvětlit a vyjasnit. Bylo fakt super, když mě někdo zastavil na chodbě a chtěl vědět jak je technicky možné pořešit některé věci o kterých jsem mluvil, nebo si chtěl povídat o tom, jak jsou ty koncentrátory vlastně implementované a jak to funguje podrobněji, **že se mu to líbí!**\n\nZjednodušeně - nejsem spokojený se svým výstupem, ale jsem rád, že jsem mohl potkat několik inspirativních lidí a dobře si popovídat. Díky. Nebudu to zde více rozpatlávat. Podívejte se na prezentaci... (-:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/46412746\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nPřikládám ještě odkazy na zmiňovaný \"referenční manuál\":http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf od mikrokontrolérů a dokument pojednávající o myšlence Fog Computingu: \"Fog Computing and Its Role in the Internet of Things\":http://conferences.sigcomm.org/sigcomm/2012/paper/mcc/p13.pdf.\n\nA co ostatní přednášky?\n=======================\nNo tak všechny skvělé. Já si vážím toho, když někdo vystoupí a ukáže co dělá a je z toho nadšený. Některé přednášky jsem tedy jen proseděl a nic nového jsem se moc nedozvěděl (a to právě nevím, jestli mám od Barcampů čekat). Ne všechny přednášky pro mě mají takovou informační hodnotu. Ale lidem se to líbí, takže za mě dobré.\n\nSoučástí Barcampu byl i \"Arduino Day 2015\":https://day.arduino.cc/#/. Tam jsem byl pouze na přednášce o Superkondenzátorech. Kamarád z toho byl úplně nadšený. Pokud vás zajímá elektronika a nejlépe ještě rádi bastlíte, tak doporučuji vyhledat si záznam. Já osobně považuji za nejlepší přednášky \"8 a půl roku přednášení pro Microsoft\":https://plzenskybarcamp.cz/2015/prednasky/5cd9cd30 a \"Od zadání k release za dva dny: jak se programuje v novinách\":https://plzenskybarcamp.cz/2015/prednasky/8eba3b56 aneb jak se hledá balanc mezi náprasem a perfektním kódem... (-:\n\nA když opomenu přednášky? No tak Afterparty byla super. I zde jsem měl příležitost prohodit pár zajímavých rozhovorů. Nakonec se to trošku protáhlo a do postele jsem ulehal až v 6 ráno. Ale s hezkým pocitem, že nedělám úplné hovadiny, jen se musím naučit své myšlenky lidem lépe prodat...',	'2015-03-29 14:15:21',	0,	'2015-03-29 14:15:21',	0),
(95,	'Doctrine pro non-doctrine programátory',	'doctrine-pro-non-doctrine-programatory',	'A také o tom proč jsem se ptal kdo studoval, studuje, nebo bude studovat elektrotechnickou fakultu a proč jsem si až pak uvědomil, že jsem se vlastně zeptal úplně blbě.\n\nAle napřed k samotné přednášce. Nemá smysl zde psát dlouhosáhlé slohy o tom co jsem říkal, počkejte si na video. Pár slov si však neodpustím. Myslím si, že jsem málo zdůraznil to, aby si každý koho to alespoň trošku zajímá Doctrine vyzkoušel. Ale ne jen tak si něco uložit a přečíst z databáze. Já jsem si například přepsal tento blog. Kompletně. Udělejte něco podobného. Teprve potom se ukáže jaké jsou výhody/nevýhody a hlavně - teprve teď se můžete rozhodnout co vám více sedí, protože už máte vyřešené nějaké konkrétní problémy, ne jen modelové situace. Výměnou za hvězdičku se můžete inspirovat například \"zde\":https://github.com/mrtnzlml/zlml.cz.\n\nA co když si nevíte rady? To nevadí. Stává se to často, proto existuje spoustu míst kde se ptát. Jedno je samozřejmě zde. Existuje však \"Nette fórum\":http://forum.nette.org/cs/ a pak (a to hlavně) \"Kdyby HELP fórum\":https://help.kdyby.org/. Na všech místech vám určitě někdo poradí.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/79L3O5KfQJxyOc\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nJeště než prozradím jak je to s tou FEL, rád bych ještě jednou poděkoval lidem z \"ANT studia\":http://www.antstudio.cz/, protože bez nich bych si PoSobotu nemohl tolik užít a nemohl bych zajít na afterpivo - i když jen nealkoholické. Těší mě to i z toho důvodu, že právě s \"ANT studiem\":http://www.antstudio.cz/ začínám, po vyřešení všech studijních formalit, spolupracovat na zajímavých projektech v Nette... (-:\n\nA teď už konečně k oné nešťastné otázce. Správně měla znít:\n\n> Kdo studoval, studuje, nebo bude studovat nějakou **neprogramátorskou** školu?\n\nBylo totiž krátkozraké omezit se jen na elektro, ale tam to vše vzniklo a už jsem to neřešil dál. Upozornil mě na to až \"@stekycz\":https://twitter.com/stekycz. A proč jsem se na to ptal? Inu nastal čas kdy jsem se potřeboval posunout někam dál a začal jsem obcházet firmy v Plzni. Měl jsem tak příležitost potkat spoustu zajímavých lidí a skutečně si vybrat něco co by mě mohlo bavit. A při tomto kolečku mě zaujal často se opakující rozhovor:\n\n> Takže vy studuje asi FAV, že?\n>\n> Ne, FEL.\n>\n> Aha, to my také...\n\nA bylo to častější, než bych si byl kdy býval pomyslel. Došel jsem pak s kolegou k jednoduchému závěru. Zřejmě všichni kdo programují dobrovolně, tedy všichni které do programování nepřinutí škola, jsou prostě dobří. Mají obrovskou naději na uchycení se. Viděl jsem to i z pozice kdy jsem dělal pohovory s lidma. Je skutečně obrovský rozdíl potkat borce z FAV a programátora z FEL nebo odkudkoliv kde programování zase až tak nefrčí.\n\nA naposledy ještě jednou velké díky \"@chemix_cz\":https://twitter.com/chemix_cz! Odvádíš neuvěřitelnou práci.',	'2015-04-26 12:38:53',	0,	'2015-04-26 12:38:53',	0),
(96,	'Fixněte si databázi',	'fixnete-si-databazi',	'Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?\n\nPrvní přístup\n=============\nNebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:\n\n/--code sql\nREPLACE INTO `options` (`key`, `value`)\nVALUES\n(\'option1\', \'value1\'),\n(\'option2\', \'value2\'),\n(\'option3\', \'value3\');\n\\--\n\nTo jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. //(Jo správně, blog jde nainstalovat na více databází...)// A to je voser.\n\nAle jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).\n\nLepší přístup pomocí fixtures\n=============================\nZnáte \"Doctrine Data Fixtures Extension\":https://github.com/doctrine/data-fixtures? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:\n\n/--code\ncomposer require doctrine/data-fixtures\n\\--\n\nSamozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna \"Kdyby/Console\":https://github.com/Kdyby/Console, která integruje \"command ze Symfony\":http://symfony.com/doc/current/components/console/introduction.html. Už jsem o tom psal něco málo \"dříve\":http://zlml.cz/kdyby-console. A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil \"někdo jiný\":https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php. A trošku si to zjedoduším:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor;\nuse Doctrine\\Common\\DataFixtures\\Loader;\nuse Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger;\nuse Kdyby\\Doctrine\\EntityManager;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass DefaultData extends Command\n{\n\n	/** @var EntityManager @inject */\n	public $em;\n\n	protected function configure()\n	{\n		$this\n			->setName(\'orm:demo-data:load\')\n			->setDescription(\'Load data fixtures to your database.\');\n            //->addOption...\n    }\n    \n    protected function execute(InputInterface $input, OutputInterface $output)\n	{\n		try {\n        	$loader = new Loader();\n			$loader->loadFromDirectory(__DIR__ . \'/../basic\');\n            $fixtures = $loader->getFixtures();\n\n			$purger = new ORMPurger($this->em);\n            \n            $executor = new ORMExecutor($this->em, $purger);\n			$executor->setLogger(function ($message) use ($output) {\n				$output->writeln(sprintf(\'  <comment>></comment> <info>%s</info>\', $message));\n			});\n			$executor->execute($fixtures);\n			return 0; // zero return code means everything is ok\n        } catch (\\Exception $exc) {\n			$output->writeLn(\"<error>{$exc->getMessage()}</error>\");\n			return 1; // non-zero return code means error\n		}\n	}\n}\n\\--\n\nOk, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí `loadFromDirectory`. Jedná o objekty, které implementují interface `FixtureInterface`, nebo možná lépe dědí od abstraktní třídy `AbstractFixture`. Obojí je v `Doctrine\\Common\\DataFixtures` namespace. Objekt obsahující defaultní uživatele může vypadat takto:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse Nette\\Security\\Passwords;\n\nclass UsersFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n	public function load(ObjectManager $manager)\n	{\n		$admin = new \\Users\\User(\'admin@nette.org\');\n		$admin->setPassword(Passwords::hash(\'admin\'));\n		$admin->addRole($this->getReference(\'admin-role\'));\n		$manager->persist($admin);\n\n		$demo = new \\Users\\User(\'demo@nette.org\');\n		$demo->setPassword(Passwords::hash(\'demo\'));\n		$demo->addRole($this->getReference(\'demo-role\'));\n		$manager->persist($demo);\n\n		$manager->flush();\n\n		$this->addReference(\'admin-user\', $admin);\n		$this->addReference(\'demo-user\', $demo);\n	}\n\n}\n\\--\n\nV čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce `addReference` a `getReference`. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:\n\n/--code php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nclass RolesFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n	public function load(ObjectManager $manager)\n	{\n		$user = new \\Users\\Role();\n		$user->setName(\\Users\\Role::DEMO_USER);\n		$manager->persist($user);\n\n		$admin = new \\Users\\Role();\n		$admin->setName(\\Users\\Role::ADMIN);\n		$manager->persist($admin);\n\n		$manager->flush();\n\n		$this->addReference(\'demo-role\', $user);\n		$this->addReference(\'admin-role\', $admin);\n	}\n\n}\n\\--\n\nVidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...\n\nJen pozor na jedno věc. Ohlídejte si \"pořadí těchto objektů\":https://github.com/doctrine/data-fixtures#fixture-ordering. To lze vyřešit implementací rozhraní `OrderedFixtureInterface`, nebo `DependentFixtureInterface`, což je o něco lepší přístup.\n\nA jak toto celé použít? Však už to znáte:\n\n/--code\nλ php index.php\nλ php index.php orm:schema-tool:create\nλ php index.php orm:demo-data:load\n\\--\n\nPrvní příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:\n\n/--code\nλ php index.php orm:demo-data:load --demo\nCareful, database will be purged. Do you want to continue Y/N ? y\n  > purging database\n  > loading RolesFixture\n  > loading UsersFixture\n  > loading ArticlesFixture\n  > loading ProductsFixture\n  ...\n\\--',	'2015-05-21 11:24:01',	0,	'2015-05-21 11:24:01',	0),
(97,	'Vzhůru dolů! A pak zase nahoru...',	'vzhuru-dolu-a-pak-zase-nahoru',	'Na relativně dlouhou dobu jsem se teď odmlčel. Psal jsem totiž někam jinam než na blog a svůj příděl písmenek na měsíc jsem odevzdával právě tam. Ale stálo to za to. Totiž jak se to vezme. Projděme si sled událostí. Událost první. Poprvé jsem \"představil\":http://www.slideshare.net/MartinZlmal/nodejs-42314371 svůj projekt na FAV, kde studenty zaujal a na konci přednášky se kolem samotného projektu utvořil hlouček zvědavců toužící prohlédnout si zařízení lépe. Událost druhá. Představil jsem tento projekt \"širší veřejnosti\":http://www.slideshare.net/MartinZlmal/barcamp2015 na Barcampu v Plzni a získal jsem velkou spoustu negativních reakcí. Samotná zadávající firma se dále přestala o tento projekt více zajímat a musel jsem se s tím chvíli pasovat, abych věděl na čem jsem. Událost třetí. I když mi to chvíli trvalo, tak jsem se vzpamatoval, implementoval jsem ještě několik cool věcí a tento projekt uvedl do finální fáze, kdy bych byl ochoten se s ním pochlubit před odborným publikem. Tak jsem také u SZZ udělal a práci úspěšně obhájil. Událost čtvrtá a poslední. Tato práce \"vyhrála soutěž\":http://www.abb.cz/cawp/seitp202/67b19426a3ab3b8fc1257e6e004f2d33.aspx ABB University Award 2015 - soutěž o nejlepší technicky zaměřenou vysokoškolskou práci v ČR.\n\nProč to vůbec říkám? Abych si trošku zamachroval... (-: Ale také proto, abych s lehkým úšklebkem poděkoval všem lidem, díky kterým jsem se chvíli cítil fakt špatně a díky kterým jsem tu práci po Barcampu přihlásil do soutěže. Chtěl jsem vědět, jestli je to fakt taková sračka a bude to jasná tečka za mým snažením, nebo ta práce (resp. myšlenka) má nějaký smysl. A smysl to mělo. Hodnotil se nápad, zpracování a to jak jsem to ústně přednesl (pravděpodobně). Pokud máte čas, tak si tuto práci můžete přečíst. Budu rád pokud tak (alespoň nějak rychle) učiníte a můžeme si o tom popovídat více.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/q1xdPbSZTIUXQ\" width=\"600\" height=\"750\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nCo celá práce velmi jednoduše řečeno řeší? Jak co nejrychleji dostat data z nějaké elektroniky (koncentrátoru) až do webové aplikace a zpět. K tomu by mělo být (a je) možné změnit zapojení sítě, tzn. jedná se o logickou síť, která není závislá ani na fyzickém zapojení, ani na použitých zařízeních a technologiích. Ve výsledku je to triviální problém, ale ne každý jej dokáže vstřebat, nebo si něco takového vůbec připustit.\n\nCo dál ještě nevím. Uvidím, jestli se to nějaké firmě zalíbí více, než té současné a bude schopna se za to postavit. Pokud ne, tak celý nápad postrádá smysl a vrhnul bych se asi do nějakých myšlenek uvedených ke konci práce, jako je například \"Li-Fi\":https://en.wikipedia.org/wiki/Li-Fi, nebo částečně decentralizovaný přístup sítě. Jedno vím ale jistě. Na Barcamp už s tím ani nepáchnu... :-))',	'2015-06-27 20:10:33',	0,	'2015-06-27 20:10:33',	0),
(98,	'Dynamické routování URL adres',	'dynamicke-routovani-url-adres',	'A když říkám dynamické, tak tím myslím opravdu kompletně. Jinými slovy to znamená, že chceme jakoukoliv cestu za doménou přeložit na jakýkoliv interní požadavek (\"Application\\Request\":http://api.nette.org/2.3.3/Nette.Application.Request.html). Kousek routovací tabulky tedy může vypadat následovně:\n\n/--code\n/						=> 	Front:Homepage:default\n/neco.html				=> 	Front:Page:default\n/neco-jineho-8			=> 	Front:Page:default(id=56)\n/neco/treba/takoveho	=> 	Front:Page:default(id=96)\n/a/b/c/d/e/f 			=> 	Admin:Dashboard:new\n...\n\\--\n\nTím jsem doufám dostatečně přesně nastínil zadání a od toho se odvíjející požadavky na router. V URL může přijít jakákoliv cesta a aplikace ji musí umět správně naroutovat.\n\nJak funguje routování v Nette\n=============================\nPokusím se to vysvětlit trošku jinak než je to vysvětlováno jinde. Většinou se totiž dočtete, jak pracovat s \"třídou Route\":http://api.nette.org/2.3.3/Nette.Application.Routers.Route.html. To je samozřejmě správně, protože takto se routování v Nette aplikacích naprosto běžně dělá. Nicméně pro tento účel mi přijde vhodnější napsat si router vlastní - o něco hloupější, ale pasující na toto zadání lépe. Proto opustíme tuto třídu a budeme se raději zajímat o \"IRouter interface\":http://api.nette.org/2.3.3/Nette.Application.IRouter.html.\n\nTento interface má dvě metody - `match` a `constructUrl`. Metoda `match` má za úkol přeložit HTTP request na již zmíněný \"Application\\Request\":http://api.nette.org/2.3.3/Nette.Application.Request.html. Jedná se tedy o překlad ve směru šipky viz zadání. Podívejte se, jak to řeší třída Route, v tomto konkrétním prípadě však bude potřeba pracovat s databází a napsat si jinou logiku. Oproti tomu metoda `constructUrl` má přesně opačný úkol. Překládá příchozí Application request na (absolutní) URL adresu.\n\n[* 9ab04acb-febc-4901-aaad-5b554f77e529/vystrizek.png 610x? <]\n\nZatímco Route dokáže tyto překlady sestavit pouze z masky routy a namapovat je na interní odkazy v aplikaci, v tomto případě bude nutná databáze. Po chvíli laborování a asi pěti variantách jsem nakonec udělal ústupek a zvolil tu nejjednodušší (ale dostatečnou) variantu viz obrázek. Stačí si tedy uchovávat cestu, interní odkaz a interní ID. To je vše, co by mělo být potřeba.\n\nKonkrétní řešení\n================\nNechci sem dávat celé zdrojáky (jen útržky), protože je tento článek hlavně o teorii. Proto se podívejte na nějakou jinou již hotovou implementaci IRouteru, třeba na \"StaticRouter\":https://github.com/nextras/static-router/blob/master/src/StaticRouter.php. Ostatně s dobrým nápadem je samotná implementace jednoduchá. V `match` si stačí podle cesty vytáhnout interní odkaz třeba nějak takto:\n\n/--code php\n$destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\nif ($destination === NULL) {\n	$this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n	return NULL;\n}\n\\--\n\nSamozřejmě je fajn si tu cestu ještě před dotazem nějak upravit, podle toho jak jí máte v databázi. Já je tam mám třeba bez úvodního lomítka. Tato cesta odkazu směrem do aplikace je velmi jednoduchá, protože pouze na základě cesty v URL si natáhnete vše, co je potřeba a už vlastně jen sestavíme Application request:\n\n/--code php\n$params = $httpRequest->getQuery();\n$params[\'action\'] = $action;\nif ($destination[$internalDestination]) {\n	$params[\'id\'] = $destination[$internalDestination];\n}\nreturn new Application\\Request(\n	$presenter,\n	$httpRequest->getMethod(),\n	$params,\n	$httpRequest->getPost(),\n	$httpRequest->getFiles(),\n	[Application\\Request::SECURED => $httpRequest->isSecured()]\n);\n\\--\n\nNedělá se zde nic zvláštního, prostě postavím request a přibalím do něj cílový presenter (ten jsem si vytáhl z databáze), do parametrů je třeba přidat action a volitelně ještě to interní ID. Stanovil jsem si takovou konvenci, že aplikace bude používat interně pouze ID. Proč? Prvně je to velmi jednoduché a neřeším žádné hovadiny. Nepotřebuji něco jako je slug, protože jsou adresy konstruovány jinak. Takové je zadání. No a potom práce s ID je i z hlediska Doctrine \"velmi přirozené\":http://forum.nette.org/cs/23681-kdyby-doctrine-use-cases-best-practices-a-jak-vam-to-dava-smysl#p159096. Jeden příklad za všechny. Mám aplikaci rozsekanou na komponenty co nejvíce to šlo. Je jich fakt hodně - stránku vlastně jen skládám z komponent. To považuji za skvělý návrh, ale vede k tomu, že se jednolivé komponenty od sebe aplikačně trošku vzdalují. No a když bych chtěl třeba v každé komponentě vytáhnout něco stejného, tak při nevhodném dotazu by Doctrine položila dva stejné dotazy na databázi. Je však možné využít ID a zeptat se jinak. Porovnejte následující dotazy:\n\n/--code php\n$this->em->getRepository(File::class)->findOneBy([\'id\' => 930]);\n$this->em->getRepository(File::class)->find(930);\n\\--\n\nNejsou stejné. Ten druhý můžete použít kolikrát chcete, ale pokud již Doctrine zná odpověď, tak se nezeptá databáze znova. Obdobně (ještě lépe) to funguje s `getPartialReference`. Takže bod pro práci pouze s ID.\n\nJe třeba zajistit i obrácený překlad. Ten mi vždy přijde náročnější a měl jsem vymyšlený fakt pěkný nápad, ale neuměl jsem ho zrealizovat. Ale díky tomu, že se využívá interně jen ID, mohu jej uložit jako třetí sloupec do databáze a je možné jednoduše patřičnou cestu dohledat. Je však třeba uvědomit si, že existují čtyři možné stavy:\n\n1) Odkaz nemá žádné ID, hledáme cestu pouze podle destination (např. Front:Homepage:default - ID je volitelné)\n2) Odkaz má ID, hledáme cestu podle destination a ID\n3) Odkaz sice má ID, ale v databázi takový záznam není, v tom případě použít první bod a parametry pověsit do query odkazu (fallback)\n4) Odkaz se nepodařilo najít ani odhadnout v dalších bodech, routa vrací NULL\n\nProč vrací v posledním bodě routa NULL? Určitě víte, že při definování klasického routeru záleží na pořadí rout. Je to právě kvůli tomuto. Když první routa nedokáže příchozí požadavek sestavit, vrací NULL a na řadě je další routa, která se o to pokusí. Požadavek propadne dále. Tak to jde až do okamžiku, kdy už není žádná jiná možnost a to je chybový stav (404). Vzhledem k tomu, že používám pouze tento vlastní router, tak NULL je ekvivalent právě k chybě 404. Ale napsal jsem si to tak, aby routa byla hodně žravá a pokusila se za každou cenu nějaký odkaz postavit. Třetí bod je navíc stav, který se loguje.\n\nJeště je důležitá poslední věc. Jak jsem psal dříve, tak se v `match` metodě přidává do Application requestu action a volitelně ID. V metodě `constructUrl` je potřeba zvolit opačný přístup a zase je zrušit. Nedostanou se tak do URL. V tom je celé kouzlo takto volně definovaných adres. Na vstupu přidám nějaké informace navíc (action, ID), s nima aplikace pracuje a na výstupu je zase z adresy odstraním.\n\nBez cache ani ránu\n==================\nZatím je to docela fajn. By default mám v databázi nějaké základní odkazy a například při ukládání článku vytvořím odkazy nové, které se pak naroutují. Výhoda je jednak v tom, že mohu mít úplně libovolné adresy. Mohu je ale také různě upravovat podle nastavení a pak co je asi nejdůležitější, adresy jsou unikátní a když ji u článku změním, mohu starou (automaticky) přesměrovat na novou. Po tomto musí SEO odborníci čvachtat blahem... :)\n\nProblém je však v tom, že je to spousta práce a bez nějaké alespoň jednoduché cache by to bylo moc komplikované, skoro až nepoužitelné. Řešení je však jednoduché. Prostě cache použijeme:\n\n/--code php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n	$destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\n	if ($destination === NULL) {\n		$this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n		return NULL;\n	}\n	return [$destination->destination => $destination->internalId];\n});\nif ($destination === NULL) {\n	return NULL;\n}\n\\--\n\nJe to vlastně stejný kód jako v první ukázce, ale výsledek si uloží do cache a příště už ví jaký odkaz použít. Trošku nevýhoda je, že to vygeneruje cache soubůrek pro každý individuální odkaz. Myslím si však, že je to správně, protože skutečně každý odkaz může být úplně jiný. Takže jsem si alespoň pro dobrý pocit vyrobil ještě upravený \"FileStorage\":http://api.nette.org/2.3.3/Nette.Caching.Storages.FileStorage.html, který cache zanořuje ještě o úroveň níže podle prvních dvou znaků (resp. podle druhého a třetího). No a celá ta sranda se chová tak, že při načtení stránky vyřeší ty dotazy, které je potřeba vyřešit a při dalším načtení již nic nedělá, pouze je přečte z cache. Při průchodu stránkou pouze dochází k řešení dalších - ještě nevyřešených odkazů. Pak to se postupně vyřeší všechny a už se na to nikdy nebude sahat (není to moc žádoucí).\n\nPár důležitých poznámek\n=======================\nVzhledem k tomu, že v tomto konkrétním případě chci používat pouze tuto routu, tak je možné všechny ostatní úplně vyhodit pryč. Fakticky stačí z rozšíření vyhodit definici původní nativní routy:\n\n/--code php\n$containerBuilder->removeDefinition(\'routing.router\');\n\\--\n\nUdělal jsem to teď, takže to ještě nemám pořádně vyzkoušené a doufám, že jsem tím nic nerozbil. Ale neměl bych. Po zaregistrování této vlastní routy v configu vše začne krásně fungovat. Stačí, že implementuje IRouter a tato implementace je jediná v celém projektu (což je po této úpravě pravda).\n\nNo a na závěr ještě úvaha, kterou jsem sice ještě neimplementoval, ale asi bych to tak rád udělal. Jedná se o jazykové mutace. Jednak je mohu ovlivňovat přidáním nějakého `/en/` do cesty (což se tento router jednoduše naučí), ale pak může přijít složitější požadavek. Máme dvě domény směřující na jednu aplikaci a každá doména představuje jinou jazykovou mutaci. To je docela naprd, ale vzhledem k tomu, že do `match` metody v argumentu vstupuje HTTP request, mohu tuto jazykovou mutaci nastavit pouze na základě adresy zase velmi jednoduše. Jediná modifikace bude v tom, že začnu v Application requestu posílat i locale proměnnou pro translátor.\n\nPoslední nejdůležitější upozornění\n==================================\nMožná si již někdo všiml, že jsem změnil doménu. Nová doména je `zlml.cz`. Vzhledem k tomu, že původní byla pouze dočasná (i když na několik let) a nepodařilo se mi získat tu co jsem moc chtěl, zvolil jsem tuto. Jak si jí snadno zapamatovat? Je to jednoduché. Prostě moje příjmení bez samohlásek. Původní doména je přesměrována 1:1 a ještě ji budu docela dlouhou dobu držet. Ale až uvidím, že to nemá takový smysl, tak bych jí třeba za pár let zrušil. Pokud tedy chcete mít jistotu, že se k vám vždy nové články dostanou, změňte si prosím ve svých RSS čtečkách adresu na \"http://zlml.cz/rss\":http://zlml.cz/rss.\n',	'2015-07-05 14:21:48',	0,	'2015-07-05 14:21:48',	0),
(99,	'Hierarchický router',	'hierarchicky-router',	'Tento článek volně navazuje na \"předchozí\":http://zlml.cz/dynamicke-routovani-url-adres. Zde jsem ukázal, jak vytvořit routy tak, aby bylo možné mít zcela libovolnou adresu a routovat ji na jakoukoliv akci v aplikaci. Dnes to trošku vylepšíme. Přidáme totiž další dva požadavky s tím, že první je ten důležitější:\n\n1) Když se změní adresa (například článku), musí se stará přesměrovat na novou. To se může dít opakovaně a nechceme mít mnohonásobný redirect. Redirect může být maximálně jeden a to pro jakoukoliv starou (i původní) adresu.\n2) Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nDruhý požadavek je vlastně jen speciální (zjednodušený) případ toho prvního. Co to znamená? Podívejte se na následující ASCII art. Obsahuje pět obrázků znázorňujících postupné změny přesměrování při přidávání dalších přesměrování. Nebudeme již řešit routování na akce v presenterech, ale práci se samotným URL a jak se bude chovat, když se přesměruje aktuální cílové URL jinam.\n\n/--code\nURL-1\n\n\nURL-1 ----> URL-2\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-4 <---- URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-5 <---- URL-3\n             ^\n             \'----------URL-4\n\\--\n\nSlovy řečeno, nesmí se **nikdy** stát, aby byla cesta od staré adresy k nové delší, než je jeden skok. Je zřejmé, že původně byla pouze URL-1. Ta byla přesměrována na URL-2. V okamžik, kdy se přesměruje URL-2 na URL-3, původní propojení mezi URL-1 a URL-2 se musí úplně zrušit a naměrovat URL-1 až na URL-3. A tak to pokračuje dále. Z toho je zřejmé, že nazývat tento router hierarchickým je poněkud zavádějící, protože ve skutečnosti se udržuje takový obrácený les. S troškou režie na začátku je to však vhodnější, protože se tím hezky mění průběžně struktura redirectů a je to lepší, než například takto, to je asi všem jasné:\n\n/--code\nURL-1\n \'--> URL-2\n       \'--> URL-3\n             \'--> URL-4\n                   \'--> URL-5\n\\--\n\nPřepočet odkazů\n===============\nV tom to vlastně celé vězí. Je nutné při vytváření redirectu najít všechny staré odkazy a změnit je na nové. Vrátíme se však k předchozímu článku a trošku vylepšíme cache. Tedy cache zůstane stejná, ale vylepšíme její invalidaci následovně:\n\n/--code php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n    $destination = $this->em->getRepository(Url::class)->findOneBy([\'fakePath\' => $path]);\n    if ($destination === NULL) {\n        $this->monolog->addError(sprintf(\'Cannot find route for path %s\', $path));\n        return NULL;\n    }\n    $dependencies = [Nette\\Caching\\Cache::TAGS => [\'route/\' . $destination->getId()]];\n    return $destination;\n});\n\\--\n\nPřidáme ke každému uložení cache tzv. tag, díky čemuž bude možné později tuto cache snadno najít a zrušit její platnost. V closure je nutné dělat to takto přes dependencies proměnnou. Jsou samozřejmě i jiné možnosti \"jak cache zneplatnit\":http://doc.nette.org/cs/2.3/caching#toc-expirace-a-invalidace, ale tento způsob považuji za dostatečný. Hodí se to proto, že až budeme upravovat staré odkazy, tak je (a pouze je) smažeme z cache, čímž zapříčiníme jejich opětovné vytvoření, tentokrát však s jiným přesměrováním.\n\nDo entity URL adresy je třeba přidat další vlastnost - odkaz na sebe.\n\n/--code php\n/**\n * @ORM\\ManyToOne(targetEntity=\"Url\", cascade={\"persist\"})\n * @ORM\\JoinColumn(referencedColumnName=\"id\", onDelete=\"SET NULL\")\n * @var Url\n */\nprotected $redirectTo = NULL;\n\\--\n\nTento odkaz využijeme v routeru, který v případě existence tohoto odkazu bude pracovat právě s ním. V opačném případě router pracuje normálně viz předchozí článek. To už tu nebudu řešit. Spíše se podíváme na samotnou tvorbu redirectů. Tu mám umístěnou v `@RedirectFacade::createRedirect`. Tato metoda přijímá dvě čísla (ID) a to odkud se přesměrovává a kam se přesměrovává. Bohužel není možné předat si parciální entitu, protože není možné ji naplnit a odeslat do databáze (vlastnost Doctrine). No a předávat celé entity je zbytečné. Proto jen ID. Zjednodušeně vypadá tato metoda takto:\n\n/--code php\npublic function createRedirect($from, $to)\n{\n    $this->em->transactional(function () use ($from, $to) {\n        /** @var Url $oldLink */\n        foreach ($this->em->getRepository(Url::class)->findBy([\n            \'redirectTo\' => $from\n        ]) as $oldLink) {\n            $oldLink->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n            $this->cache->clean([Nette\\Caching\\Cache::TAGS => [\'route/\' . $oldLink->getId()]]);\n        }\n\n        /** @var Url $from */\n        $from = $this->em->find(Url::class, $from);\n        $from->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n        $this->em->flush();\n        $this->cache->clean([Nette\\Caching\\Cache::TAGS => [\'route/\' . $from->getId()]]);\n    });\n}\n\\--\n\nDalo by se to optimalizovat z hlediska databázových dotazů lépe, ale jednak to není (zatím nebylo) potřeba a pak se hodí tahat si jednotlivé záznamy postupně právě kvůli invalidace cache. Jak to funguje? V první části si vytáhnu všechny odkazy, které ukazují na odkaz ze kterého budu přesměrovávat. To jsou ty staré, které je třeba zrušit. Ty jsou nahrazeny odkazy na nové stránky a jejich cache je samozřejmě smazána. To je ta důležitější část. V druhé polovině dojde jen k uložení nového přesměrování a opět smazání cache pro tento odkaz. Za povšimnutí stojí funkce `getPartialReference` o které jsem psal už minule. Je to funkce, která nevrací celou entitu, ale pouze nenaplněnou entitu s ID (parciální). Nic víc totiž dost často není potřeba...\n\nDruhá část řešení\n=================\nDruhá část řešení je již jednoduchá.\n\n> Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nStačí entitě povolit, aby mohlo být NULL `destination` (tedy interní odkaz na presenter a akci) a `internalId`. To jsou totiž informace, které nejsou známé a pro tetno účel jsou i zbytečné. Důležitá je totiž jen cesta a odkaz na cílovou URL. A to je vlastně vše, protože vše ostatní už přirozeně umí dříve napsaný router.\n\nJeště jsem nedávno narazil na zajímavý router, který umožňoval smazat jakoukoliv část cesty a on si jí domyslel a přesměroval. Nekoukal jsem úplně do střev, ale asi tak, že vyhledá přesně znění cesty a když ji nemůže najít, tak položí nějaký LIKE% dotaz ve snaze alespoň ji odhadnout. To už ale považuji za zbytečné a nevyužitelné. Osobně se mi ještě více líbí routy, které jsou na ČSFD. Obsahují totiž přirozený zkracovač adres viz tyto dvě adresy, které jsou stejné:\n\n/--code\nhttp://www.csfd.cz/film/5911\nhttp://www.csfd.cz/film/5911-tenkrat-na-zapade/\n\\--\n\nVyzkoušejte \"si\":http://www.csfd.cz/film/5911 \"to\":http://www.csfd.cz/film/5911-tenkrat-na-zapade/. První přesměruje na druhou. Bohužel ne všem se čísla v adresách líbí (i když podle mého názoru bezdpůvodně).\n\nAčkoliv budu na routeru dále pracovat, tak k němu zatím nemám v plánu další komentáře. Pokud tedy něco není jasné, teď je ta správná chvíle zeptat se. Jo mimochodem. Předchozí router už není obyčejnou implementací `\\Nette\\Application\\IRouter`, ale dědí od `\\Nette\\Application\\Routers\\RouteList`. Je to z toho důvodu, že se bez toho Kdyby\\Console \"nerozjede\":https://github.com/Kdyby/Console/blob/master/src/Kdyby/Console/CliRouter.php#L124. Pokud bych tedy nepoužíval tuto knihovnu, tak by to nebyl problém. Samotná quick\'n\'dirty úprava spočívá v přidání tohoto kódu na začátek match metody:\n\n/--code php\n/** @var Application\\IRouter $route */\nforeach ($this as $route) {\n    /** @var Application\\Request $applicationRequest */\n    $applicationRequest = $route->match($httpRequest);\n    if ($applicationRequest !== NULL) {\n        return $applicationRequest;\n    }\n}\n\\--\n\nA to je vše...',	'2015-07-11 14:38:21',	0,	'2015-07-11 14:38:21',	0),
(100,	'Návrhový vzor Legacy code',	'navrhovy-vzor-legacy-code',	'Asi každý se k tomuto návrovému vzoru jednou dostane. Zatím jsem vždy takovou práci striktně odmítal, ale tentokrát šlo o jinou situaci a svolil jsem k poklesu od OOP frameworku ke špagetě. Ačkoliv má pojem \"legacy code\" celou řadu definic, já osobně jej chápu jako kód, který je prostě starý. Vhodnější by však bylo asi říci, že se jedná o kód se kterým teď musím pracovat, ale nenapsal jsem ho. Zůstaňme však u první definice. Zde platí, že (stejně tak jako jakýkoliv jiný navrhový vzor) obsahuje celou řadu opakujících se poznávacích prvků.\n\nNapříklad mezi vývojáři panuje pozoruhodná pasivita. Nikdo se nepostaví na zadní a nepřijde s něčím novým. Nemyslím novou fičuru, ale nějakou systémovou věc. Na druhou stranu se to dá pochopit. Je to ta nejdražší změna a zase až tak ničemu to z vnějšího pohledu neprospěje. Nepovažuji to za správný přístup, ale taková je asi realita. Bohužel se pak často argumentuje (totální) zpětnou kompatibilitou. Dále tento návrhový vzor předpokládá, že se používá nějaký vypíčený verzovací systém a nikoho to netrápí (viz pozoruhodná pasivita vývojářů). O coding standardu ani nemluvě a globální prostor je samozřejmostí. No a pak samozřejmě klasické věci jako RY přístup (opak \"DRY\":https://cs.wikipedia.org/wiki/Don%27t_repeat_yourself - Don\'t Repeat Yourself), šablonovací systém (pokud vůbec existuje) je stejně debilní jako ten verzovací a v neposlední řadě neotestovaný/neotestovatelný kód.\n\nV mém konkrétním případě jsem se musel potýkat ještě s něčím. Jednak jsem se musel poprat s opačným smýšlením vývojářů. Takže například zatímco všude se direktiva `magic_quotes_gpc` \"vypínala\":http://php.vrana.cz/vypnuti-magic_quotes_gpc.php, zde se globálně zapínala atd. No a pak samotný globální prostor to je písnička sama pro sebe. Myslel jsem si, že to až takový problém nebude, ale neuvědomoval jsem si, co to vlastně obnáší. Pokud stejně jako já nikdy globální proměnné nepoužíváte, zde je příklad na připomenutí.\n\nJakákoliv globální proměnná, která není nijak dále zabalená je automaticky globální:\n\n/--code php\n$x = \'y\';\ndump($GLOBALS[\'x\']); //y\n\\--\n\nTo dává smysl a není na tom nic divného. Za mnohem větší problém však považuji fakt, že to funguje i obráceně:\n\n/--code php\n$GLOBALS[\'x\'] = \'y\';\ndump($x); //y\n\\--\n\nProč je to problém? Protože druhý případ je striktně závislý na použitém kontextu. Tím pádem tato pseudoglobální proměnná funguje ve špagetě, ale když chcete takový kód jinak uspořádat a nedej bože ještě obalit, tak je to problém. Vzhledem k tomu, že bylo mým úkolem integrovat \"Nette Framework\":https://nette.org/ do takového systému, musel jsem trošku upravit start aplikace a tím jsem hodně věcí rozbil.\n\n[* d6ca5ea3-5c1a-43af-8488-73d4fae836f1/strip-wordpress-550-finalenglish.jpg <]\n\nJak jsem na to šel\n==================\nNebudu zde rozebírat přesně důvody proč jsem to udělal tak a ne jinak. Většinou mě to k tomu řešení jasně dovedlo, protože dělat to jinak by bylo nesmyslně složité - pokud vůbec možné. Berte to jako inspiraci. Myslím si, že se to bude ještě nekomu hodit, protože je tento návrhový vzor rozšířen více, než si přiznávám.\n\nV první řadě bylo nutné do projektu přidávat závislosti pomocí Composeru. Jednak se tak projekt trošku vyčistil od zbytečně nakopírovaných knihoven a potom jsem mohl s výhodou používat jednotlivé Nette komponenty. Pak je velmi důležité celý projekt poznat trochu hlouběji. Na to není vždy čas. Začal jsem proto tak, že jsem napojil na systém jednodušší části frameworku jako je třeba Tracy, Cache, Utils, RobotLoader atd. S tím se samozřejmě svezlo několik úprav, jako je například zapnutí error reportingu nebo vypnutí zahazování výjimek a další podobné hovadiny. Samotné zapnutí error reportingu je neskutečný oser, protože se tím ukáže, jak se daná aplikace hrozně sype (\"však jsou to jen notices\":https://media.giphy.com/media/11c2hRHwmvgFOg/giphy.gif, co se může stát). Každopádně už třeba použitím cache na správných místech a úpravou několik funkcí se aplikace rozjela daleko rychleji.\n\nDalší čeho bych se rád zbavil jsou `mysql_*` funkce a nahradil je PDO. To není úplně jednoduchý úkol a pořád je to \"in progress\". Zde jsem zvolil NDB, ale nejsem si tou volbou vůbec jistý. No a pak nastal čas, kdy je třeba přistoupit k hlubší integraci frameworku. To jsem chtěl udělat jako štít před celou aplikací. Tím jsem samozřejmě polovinu věcí rozbil, ale naštěstí už to tak nějak funguje. Co to vlastně znamená? V první řadě například startování aplikace z jednoho místa (což nebylo normální a rozbilo to všechno) a potom napsání LegacyPresenteru, který se stará o zpětnou kompatibilitu se starým jádrem (což zase rozbilo pseudoglobální kontext). No a potom bylo potřeba vyřešit také routování. To však ve výsledku bylo velmi triviální a stačilo napsat několik základních pravidel, za která se schová jakákoliv URL v systému. Jednoduchá implementace takového presenteru může vypadat třeba takto:\n\n/--code php\n//dodatečná nastavení ve startup()\n\npublic function renderDefault($fakePath = NULL)\n{\n    if (NULL !== $fakePath) {\n        if (file_exists($file = SITE_ROOT . DS . $fakePath)) {\n            require $file; //bacha na Local File Inclusion\n        }\n    }\n}\n\\--\n\nTato implementace vlastně kopíruje původní chování. Napsání routovacích pravidel je fakt jednoduché:\n\n/--code php\n$router[] = new Route(\'<? index(\\.html?|\\.php)>\', \'Legacy:default\', Route::ONE_WAY);\n$router[] = new Route(\'[<fakePath .+>]\', \'Legacy:default\');\n\\--\n\nMnohem zajímavější je však implementace Smarty šablonovacího systému. K tomu je vhodné napsat si vlastní implementaci render metody objektu \"Template\":https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.Template.php.html. Zde se rozhodne, jak se bude šablona vykreslovat. V mém případě jestli pomocí Latte, nebo Smarty. Je samozřejmě nutné upravit i TemplateFactory hlavně kvůli \"této řádce\":https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.TemplateFactory.php.html#56.\n\nŠpatné pořadí\n=============\nVšechno špatně. Teď vím, že jsem měl začít obráceně a nejdříve si na to napsat testy. Alespoň dodatečně (klasicky po prvním problému) jsem si na to ještě napsal jednoduché scénáře pro akceptační testy v Codeception. A pak jsem si měl stát za svým a neústupně odstranit všechny weird věci, protože ty prostě nejsou kompatibilní s moderním frameworkem a způsobuje to jen nepředvídatelné problémy.\n\nJsou vlastně nějaké výhody takové integrace frameworku do starého systému? Vyjma těch klasických, které přináší framework sám o sobě, je teď možné psát nové věci Nette stylem a využívat všechny možnosti (hlavně asi DIC a Latte). Se starým kódem se kromě vyčištění od hovadin vlastně zase až tak dít nic nebude a je možné jej přepisovat do nového kabátku. Osobně bych nejraději odstranil globální proměnné úplně, to je ale na tak velkém projektu skoro nemožné.\n\nNo a pak je zde psychická stránka věci. Jak se budou tvářit ostatní vývojáři až zjistí, že framework nemá jen pomáhat, ale i omezovat, aby programátor nedělal píčoviny? Najednou je programování náročnější. Spousta objektů, žádný `$GLOBALS`, dependency injection... Skvělé však je, že má takovýto úkol i svá nesporná pozitiva. Jedině zde budete pracovat s frameworkem skutečně po částech a tím spíš se nechají jednotlivé části poznat.\n\nMáte také nějaké zkušenosti s legacy projektem?',	'2015-08-30 15:16:00',	0,	'2015-08-30 15:16:00',	0),
(101,	'Crazy JavaScript PDF generator',	'crazy-javascript-pdf-generator',	'Kdysi mi někdo řekl, že správný programátor by měl být tak trošku děvka pro všechno. Nestačí jen umět PHP. Nestačí jen umět JavaScript. S tímto názorem jsem od samého začátku souhlasil. Ostatně je to jeden z důvodů, proč se občas zajímám i o věci, které v nejbližší době nevyužiju a zase tolik jim nerozumím (také to podle toho pak vypadá). Jednou z takových věcí je \"React\":http://facebook.github.io/react/index.html. Nedávno jsem si hrál také s \"PhantomJS\":http://phantomjs.org/ a když už jsme u toho, tak ani \"NodeJS mi není cizí\":http://www.slideshare.net/MartinZlmal/nodejs-42314371. A co se stane, když se jednoho večera rozhodnete spojit všechno dohromady? Něco šíleného... (-:\n\nKrátké seznámení\n================\nVzhledem k tomu, že tento blog byl vždy zacílen spíše na začátečníky, bylo by vhodné jednotlivé projekty krátce přiblížit.\n\n\"React\":http://facebook.github.io/react/index.html vytvořený Facebookem se sám prezentuje jako knihovna pro stavění uživatelských rozhraní. V sekci \"Why React?\":http://facebook.github.io/react/docs/why-react.html se lze však dočíst zajímavější skorodefinici: *\"Many people choose to think of React as the **V** in MVC.\"* Celá myšlenka Reactu je postavená na komponentách. A já mám \"komponenty rád\":https://doc.nette.org/cs/components. Myslím si, že je to dobrý směr jak udržet v aplikaci chaos na rozumné úrovni. Než abych to zde však dlouhosáhle popisoval, doporučuji pojet si \"Getting Started\":http://facebook.github.io/react/docs/getting-started.html.\n\n\"PhantomJS\":http://phantomjs.org/ je oproti tomu úplně něco jiného. Jedná se o tzv. \"headless browser\" - velmi volně přeloženo prohlížeč bez grafického rozhraní. Je to takové Safari bez Safari. Prohlížeč, kterému úplně chybí (jinak pomalá) renderovací vrstva. Nejedná se tedy o prohlížeč, který by chtěl kdokoliv používat, ale spíše o nástroj, kterým lze skutečný prohlížeč nahradit třeba na serveru. Primárně se tedy používá pro testování aplikací, ve fantazii se však meze nekladou. Je tak možné např. tvořit screeny webů, nebo spouštět plně JavaScriptové stránky a koukat se na jejich obsah. Já jej začal používat kvůli rychlosti (oproti Seleniu), v tomto konkrétním případě však slouží právě pro spuštění čistě JavaScriptové stránky.\n\nNo a konečně \"NodeJS\":https://nodejs.org/en/ - JavaScriptové prostředí pro server. Zatímco ostatní jej využívají pro tvorbu aplikací, které jsou napsány v JS prakticky kompletně (server,  klient), já jej využíval kvůli svým vlastnostem spíše na rychlou komunikaci elektronika - server. To se mi na JS líbí. Dnes se nechají napsat i velmi složité věci pomocí pár řádek, ale třeba práce s časem a datumem bude vždy oser... (-:\n\nNěco šíleného\n=============\n[* e80e305e-8431-4c0e-9c79-5db761c22608/199aff3.jpg 300x? >]\n\nTo je tak když se sejde několik věcí najednou. Vytvořit si faktury, otestovat aplikaci, neustálý přirozený hlad po NodeJS. A pak to přišlo. Co si tak vytvořit \"generátor faktur\":https://github.com/mrtnzlml/js-invoice-generator, který bude samotnou fakturu stavět pomocí Reactu, server bude tvořit NodeJS a PDF budu generovat tak, že si tu stránku otevřu v PhantomJS a uložím (čímž snad získám velmi přesný výsledek)? Samozřejmě jsem se pokukoval i po již hotových řešeních jako je třeba \"Fakturiod\":https://www.fakturoid.cz/. A kdybych byl jen o kousek línější, tak bych asi nic takového netvořil. Nakonec jsem se však pouze inspiroval \"peckovým designem jedné z jejich faktur\":https://www.fakturoid.cz/blog/2015/08/25/nova-verejna-stranka-faktury (protože k designu mám asi tak daleko jako k Praze z Azor) s tím, že jí komplet napíšu znova pomocí komponent v Reactu a budu se modlit, aby to nikoho z Fakturoidu (až si tento článek přečte) neurazilo... (-:\n\nPrvním krokem bylo \"naškytnout samotný server\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/run.js. Zde bylo potřeba nastartovat ještě samotný PhantomJS pomocí \"child_process\":https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options. Mohl jsem to udělaj jakkoliv jinak, ale takovou opičárnu jsem si vždy chtěl vyzkoušet. Samotná příprava stránky pro PhantomJS je pak \"jednoduchá\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.js. Takže server funguje a PhantomJS běží. Co dál?\n\nChtělo by to něco co by šlo renderovat. Takové minimální rozumné HTML může vypadat fakt jednoduše:\n\n/--code html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <script src=\"react.js\"></script>\n</head>\n<body>\n    <div id=\"react-root\"></div>\n    <script src=\"build/index.js\"></script>\n</body>\n</html>\n\\--\n\nKde `react.js` je samotný React a `build/index.js` obsahuje definici komponent:\n\n/--code jsx\nvar LikeButton = React.createClass({\n	render: function () {\n		return (\n			<button>LikeButton</button>\n		);\n	}\n});\n\nReact.render(<LikeButton />, document.getElementById(\'react-root\'));\n\\--\n\nJe to fakt minimální, ale funkční kód, takže si to může vyzkoušet každý. Přechozí zápis samozřejmě není JavaScript, ale \"JSX\":https://facebook.github.io/jsx/, takže je třeba jej ještě přeložit (`jsx --watch src/ build/`). Výsledný kód je pak v tomto konkrétním jednoduchém případě velmi podobný:\n\n/--code javascript\nvar LikeButton = React.createClass({displayName: \"LikeButton\",\n	render: function () {\n		return (\n			React.createElement(\"button\", null, \"LikeButton\")\n		);\n	}\n});\n\nReact.render(React.createElement(LikeButton, null), document.getElementById(\'react-root\'));\n\\--\n\nPokud se vrátím zpět k faktuře, tak její HTML \"je také velmi jednoduché\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.html a celá sranda se odehrává \"zde\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js. Zde jsem si také schválně chtěl vyzkoušet, jak reálně funguje \"Inline Styles\":https://facebook.github.io/react/tips/inline-styles.html. Samotná faktura je tedy tvořena pouze krátkým HTML a pěknou kopou JavaScriptu. Žádné CSS. Abych řekl pravdu, tak se mi s tím moc dobře nepracuje, ale to je dáno spíše tím, že zase až tolik CSS nehovím a proto bylo místy komplikované přemýšlet nad tím jak funguje React a zároveň držet v hlavě to, jak má faktura nakonec vypadat. Koukal jsem se, jak se to řeší na jiných webech jedoucích na Reactu a asi se o zase až tak nepoužívá. Ale konec naříkání. Podívejte se \"na výsledek\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.pdf.\n\nQR kód\n======\nJeště bych se rád zaměřil na samotný QR kód, který je na faktuře (\"komponenta\":https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js#L246-L269). Použil jsem \"stejnou knihovnu\":https://larsjung.de/jquery-qrcode/, kterou používám zde na blogu v záhlaví (nejlepší). Protože se jedná o QR, tak se nedá čekat, že by obsahoval něco složitého (\"podrobný popis formátu\":http://qr-platba.cz/pro-vyvojare/specifikace-formatu/):\n\n/--code\nSPD*1.0*ACC:CZ4101000000123456789101+KOMBCZPPXXX*AM:2750.00*CC:CZK*MSG:PLATBA FAKTURY 2015-0001*X-VS:20150001\n\\--\n\nJe to takový hloupý \"RESP\":http://redis.io/topics/protocol. Řetězec začíná označením formátu `SPD*1.0*` a následuje vždy výčet položek `klíč:hodnota*`, které chceme do QR kódu dostat. Povinný je pouze `ACC`, což je IBAN, popř. IBAN+BIC. Následuje částka, měna, zpráva pro příjemce a variabilní symbol.\n\nTakže úkol někdy na příště. Přepsat **V** u blogu do Reactu? (-:',	'2015-10-03 12:54:28',	0,	'2015-10-03 12:54:28',	0),
(102,	'Ještě lepší struktura Nette aplikace',	'jeste-lepsi-struktura-nette-aplikace',	'Každý, kdo postavil pár aplikací, musel vždy řešit ten samý problém. Jakou strukturu by měla aplikace mít? A co když se začne projekt rozrůstat? Měl bych se držet toho jak to dělá \"sandbox\":https://github.com/nette/sandbox (resp. \"web-project\":https://github.com/nette/web-project)? Postupem času jsem dokonvergoval k relativně přijatelnému výsledku a vzhledem k tomu, že projekt na kterém jsem to poprvé pořádně rozjel byl ukočen, \"rozhodl jsem se jej zveřejnit\":https://github.com/mrtnzlml/CMS-lite. Už je to sice nějaký čas, ale v době největšího vrcholu tohoto projektu jsem jej považoval za takovou osobní špičku. A to hned z několika důvodů. K tomu se ale dostanu postupně. A vezmu to pěkně od těch nejmenších částí.\n\nPresentery a komponenty\n=======================\nU presenterů se mi vlastně docela líbí jak to dělá sandbox. Ve složce presenterů jsou logicky presentery a také složka `templates`, která obsahuje šablony právě k těmto presenterům:\n\n/--code\npresenters/\n    templates/\n        Homepage/\n            default.latte\n        @layout.latte\n    BasePresenter.php\n    HomepagePresenter.php\n\\--\n\nDříve to bylo jinak. Šablony a presentery měl dříve sandbox na stejné úrovni, ale souhlasím s tím, že šablony patří spíše (a poměrně úzce) k presenterům. Je tedy nutné zmínit, že díky tomu jak je Nette framework chytrý, tak je v podstatě jedno jakou bude mít projekt strukturu, protože bude fungovat vše. Za chvíli se však začne vše nabalovat a bude třeba neustále udržovat pořádek. Proto je nutné mít jasno i v takto triviálních otázkách.\n\nKomponenty se od presenterů tolik neliší. Spíše naopak. Komponenty mohou být poměrně komplikované, ale rád je dělám co nejjednodušší. U komponent používám několik návrhů. Pro velmi triviální komponenty zachovávám plochou strukturu:\n\n/--code\nContactForm/\n    ContactForm.latte\n    ContactForm.php\n\\--\n\nJe totiž otrava vytvářet spoustu zbytečných složek. To platí i pro soubory. Proto jsou generované továrničky vždy k nalezení pod třídou komponenty v jednom a tom samém souboru. Jakmile se však komponenta jen o trošku zkomplikuje, automaticky přepínám do klasického presenterového stylu:\n\n/--code\nContactForm/\n    providers/\n        IContactFormTemplateProvider.php\n    templates/\n        ContactForm.latte\n    ContactForm.php\n\\---\n\nDobře, základní stavební kameny jsou položeny. Co by však mělo být okolo. A kde jsou vlastně položeny? Inu pojďme na to opět postupně.\n\nSupercore věci\n==============\nFakt nevím jak to nazvat jinak, protože ke core záležitostem se ještě dostanu. O co tedy jde? Jedná se o části aplikace, které tvoří to nejzákladnější jádro. Jádro, na které je pak možné napojovat další věci. Tuto část aplikace nechávám ve složce `app`:\n\n/--code\napp/\n    AdminModule/\n        presenters/ <-- viz první ukázka (je zde jen BasePresenter)\n    AuthModule/\n        presenters/ <-- jen SignPresenter\n    FrontModule/\n        presenters/ <-- viz první ukázka (Base, Contact, Homepage)\n    components/\n        ContactForm/ <-- také už známe (viz druhá ukázka)\n        AControl.php\n    config/\n    extensions/\n    bootstrap.php\n\\--\n\nJak je vidět, tak všechny moduly obsahují jen kritický základ. Žádné další presentery. Tak kde je zbytek? Zbytek se nechází v rootu aplikace, konkrétně ve složkách `custom` a `src`. Je celkem jedno jaký je název těchto složek, vtip je v tom nějaké mít a vše sem přesunout. Důvod proč jsou dvě je prostý. Zatímco v `src` jsou části aplikace, které tvoří jádro (tedy spoustu funkčnosti), v `custom` jsou velmi podobné částí aplikace, bez kterých lze však žít. Původní myšlenka byla taková, že se pak custom složka zruší a vše v ní se velmi elegantně rozpadne na composer balíčky. Obě složky jsou však strukturálně stejné, proto budeu řešit jen `custom`.\n\nBusiness logika\n===============\nOk, to jsem také nazval pěkně debilně. Alespoň však vysvětlím jednu důležitou věc, se kterou jsem v začátcích bojoval a kterou je potřeba se odnaučit. Sadbox vždy totiž vedl k takovéto podobné struktuře:\n\n/--code\napp/\n    config/\n    forms/\n    presenters/\n    model/\n    router/\n\\--\n\nTo nikomu nemám za zlé. Je to jednoduše pochopitelné a to je dobře. Takže s tím vlastně spíš souhlasím. Problém je v tom, že u rozrůstající aplikace už to začíná být děsný mrdník, protože `presenters` najednou obsahují všechny presentery a `model` obsahuje všechnu logiku. Ale v tom aby se prase vyznalo. Tento efekt se nechá trošku umírnit rozdělením aplikace na moduly a s tím už jsem byl (a vlastně do dneška jsem) spokojen. Jenže co s tím modelem? Fuck model! Rozdělte si model podle logických částí, které na sobě nejsou závislé a vše oddělte. Třeba takto:\n\n/--code\ncustom/\n    Error/\n    Eshop/\n    Files/\n    Notes/\n    Pages/\n\\--\n\nJak řekl kdosi moudrý, existují dva nejnáročnější problémy v programování a to správná invalidace cache a pojmenovávání věcí. Naprosot s tím souhlasím. Moc mi to nejde, ale mělo by být zřejmé, že jsou zde části, které se starají (výhradně) o eshop, o poznámky, stránky atd. Pojďme se tedy zanořit hlouběji:\n\n/--code\nPages/\n    AdminModule/\n        presenters/\n            CategoryPresenter.php\n            PagePresenter.php\n    components/\n        PageForm/\n        PagesGrid/\n    DI/\n    FrontModule/\n    listeners/\n    Category.php\n    Page.php\n    ...\n\\--\n\nA voilà, máme tu zase strukturu složky `app`. Nebo alespoň její obdobu. A v tom je síla toho návrhu. Mělo by už teď být jasnější, proč jsou v `app` právě ty věci co tam jsou. Celém vždy bylo mít v systému místa, které obsahují velmi podobné věci, ale nic dalšího. Drobné niance se zde najdou, to je jasné, ale základ zůstává. Jenže jak to sakra funguje?\n\nJak to sakra funguje\n====================\nPrávě teď je ten správný čas \"proklikat si celý systém\":https://github.com/mrtnzlml/CMS-lite. Je zřejmé, že už je to trošku komplikovanější a samo od sebe to fungovat nemůže (ani to není žádoucí). Zkušenější už tuší, že celé kouzlo je ve složce `DI`. Zde je tedy mé další doporučení. Až rozsekáte aplikaci do komponent, udělejte to samé s funkcionalitou. A víte co, udělejte to se vším co spolu nějak logicky souvisí. Proto jsem do složky `custom/Pages` umístil vše co patří ke stránkám. Komponenty, doctrine entity, servisní třídy, fasády, ale také presentery. Prostě všechno. Dělejte to tak dlouho, dokud v `app` nezůstane nic.\n\nTento způsob však s sebou nese celou řadu úskalí. Prvně je to komplikované. A pak je třeba vše napojit. Existují dva způsoby, které mi přijou v pořádku. První je poněkud agresivní, ale jednoduchý. Vychází vlastně z myšlenky \"Flame\\Modules\":http://flame-org.github.io/Modules/. Napíšete si nějaké rozšíření, které bude implementovat nějaký interface. Třeba `IFaviconProvider`. Pak je třeba mít (právě v supercore) rozšíření, které takový interface najde a při vytváření DIC zpracuje. Hodně toho využívají šablony (`custom/Versatile/DI/VersatileExtension.php`). Nebezpečí je však v tom, že se to prostě stane jakmile přidáte toto rozšíření do aplikace. Není zde moc rozumná možnost jak třeba rozšíření deaktivovat. A ještě komplikovanější je pak při vytváření DIC přeba automaticky spustit nějaký SQL dotaz.\n\nProto je zde druhý způsob (který jsem pořádně nestihl dodělat). Využívá jej například `\\Eshop\\DI\\EshopExtension`. To implementuje `ICustomExtension`. Jiné (supercore) rozšíření se toho chytí a udělá pouze to, že jej zobrazí v administraci včetně potřebných odadtečných informací. Stejně tak jako to dělá WordPress. Uživatel zde může kliknutím modul nainstalovat, což se přesně u eshopu děje a spustí se tak celá řada komplikovaných operací, které tento modul nainstalují. Jedná se zejména o předání URL adres, nastavení ACL, zaregistrování položek do menu atd. Elegantně se tak celý systém připraví a díky tomu, že dojde k registraci do DIC, není důvod k tomu, aby se s narůstajícím počtem modulů systém nějak dusil. Prostě se chová jako jakákoliv jiná velká aplikace. Nic není hledáno a řešeno dynamicky za běhu aplikace. Druhý krok je už pak dodělat instalace modulů ze vzdáleného repozitáře, ale to už je jednoduchý úkol.\n\nA je to. Elegantní instalační systém pluginů pro vaší Nette aplikaci.\n\nDalší zajímavé vlastnosti systému\n=================================\nTakže to máme peckovou strukturu aplikace, kterou je velmi jednoduché udržovat a rozšířovat + automatickou registraci modulů (pluginů chcete-li). A to jsem teprve na začátku. Proto už jen bodově vypíchnu a připomenu některé zajímavé věci, které všem dávám k dispozici.\n\n1) Každé rozšíření je v Nette nutné registrovat do konfiguračního souboru. To by s tím ale nešlo nělat takové švíky. Proto jsem napsal `\\App\\Extensions\\CoreExtension`, které to dělá automaticky. Není to zrovna ukázka čistého kódu, ale svůj účel to plní dobře. Už touto vlastností jste několik mil před konkurencí... (-:\n2) Vzpomínáte si na \"Hierarchický router\":http://zlml.cz/hierarchicky-router? Tak i ten je zde v celé své kráse. Jen pro připomenutí. Je možné měnit si URL adresy jak chcete, nikdy nepřijdete o ty staré a výkonově to nestojí nic navíc.\n3) \"Dynamické routování URL adres\":http://zlml.cz/dynamicke-routovani-url-adres. To je další fičura, kterou jen tak někdo nemá. Nebo snad ano? Použijte ji. Vybudujte něco úžasného.\n4) A co takhle Fixtures. \"Vzpomínáte si\":http://zlml.cz/fixnete-si-databazi?\n5) Všimněte si, že hodně rozšíření obsahuje jakési providery. Je tak možné jednoduše třeba zaměnit šablonu kontaktního formuláře, nebo navigace. Obdobně mohou rozšíření registrovat vlastní styly i javascriptové skripty.\n6) K dispozici jsou Doctrine migrace. K dispozici jsou v nabídce přes `php index.php`. Samotné migrační skripty jsou pak v `migrations` složce.\n\nJe toho fakt ranec, co pouštím na obdiv i kritiku. Proto ještě stručněji přehled technologií, které v projektu naleznete:\n\n- grunt + grunt-contrib packages (concat, copy, cssmin, less, uglify)\n- bootstrap, nette.ajax.js, nette-forms, jquery, selectize\n- nette (application, caching, DI, finder, forms, robot-loader, security, utils, ...)\n- latte, tracy, texy, webloader, minify, faker, secured-links\n- kdyby (doctrine, annotations, console, events, translation, autowired, monolog, ...)\n- doctrine (data-fixtures, migrations, ORM, ...)\n- testbench, nette\\tester\n\nA to jsem zde ještě nenapsal vše. Mrkněte se na náhled, nejedná se jen o nějaký marný pokus:\n\n[* 9b3c176d-4884-45c5-95c3-53cac2999d0f/admin.png *]\n\nInstalace systému\n=================\nBohužel jsem nevychytal všechny mouchy, půlka věcí zůstala nerozdělána a celý materiál je spíše pro inspiraci. Pokud by si to však někdo chtěl rozjet, dávám k dispozici také poněkud složitější návod na instalaci (viz readme):\n\n- Nainstalujte si \"GIT\":http://git-scm.com/\n- `git clone https://github.com/mrtnzlml/CMS-lite.git`\n- Nainstalujte si \"Composer\":http://getcomposer.org/\n- `composer install` (natáhne PHP závislosti)\n- Vytvořte si prázdnou MySQL databázi\n- Přejmenujte `config.local.neon.dist` (v app/config) na `config.local.neon` a nastavte přístupové údaje k databázi\n- `php index.php orm:schema-tool:create` (vygeneruje strukturu databáze)\n- `php index.php cms:fixtures:load` (našte základní data, teď už by měla aplikace fungovat)\n- Nainstalujte si \"Bower\":http://bower.io/, popř. \"npm\":https://www.npmjs.com/ je-li třeba\n- `bower install` (fetches JS dependencies)\n- Nainstalujte si \"Grunt\":http://gruntjs.com/\n- `grunt` (připraví JS, CSS, fonts, ...)\n\nKaždý příkaz by měl být spouštěn z rootu webu. Výjimku tvoří příkazy obsahující `index.php`. Ty je třeba spouštět ze složky `www`. To dá asi rozum.\n\nA na závěr. Jsem realista. Nepředpokládám, že by se projektu někdo doprovolně chytil a nakopl mě, aby v něm pokračoval aktivněji. Zatím jej spíš nikdo nepochopil a musel jsem si protrpět i pár klacků pod nohama. Proto jej dávám k dispozici jako inspiraci pro ostatní. Nemám strach, že by si to někdo přivlastnil, nebo na tom zbohatl. To si spousta firem (lidí) neuvědomuje a tak nikdo raději nezveřejňuje nic. Zveřejňujte, předávejte znalosti - nepřijdete o ně. Nicméně v rámci gentlemanské dohody bych rád vyměnil své předané znalosti za hvězdičku u tohoto nového repozitáře. Nic víc nežádám.\n\n<iframe src=\"https://ghbtns.com/github-btn.html?user=mrtnzlml&repo=CMS-lite&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"160px\" height=\"30px\"></iframe>\n\nPokorně děkuji.',	'2015-10-11 16:28:04',	0,	'2015-10-11 16:28:04',	0),
(103,	'Od indexu až po presenter',	'od-indexu-az-po-presenter',	'Když jsem se učil pracovat s Nette Frameworkem, musel jsem v začátcích hodně přivírat oči a říkat si \"prostě to tak je\". Hodně věcí bylo zahaleno do tmy. Teď už to tak naštěstí není, ale stále se stává, že mi někdo napíše a děkuje za poodhalení a vysvětlení toho, jak to funguje na pozadí (za což zase děkuji já). Pokusím se tedy pokračovat a vrátím se na úplný začátek - do `index.php` a poodhalím, jak probíhá start takové běžné aplikace. A jako vždy - co nejjednodušeji.\n\nZodpovím (nebo alespoň nastíním odpovědi na) následující otázky:\n- proč redirect vyvolává AbortException\n- jak napsat vlastní NanoPresenter\n- proč má Nette dva request objekty\n- kde se bere životní cyklus presenteru\n\nStart aplikace\n==============\nNedávno jsem dostal v práci na starost implementovat Nette do jednoho legacy projektu. Už jsem tu o tom \"psal\":http://zlml.cz/navrhovy-vzor-legacy-code. Byl to nesmírně vyčerpávající úkol, ale už mám hotovo a jsem ve fázi nekonečného refaktoringu. Jednou z prvních věcí, které bylo nutné vyřešit byl start aplikace z jednoho místa. Toto naštěstí řeší \"web-project\":https://github.com/nette/web-project (nebo \"sandbox\":https://github.com/nette/sandbox chcete-li) už v základu takto (`.htaccess`):\n\n/--code\n<IfModule mod_rewrite.c>\n	RewriteEngine On\n\n	RewriteCond %{REQUEST_FILENAME} !-f\n	RewriteCond %{REQUEST_FILENAME} !-d\n	RewriteRule !\\.(pdf|js|ico|gif|jpg|png|css|rar|zip|tar\\.gz|map)$ index.php [L]\n</IfModule>\n\\--\n\nČímž se velmi rychle dostáváme k prvnímu bodu, kterým je `index.php`:\n\n/--code php\n/** @var \\Nette\\DI\\Container $container */\n$container = require __DIR__ . \'/../app/bootstrap.php\';\n/** @var \\Nette\\Application\\Application $application */\n$application = $container->getByType(\\Nette\\Application\\Application::class);\n$application->run();\n\\--\n\nV tomto souboru vše začíná a také končí. Totiž zavolá se ještě minimálně `\\Tracy\\Debugger::shutdownHandler`, `\\Nette\\Http\\Session::clean` a `\\Nette\\Http\\Response::__destruct`, ale zůstaňme u toho, že zde vše začíná a také končí. O co v indexu vlastně jde? Hned přeskočím první řádku, ačkoliv se jedná o nezanedbatelnou část. Z bootrapu získáme hotovou instanci \"DIC\":https://doc.nette.org/cs/2.3/dependency-injection, resp. přímého potomka. Následuje vytažení \"Application\":https://api.nette.org/2.3.7/Nette.Application.Application.html a naškytnutí aplikace pomocí metody `run`. To je předpokládám všem jasné, proto jsem to vzal letem světem. Cílem tohoto článku je však popsání právě `run` metod.\n\nRun, run!\n=========\nMetoda `\\Nette\\Application\\Application::run` vypadá přesně takto:\n\n/--code php\npublic function run()\n{\n    try {\n        $this->onStartup($this);\n        $this->processRequest($this->createInitialRequest());\n        $this->onShutdown($this);\n    } catch (\\Exception $e) {\n        $this->onError($this, $e);\n        if ($this->catchExceptions && $this->errorPresenter) {\n            try {\n                $this->processException($e);\n                $this->onShutdown($this, $e);\n                return;\n            } catch (\\Exception $e) {\n                $this->onError($this, $e);\n            }\n        }\n        $this->onShutdown($this, $e);\n        throw $e;\n    }\n}\n\\--\n\nPro přehlednost to ještě zjednoduším a vyhodím vše, co pro samotné spuštění aplikace není nezbytně nutné:\n\n/--code php\npublic function run()\n{\n    try {\n        $this->processRequest($this->createInitialRequest());\n    } catch (\\Exception $e) {\n        if ($this->catchExceptions && $this->errorPresenter) {\n            $this->processException($e);\n            return;\n        }\n        throw $e;\n    }\n}\n\\--\n\nMoc toho opět nezbylo. Vlastně se zde dějí jen tři věci. Prvně \"createInitialRequest\":https://api.nette.org/2.3.7/source-Application.Application.php.html#102-124. Tato metoda vrátí (jak už název napovídá) tzv. aplikační request. To je objekt, který pak putuje celou aplikací a nese si informaci o tom co vlastně uživatel chce. Vzpomínáte si na článek o \"dynamickém routování URL adres\":http://zlml.cz/dynamicke-routovani-url-adres? Tam jsem ukazoval, jak se HTTP request změní právě na aplikační a zpět. Celá sranda se tedy odehrává někde v RouterFactory (zatím to platí, do budoucna ale \"nebude\":https://github.com/nette/routing/commit/e802a85e96f5814ddf1a16ea1517398eb560bab6). Samotný HTTP request se pak dostane do `Application` díky DI. Už v `createInitialRequest` je tedy jasné, jestli je možné požadavek přeložit, nebo 404. Pokud 404, tak konec, resp. `processException` pokud je to v configu zapnuté (což jinými slovy znamená forward na error presenter):\n\n/--code neon\napplication:\n    catchExceptions: yes\n\\--\n\nPokud se však povede získat aplikační request, nastupuje funkce `processRequest`. Mrkněte na \"implementaci\":https://api.nette.org/2.3.7/source-Application.Application.php.html#127-150. Opět se nejedná o nic složitého. Jde zde vlastně jen o jedinou věc. Získat presenter a zavolat nad ním `run`. Proč `run`? Presenter totiž není potomek `\\Nette\\Application\\UI\\Presenter` jak si pamatují skoro všichni, ale spíše objekt, který implementuje interface `\\Nette\\Application\\IPresenter` jehož jedinou metodou je právě `run` do které se jako jediný parametr předává již zmíněný aplikační request. Zároveň musí tato metoda vracet `\\Nette\\Application\\IResponse`.\n\nZ toho plyne, že pokud potřebujeme velmi jednoduchý presenter (který skoro nic neumí, ale je rychlý), stačí si implementovat `IPresenter` rozhraní a hotovo:\n\n/--code php\nclass NanoPresenter extends Nette\\Object implements Nette\\Application\\IPresenter\n{\n\n	public function run(Nette\\Application\\Request $appRequest)\n	{\n		return new Nette\\Application\\Responses\\TextResponse(\'It works!\');\n	}\n\n}\n\\--\n\nV běžném presenteru se toho však děje samozřejmě mnohem více. Právě v metodě `run` se schovává celý dobře známý životní cyklus presenteru. Než se však dostanu k reálnému příkladu, začnu na tomto jednoduchém. `NanoPresenter` vrací pouze `TextResponse` s obyčejným textem. Tato odpověď je předána zpět do `processRequest` a následně je hned zavoláno `\\Nette\\Application\\IResponse::send` což v tomto konkrétním případě vyústí v obyčejné echo. Co se však děje v běžném presenteru?\n\nVykreslení šablony\n==================\nPresenter, který dědí od `\\Nette\\Application\\UI\\Presenter` dělá téměř to samé. Jediný rozdíl je v tom, že presenter vlastně vykreslitelná komponenta, takže si vezme šablonu a předá ji stejně jako v předchozím případě do `TextResponse`. Zde je oproti mému `NanoPresenter` příkladu malý implementační rozdíl, ale ve výsledku presenter tak jako tak `TextResponse` vrátí zpět `Application` objektu do `processRequest` metody. Dále se opět zavolá `\\Nette\\Application\\Responses\\TextResponse::send`, tentokrát však nedojde k obyčejnému echu, ale spustí se renderování předané šablony (`\\Nette\\Application\\UI\\ITemplate`). Většinou to tedy propadne na Latte, ale to samozřejmě není podmínkou.\n\n/--code php\npublic function send(Nette\\Http\\IRequest $httpRequest, Nette\\Http\\IResponse $httpResponse)\n{\n    if ($this->source instanceof Nette\\Application\\UI\\ITemplate) {\n        $this->source->render();\n    } else {\n        echo $this->source;\n    }\n}\n\\--\n\nZ předchozího textu by mělo být zřejmé, kudy požadavek putuje. Když si prohlédnete detailněji to co jsem zde popsal, mělo by být jasné, že se interně používá `\\Nette\\Application\\AbortException` a proto je nebezpečné v presenterech chytat bezmyšlenkovitě všechny výjimky. Nikdo pak nechce řešit \"proč to Nette zase nepřesměrovává\".\n\nTento text by měl překlenout tu temnou propast mezi `index.php` a akcí v presenteru. Příště už se snad vrhnu na něco zajímavějšího... :)',	'2015-11-15 19:24:04',	0,	'2015-11-15 19:24:04',	0),
(104,	'Znovupoužitelné části formuláře',	'znovupouzitelne-casti-formulare',	'Před nějakým časem jsem psal o tom, jak vytvořit \"znovupoužitený formulář\":http://zlml.cz/znovupouzitelny-formular. Nejedná se o nic jiného, než o správné navržení a následné použití komponent, tedy potomků `UI\\Control`. Pokud bych měl být upřímný, nemyslím si, že se formuláře nějak často na webu opakují a osobně tento princip používám spíše pro oddělení části aplikace do samostatného balíčku. Tím spíš najde následující ukázka méně použití. Právě mám totiž za úkol navrhnout předělání jedné administrace. Úkolem není hledět na to, jak moc je tento přístup špatný, ale navrhnout řešení, které nahradí stávající 1:1. Tato administrace obsahuje často se opakující (a velmi rozsáhlý) formulář, který se skládá z několika karet. Navíc některé části formuláře spolu vůbec nesouvisí a na každé stránce je formulář trošku jiný (i když je podobnost zřejmá). Vzhledem k tomu, že se jedná o tak rozsáhlý kód, upustil jsem od znovupoužitelného formuláře a navrhnul jsem znovupoužitelné pouze jeho části. A na následujících řádcích nastíním jak.\n\nNa začátku stála komponenta\n===========================\nPořád platí, že je samotný formulář komponenta. Na tom se nic nemění. V mém případě se však hodilo udělat si ještě nějaké bázové třídy. Pokusím se ukázky ořezat co nejvíce od zbytečností tak, aby to pokud možno ještě dávalo smysl:\n\n/--code php\nclass NewsForm extends BaseControl {\n\n	/** @var News|NULL */\n	private $news;\n\n	public function __construct($news) {\n		parent::__construct();\n		$this->news = $news;\n	}\n\n	public function render() {\n		$this->template->render(__DIR__ . \'/NewsForm.latte\');\n	}\n\n	protected function createComponentNewsForm() {\n	    $form = $this->form;\n	    // nastavení společných prvků formuláře\n	    return $form\n	}\n\n}\n\\--\n\nK tomu (třeba) nějaká ta generovaná továrnička a komponenta tak jak ji známe všichni je hotova. Bude však nutné rozklíčovat, co se děje třeba pod třídou `BaseControl`. Jedná se o jednoduchého předka, který krom dalších věcí obsahuje hlavně toto:\n\n/--code php\nabstract class BaseControl extends UI\\Control {\n\n	/** @var BaseForm */\n	protected $form;\n\n	public function __construct() {\n		parent::__construct();\n		$this->form = new BaseForm;\n	}\n\n	protected function attached($obj) {\n		parent::attached($obj);\n		if ($obj instanceof UI\\Presenter) {\n			$this->form->addComponent(new SubmitButtonsContainer, \'submitButtons\');\n			$this->form->addComponent(new AnotherContainer, \'another\');\n		}\n	}\n\n}\n\\--\n\nZde se vytvoří nějaký formulář (s kterým pak pracuji v komponentě) a po připojení formuláře k presenteru se připojí i nějaké formulářové kontejnery. Než se však k těmto kontejnerům dostanu, tak by bylo dobré prozradit i co se děje v třídě `BaseForm`. Popravdě nic moc:\n\n/--code php\n/**\n * @method addTinyMCE($name, $label = NULL, $cols = NULL, $rows = NULL)\n */\nclass BaseForm extends UI\\Form {\n\n	/** @var callable[] */\n	public $onSaveAndStay;\n\n	/** @var callable[] */\n	public $onSaveAndExit;\n\n	/** @var callable[] called BEFORE onClick event */\n	public $onSuccess;\n\n	public function __construct() {\n		parent::__construct();\n		$this->addProtection();\n	}\n\n}\n\\--\n\nNastavím si zde nějaké věci, které jsou pro každý formulář v administraci obecně společné. Konkrétně tedy CSRF ochranu a pár polí pro události. Události jsem si zde musel nadefinovat sám, běžně se na formuláři volá `onSuccess` událost až po `onClick` (\"link\":https://api.nette.org/2.3.7/source-Forms.Form.php.html#380-420), ale zrovna zde jsem to potřeboval obráceně. Hodí se to v okamžiku, kdy chci využívat `onSuccess`, ale v `onClick` už z formuláře třeba přesměrovávám pryč. Vzhledem k tomu, že oba eventy se volají jen při validním odeslání, tak to ničemu nevadí. V této třídě je také vhodné místo pro umístění nějakých dynamických metod do anotací, aby je IDE dobře napovídalo (viz `addTinyMCE`). Byl to dlouhý úvod, ale vše je připraveno a můžeme se vrhnout na kontejnery.\n\nFormulářové kontejnery\n======================\nOsobně \"formulářové kontejnery\":https://pla.nette.org/cs/dedicnost-vs-kompozice nemám moc rád. Jsou sice super, ale pohybují se na další úrovni formuláře. Pokud se však s tímto faktem smíříme (a nejlépe z něj uděláme výhodu), pak jsou docela super a zde se skvěle hodí. Můžu si pěkně oddělit například odesílací tlačítka a ty pak vesele používat ve všech formulářích:\n\n/--code php\nclass SubmitButtonsContainer extends BaseFormContainer {\n\n	private $form;\n\n	public function attached($obj) {\n		parent::attached($obj);\n		if ($obj instanceof BaseForm) {\n			$this->form = $obj;\n			$obj->onSuccess[] = function (BaseForm $form) {\n				$path = $this->lookupPath(BaseForm::class);\n				dump($form->getValues()->$path); // další zpracování hodnot\n			};\n		}\n	}\n\n	public function render() {\n		$this->template->_form = $this; // kvůli formulářovým makrům v šabloně\n		$this->template->render(__DIR__ . \'/SubmitButtonsContainer.latte\');\n	}\n\n	protected function configure() {\n		$this->addSubmit(\'saveAndStay\', \'Uložit a zůstat\')->onClick[] = function (SubmitButton $button) {\n            $form = $button->getForm();\n            $this->form->onSuccess($form, $form->getValues());\n            $this->form->onSaveAndStay($form, $form->getValues());\n		};\n	}\n\n}\n\\--\n\nPokud sledujete fórum, tak vám je tento návrh jistě povědomý. Jedná se o \"slavné řešení pod čarou\":https://forum.nette.org/cs/11747-skladani-komponent-a-formulare#p84652. Přesně toto se odehrává v rodičovské třídě `BaseFormContainer`. Doplnil jsem si do této třídy však jednu malou vychytávku. Chtěl jsem totiž, aby každý kontejner mohl mít vlastní šablonu. To běžně není možné. Kontejner tedy mohu vykreslovat pomocí dobře známého makra `{control ...}` (což nedělá nic jiného, než že se zavolá metoda `render`). Jenže co je `$this->template`? Bázový kontejner jsem musel rozšířit ještě o vhodnou část z `UI\\Control`, která se stará o vykreslování:\n\n/--code php\nabstract class BaseFormContainer extends Forms\\Container {\n\n	/** @var UI\\ITemplateFactory */\n	private $templateFactory;\n\n	/** @var UI\\ITemplate */\n	private $template;\n\n    public function injectTemplateFactory(UI\\ITemplateFactory $templateFactory) {\n		$this->templateFactory = $templateFactory;\n	}\n\n	abstract public function render();\n\n    public function getTemplate() {\n		// bla bla, mrkni na: https://api.nette.org/2.3.7/source-Application.UI.Control.php.html#45\n		return $this->template;\n	}\n\n	protected function createTemplate() {\n		/** @var UI\\ITemplateFactory $templateFactory */\n		$templateFactory = $this->templateFactory ?: $this->lookup(UI\\Presenter::class)->getTemplateFactory();\n		return $templateFactory->createTemplate(NULL);\n	}\n\\--\n\nJednoduché vykreslitelné formulářové kontejnery. Cool. Abych to rychle zrekapituloval. Máme jednoduchou komponentu na formulář, která dědí od `BaseControl`. Tato třída připojuje ve vhodný čas formulářové kontejnery, které se umí vykreslit (což běžně nejde).\n\nV šabloně `SubmitButtonsContainer.latte` je možné používat normálně `{input ...}` makra a další, jako kdybych pokračoval dál v šabloně jednoho velkého formuláře. Samotné připojené formulářové kontejnery je možné vykreslovat pomocí klasického makra `{control newsForm-submitButtons}` v hlavním formuláři. To je možná trošku nevýhoda, protože kontejnery se připojují do formuláře a stávají se tak podkomponentou. Musím tedy control makro volat stylem *rodič-podkomponenta*.\n\nZnovupoužitelnost vykreslitelných kontejnerů\n============================================\nKde je ta znovupoužitelnost? Jak bych udělal to, že použiju třeba odesílací tlačítka (nebo jakoukoliv jinou část formuláře) někde jinde? Jednoduše. Prostě vytvoříme formulář (to je podmínka nutná) a kontejner v něm použijeme:\n\n/--code php\nprotected function createComponentTest() {\n    $form = new UI\\Form;\n    $form->addComponent(new AnotherContainer, \'another\');\n    $form->addSubmit(\'odeslat\', \'Odeslat\');\n    $form->onSuccess[] = function ($_, ArrayHash $values) {\n        dump($values);\n    };\n    return $form;\n}\n\\--\n\nK tomu třeba nějaká taková šablona:\n\n/--code\n{form test}\n    {control test-another}\n    {input odeslat}\n{/form}\n\\--\n\nFormulář se samozřejmě vykreslí i při obyčejném `{control test}`, ale bez šablony kontejneru (píšu si nápad na vylepšení). Vlastně je ta myšlenka docela jednoduchá, že? Jen je třeba dát pozor na to, že kontejner takto umisťuje formulářové prvky na jinou úroveň.\n\nMalá poznámka na závěr, která je sice mimo, ale může se hodit. Občas je potřeba zajistit si někde inject závislostí, ale z nějakého důvodu je to problematické. Může se jednat třeba o závislost v abstraktní rodičovské třídě. V takovém případě je možné v configu nastavit \"decorator\":https://github.com/dg/nette-di/blob/master/tests/DI/DecoratorExtension.basic.phpt:\n\n/--code neon\ndecorator:\n	BaseFormContainer:\n		inject: on\n\\--\n\nPříště se podíváme znovu na \"Dependent select box\":http://zlml.cz/dependent-select-box. Původní článek si totiž zaslouží důkladnou revizi a po krátké anketě jsem byl přesvědčen, že bude lepší napsat nový článek a podívat se na celý problém podrobněji.',	'2015-11-24 23:46:16',	0,	'2015-11-24 23:46:16',	0);

DELIMITER ;;

CREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW
INSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body, NEW.date);;

CREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW
UPDATE mirror_posts SET
    id = NEW.id,
    title = NEW.title,
    body = NEW.body,
    date = NEW.date
WHERE id = OLD.id;;

CREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW
DELETE FROM mirror_posts WHERE id = OLD.id;;

DELIMITER ;

DROP TABLE IF EXISTS `posts_tags`;
CREATE TABLE `posts_tags` (
  `tag_id` int(11) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`post_id`,`tag_id`),
  KEY `IDX_D5ECAD9F4B89032C` (`post_id`),
  KEY `IDX_D5ECAD9FBAD26311` (`tag_id`),
  CONSTRAINT `FK_D5ECAD9F4B89032C` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`) ON DELETE CASCADE,
  CONSTRAINT `FK_D5ECAD9FBAD26311` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts_tags` (`tag_id`, `post_id`) VALUES
(52,	2),
(51,	3),
(43,	4),
(42,	9),
(42,	10),
(41,	11),
(42,	11),
(77,	11),
(41,	45),
(42,	45),
(44,	45),
(41,	46),
(42,	46),
(41,	47),
(42,	47),
(45,	49),
(41,	50),
(42,	50),
(45,	50),
(41,	51),
(77,	51),
(42,	52),
(46,	52),
(41,	53),
(41,	54),
(47,	54),
(48,	54),
(49,	55),
(50,	56),
(41,	57),
(41,	58),
(41,	59),
(52,	60),
(53,	61),
(41,	62),
(42,	62),
(54,	62),
(46,	63),
(55,	63),
(41,	64),
(56,	64),
(57,	64),
(58,	65),
(59,	67),
(52,	68),
(60,	69),
(61,	69),
(41,	70),
(47,	70),
(48,	70),
(41,	71),
(62,	71),
(53,	72),
(63,	73),
(41,	74),
(62,	74),
(47,	76),
(64,	76),
(61,	77),
(41,	78),
(58,	78),
(49,	79),
(65,	79),
(66,	80),
(67,	80),
(68,	80),
(65,	81),
(66,	81),
(67,	81),
(41,	82),
(69,	82),
(47,	84),
(66,	84),
(70,	85),
(71,	85),
(51,	86),
(72,	86),
(41,	87),
(47,	87),
(48,	87),
(70,	88),
(73,	88),
(74,	88),
(47,	89),
(73,	89),
(74,	89),
(41,	90),
(69,	90),
(74,	91),
(75,	91),
(47,	92),
(74,	92),
(41,	93),
(63,	94),
(41,	95),
(62,	95),
(76,	95),
(41,	96),
(62,	96),
(69,	96),
(49,	97),
(41,	98),
(77,	98),
(41,	99),
(62,	99),
(77,	99),
(41,	100),
(78,	100),
(74,	101),
(79,	101),
(80,	101),
(41,	102),
(62,	102),
(69,	102),
(41,	103),
(42,	103),
(41,	104),
(42,	104);

DROP TABLE IF EXISTS `settings`;
CREATE TABLE `settings` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `key` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UNIQ_E545A0C54E645A7E` (`key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

INSERT INTO `settings` (`id`, `key`, `value`) VALUES
(1,	'show_content',	'1'),
(2,	'random_search',	'1'),
(3,	'show_comments',	'1'),
(4,	'show_print',	'1'),
(5,	'disable_blog',	'0'),
(6,	'disqus_shortname',	'mrtnzlml'),
(7,	'ga_code',	'UA-39142238-1');

DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `color` varchar(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `tags` (`id`, `name`, `color`) VALUES
(41,	'nette',	'106dcf'),
(42,	'php',	'aa16b1'),
(43,	'html',	'1c7640'),
(44,	'tester',	'9f1857'),
(45,	'sql',	'7608de'),
(46,	'pcre',	'a69d02'),
(47,	'javascript',	'a4423a'),
(48,	'ajax',	'706753'),
(49,	'úvaha',	'0a8b93'),
(50,	'latex',	'c51cdd'),
(51,	'math',	'256781'),
(52,	'crypto',	'de3446'),
(53,	'bezpečnost',	'33b1d7'),
(54,	'git',	'07269c'),
(55,	'vlna',	'd51082'),
(56,	'texy',	'28009d'),
(57,	'fshl',	'558fed'),
(58,	'RFC',	'780672'),
(59,	'stats',	'd45a45'),
(60,	'QR',	'f4512c'),
(61,	'matrix',	'730dd0'),
(62,	'doctrine',	'3ba8ca'),
(63,	'barcamp',	'7c3448'),
(64,	'disqus',	'97871f'),
(65,	'API',	'a1520c'),
(66,	'odoo',	'a24689'),
(67,	'python',	'cb5a16'),
(68,	'xml',	'66bb15'),
(69,	'kdyby',	'5b950f'),
(70,	'stm32',	'58ab4f'),
(71,	'C',	'ce412e'),
(72,	'JSON',	'9f990f'),
(73,	'IoT',	'3b5074'),
(74,	'NodeJS',	'344c28'),
(75,	'redis',	'a41a11'),
(76,	'posobota',	'6bc034'),
(77,	'routování',	'8b0291'),
(78,	'legacy',	'14a830'),
(79,	'React',	'247481'),
(80,	'PhantomJS',	'7a20ac');

DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) NOT NULL,
  `password` varchar(100) NOT NULL,
  `role` varchar(20) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UNIQ_1483A5E9F85E0677` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `users` (`id`, `username`, `password`, `role`) VALUES
(1,	'martin',	'$2y$10$39OQqbxEVjby7x1kpRnH8eXjxyM3ARSFhyRrTShmTE8osiCdnbytq',	'admin'),
(2,	'demo',	'$2y$10$2SdneWBxW3y4f2qGKE6fi.dvJzBT4JKdo3Rmrv/2hd66WePZ8EOW2',	'demo');

-- 2015-11-29 11:43:19
